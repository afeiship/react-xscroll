{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-xscroll.js","webpack:///webpack/bootstrap 3751897750118c5c0894","webpack:///./src/main.js","webpack:///./~/xscroll/build/cmd/util.js","webpack:///./~/xscroll/build/cmd/base.js","webpack:///./~/xscroll/build/cmd/animate.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./~/xscroll/build/cmd/hammer.js","webpack:///./~/xscroll/build/cmd/core.js","webpack:///./~/xscroll/build/cmd/easing.js","webpack:///./~/xscroll/build/cmd/timer.js","webpack:///./src/components/react-xscroll.js","webpack:///./src/components/style.plug.pulldown.scss","webpack:///./src/components/style.plug.pullup.scss","webpack:///./src/components/style.scss","webpack:///./src/components/style.plug.pulldown.scss?663a","webpack:///./src/components/style.plug.pullup.scss?c773","webpack:///./src/components/style.scss?3726","webpack:///./~/xscroll/build/cmd/boundry.js","webpack:///./~/xscroll/build/cmd/components/controller.js","webpack:///./~/xscroll/build/cmd/components/fixed.js","webpack:///./~/xscroll/build/cmd/components/scrollbar.js","webpack:///./~/xscroll/build/cmd/components/sticky.js","webpack:///./~/xscroll/build/cmd/events.js","webpack:///./~/xscroll/build/cmd/origin-scroll.js","webpack:///./~/xscroll/build/cmd/plugins/infinite.js","webpack:///./~/xscroll/build/cmd/plugins/pulldown.js","webpack:///./~/xscroll/build/cmd/plugins/pullup.js","webpack:///./~/xscroll/build/cmd/simulate-scroll.js","webpack:///./~/xscroll/build/cmd/xscroll.js","webpack:///external \"classnames\"","webpack:///external \"react\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_29__","__WEBPACK_EXTERNAL_MODULE_30__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_reactXscroll","_reactXscroll2","__WEBPACK_AMD_DEFINE_RESULT__","Empty","createObject","proto","constructor","newProto","create","prototype","getNodes","node","rootNode","nodeType","document","querySelectorAll","SUBSTITUTE_REG","EMPTY","RE_TRIM","trim","String","_trim","str","replace","idCounter","getOffsetTop","el","offset","offsetTop","offsetParent","getOffsetLeft","offsetLeft","Util","isObject","isArray","Array","toString","isEmpty","isString","length","key","has","mix","to","from","deep","i","extend","r","s","px","sx","rp","sp","superclass","startsWith","prefix","lastIndexOf","endsWith","suffix","ind","indexOf","substitute","o","regexp","match","name","charAt","slice","undefined","vendor","transform","createElement","style","vendors","l","substr","prefixStyle","attrName","toUpperCase","hasClass","className","addClass","removeClass","remove","parentNode","removeChild","findParentEl","selector","rs","parent","type","test","sel","querySelector","body","tagName","toLowerCase","guid","isAndroid","window","navigator","appVersion","isBadAndroid","px2Num","Number","getNode","nodes","stringifyStyle","styleStr","join","names","Events","Base","plug","plugin","self","pluginId","__plugins","__plugin","getPlugin","unplug","pluginInitializer","push","_plugin","pluginDestructor","splice","plugins","myParse","v","Math","round","parseFloat","defaultDecompose","translateX","translateY","rotate","skewX","skewY","scaleX","scaleY","toMatrixArray","matrix","split","map","decomposeMatrix","skew","A","B","C","D","sqrt","atan2","PI","atan","getTransformInfo","prop","val","ret","Animate","cfg","css","duration","easing","delay","run","timer","Timer","on","_bindEvt","computeTransform","prevTransform","destTransform","dest","trans","prevVal","newVal","setStyle","styleName","percent","isNaN","curVal","vendorTransform","Easing","vendorTransition","vendorTransitionEnd","translateTpl","animAttrs","opacity","scrollTop","scrollLeft","__isTransitionEnd","clearTimeout","__itv","MIN_DURATION","stop","__handlers","useTransition","format","setTimeout","trigger","computeStyle","getComputedStyle","transmap","off","transRun","_transitionEndHandler","e","newTrans","end","addEventListener","target","currentTarget","cssRun","reset","list","result","item","mediaQuery","alreadyImportedModules","addStylesToDom","styles","options","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","Error","removeStyleElement","idx","createStyleElement","createLinkElement","linkElement","rel","update","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","encodeURIComponent","JSON","stringify","blob","oldSrc","memoize","fn","memo","apply","arguments","isOldIE","userAgent","getElementsByTagName","newList","mayRemove","textStore","replacement","filter","Boolean","setTimeoutContext","timeout","context","bindFn","invokeArrayArg","arg","each","iterator","forEach","hasOwnProperty","src","merge","keys","inherit","child","base","properties","childP","baseP","_super","boolOrFn","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","removeEventListeners","removeEventListener","hasParent","inStr","find","inArray","findByKey","toArray","uniqueArray","sort","results","values","a","b","prefixed","property","camelProp","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","Input","manager","callback","inputTarget","domHandler","ev","enable","init","createInputInstance","Type","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","now","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","scale","getScale","rotation","getRotation","computeIntervalInputData","srcEvent","offsetDelta","prevDelta","x","y","velocity","velocityX","velocityY","direction","last","lastInterval","COMPUTE_INTERVAL","getVelocity","abs","clientX","clientY","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","props","PROPS_XY","start","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","allow","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","all","touches","changed","changedTouches","concat","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","identifier","targetTouches","changedTargetTouches","touch","mouse","TouchAction","set","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","get","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","Hammer","recognizers","preset","Manager","handlers","touchAction","toggleCssProps","add","recognizeWith","requireFailure","cssProps","triggerDomEvent","event","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TEST_ELEMENT","Date","MOBILE_REGEX","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","MSPointerEvent","removePointer","eventTypeNormalized","isTouch","storeIndex","pointerId","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","compute","getTouchAction","preventDefaults","prevented","preventDefault","hasNone","preventSrc","STATE_RECOGNIZED","STATE_FAILED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","withState","tryEmit","canEmit","inputDataClone","process","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","STOP","FORCED_STOP","force","stopped","curRecognizer","existing","events","Tap","Pan","Swipe","Pinch","Rotate","Press","XScroll","userConfig","Boundry","Sticky","Fixed","BOUNDRY_CHECK_DURATION","BOUNDRY_CHECK_EASING","BOUNDRY_CHECK_ACCELERATION","version","defaultCfg","bounce","boundryCheck","gpuAcceleration","useOriginScroll","zoomType","indicatorInsets","top","bottom","left","right","width","spacing","container","content","stickyElements","fixedElements","renderTo","__timers","elCfg","parse","getAttribute","boundry","refresh","mc","sticky","fixed","_initContainer","enableGPUAcceleration","disableGPUAcceleration","getScrollPos","getScrollLeft","getScrollTop","scrollTo","scrollBy","scrollByX","scrollByY","scrollLeftBy","scrollTopBy","resetSize","renderToStyle","containerWidth","offsetWidth","height","offsetHeight","containerHeight","render","initSticky","initFixed","initTouchAction","xscroll","fixedRenderTo","stickyRenderTo","boundryCheckX","boundryCheckY","___isEvtBind","tap","pan","touchEvents","_resetLockConfig","linear","ease","ease-in","ease-out","ease-in-out","quadratic","circular","Bezier","x1","y1","x2","y2","epsilon","curveX","t","curveY","derivativeCurveX","t0","t1","t2","d2","RAF","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","cancelRAF","cancelAnimationFrame","isfinished","_stop","_hasFinishedPercent","easingFn","_run","_raf","progress","param","originPercent","React","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","enumerable","writable","configurable","setPrototypeOf","__proto__","_createClass","defineProperties","descriptor","protoProps","staticProps","_xscroll","_xscroll2","_pullup","_pullup2","_pulldown","_pulldown2","_infinite","_infinite2","_classnames","_classnames2","uid","ReactXScroll","_React$Component","_this","getPrototypeOf","_renderId","cssClass","assign","xscrollOptions","pullupOptions","pullup","onInfinite","pulldownOptions","pulldown","onRefresh","infiniteOptions","infinite","createIscroll","createInfinitePlugin","createPullUpPlugin","createPullDownPlugin","inName","nextProps","setState","children","Component","propTypes","PropTypes","string","object","func","defaultProps","locals","_xtop","_xright","_xleft","_xbottom","resetTop","resetLeft","resetBottom","resetRight","expandTop","expandLeft","expandRight","expandBottom","Controller","scroll","captureBounce","stopPropagation","__scrolls","parentscroll","_bind","subscroll","_unbind","sub","lockY","isBoundryOut","getBoundryOutTop","getBoundryOutBottom","lockX","getBoundryOutLeft","getBoundryOutRight","xscrollConfig","isY","_","originalFixedElements","getFixedElements","renderFixedElement","els","__serializedData","position","fixedIndex","isRender","fixedElement","display","_top","renderHook","innerHTML","originalFixedElement","MAX_BOUNCE_DISTANCE","MIN_BAR_SCROLLED_SIZE","MIN_BAR_SIZE","transformStr","transition","ScrollBar","scrollTopOrLeft","scrollbar","_scrollHandler","_scrollEndHandler","translateZ","commonCss","indicate","size","_update","hide","pos","barInfo","computeScrollBar","moveTo","containerSize","indicateSize","barPos","barSize","overTop","overBottom","barShiftSize","pct","show","config","__timer","isBoundryOutTop","isBoundryOutBottom","isBoundryOutLeft","isBoundryOutRight","__isEvtBind","defaultStickyRenderFunc","stickyElement","curStickyElement","forceSticky","stickyRenderFunc","_handlers","getStickiesPos","isInfinite","stickiesPos","getPos","_left","_height","_width","stickiesNum","createStickyEl","getStickyElements","serializedData","rowData","stickyHandler","indexes","curStickyIndex","max","prevStickyIndex","curStickyPos","eventsObj","_stickyRenderFunc","cur","next","_once","ran","eventsApi","_events","ctx","once","_callback","remaining","k","allEvents","triggerEvents","listenTo","listeningTo","_listeningTo","_listenId","listenToOnce","cb","stopListening","eventSplitter","action","rest","a1","a2","a3","unbind","OriginScroll","Core","Infinite","visibleElements","sections","translate","_initInfinite","infiniteLength","infiniteElements","visibility","_updateByScroll","_cellEventsHandler","infiniteElementsCache","tmp","elementsPos","_renderUnRecycledEl","unrecycledEl","getElementById","randomId","getVisibleElements","_computeDomPositions","_containerSize","_updateByRender","_getChangedRows","newElementsPos","changedRows","recycled","_pos","_pushEl","elObj","_popEl","__infiniteIndex","_renderData","_renderStyle","console","warn","prevEl","newEl","prevElementsPos","section","len","sectionId","maxSpeed","_visible","elementObj","getCell","_isEvtBinded","webkitTransition","cell","cellEl","panstart","panend","insertAfter","append","number","Plugins","clsPrefix","loadingContent","PullDown","autoRefresh","downContent","upContent","_panStartHandler","_panHandler","_panEndHandler","__isRender","_evtBinded","containerCls","lineHeight","textAlign","status","_changeStatus","_expanded","loadingItv","location","reload","PULL_UP_HEIGHT","HEIGHT","PullUp","pullUpHeight","bufferHeight","isLoading","complete","SimuScroll","PAN_RATE","SCROLL_ACCELERATION","BOUNDRY_ACCELERATION","transformOrigin","preventTouchMove","_setOverflowBehavior","defaltConfig","overflow","_ontouchstart","_ontouchmove","destroyScrollBars","scrollbarX","scrollbarY","__isContainerInited","transY","transX","_animate","_ontap","_unPreventHref","isRealScrollingX","isRealScrollingY","_triggerClick","_preventHref","pinch","_onpanstart","_onpan","_onpanend","thresholdY","thresholdX","__topstart","__leftstart","directionX","directionY","triggerType","computeScroll","boundryStart","boundryEnd","innerSize","_s","_t","v0","_t2","s2","isScrollingX","isScrollingY","initScrollBars","initController","controller","initMouseEvent","view","screenX","screenY","ctrlKey","altKey","shiftKey","metaKey"],"mappings":"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","file":"react-xscroll.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"classnames\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"classnames\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactXscroll\"] = factory(require(\"classnames\"), require(\"react\"));\n\telse\n\t\troot[\"ReactXscroll\"] = factory(root[\"classnames\"], root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_30__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"classnames\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"classnames\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactXscroll\"] = factory(require(\"classnames\"), require(\"react\"));\n\telse\n\t\troot[\"ReactXscroll\"] = factory(root[\"classnames\"], root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_29__, __WEBPACK_EXTERNAL_MODULE_30__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _reactXscroll = __webpack_require__(10);\n\t\n\tvar _reactXscroll2 = _interopRequireDefault(_reactXscroll);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = _reactXscroll2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar SUBSTITUTE_REG = /\\\\?\\{([^{}]+)\\}/g,\n\t\tEMPTY = '';\n\t\n\tvar RE_TRIM = /^[\\s\\xa0]+|[\\s\\xa0]+$/g,\n\t\ttrim = String.prototype.trim;\n\t\n\tvar _trim = trim ?\n\t\tfunction(str) {\n\t\t\treturn str == null ? EMPTY : trim.call(str);\n\t\t} : function(str) {\n\t\t\treturn str == null ? EMPTY : (str + '').replace(RE_TRIM, EMPTY);\n\t\t};\n\t\n\tfunction upperCase() {\n\t\treturn arguments[1].toUpperCase();\n\t}\n\t\n\tfunction Empty() {}\n\t\n\tfunction createObject(proto, constructor) {\n\t\tvar newProto;\n\t\tif (Object.create) {\n\t\t\tnewProto = Object.create(proto);\n\t\t} else {\n\t\t\tEmpty.prototype = proto;\n\t\t\tnewProto = new Empty();\n\t\t}\n\t\tnewProto.constructor = constructor;\n\t\treturn newProto;\n\t}\n\t\n\tfunction getNodes(node, rootNode) {\n\t\tif (!node) return;\n\t\tif (node.nodeType) return [node];\n\t\tvar rootNode = rootNode && rootNode.nodeType ? rootNode : document;\n\t\tif (node && typeof node === \"string\") {\n\t\t\treturn rootNode.querySelectorAll(node);\n\t\t}\n\t\treturn;\n\t}\n\t\n\t// Useful for temporary DOM ids.\n\tvar idCounter = 0;\n\t\n\tvar getOffsetTop = function(el) {\n\t\tvar offset = el.offsetTop;\n\t\tif (el.offsetParent != null) offset += getOffsetTop(el.offsetParent);\n\t\treturn offset;\n\t};\n\tvar getOffsetLeft = function(el) {\n\t\tvar offset = el.offsetLeft;\n\t\tif (el.offsetParent != null) offset += getOffsetLeft(el.offsetParent);\n\t\treturn offset;\n\t};\n\t\n\tvar Util = {\n\t\t// Is a given variable an object?\n\t\tisObject: function(obj) {\n\t\t\treturn obj === Object(obj);\n\t\t},\n\t\tisArray: Array.isArray || function(obj) {\n\t\t\treturn toString.call(obj) == '[object Array]';\n\t\t},\n\t\t// Is a given array, string, or object empty?\n\t\t// An \"empty\" object has no enumerable own-properties.\n\t\tisEmpty: function(obj) {\n\t\t\tif (obj == null) return true;\n\t\t\tif (this.isArray(obj) || this.isString(obj)) return obj.length === 0;\n\t\t\tfor (var key in obj)\n\t\t\t\tif (this.has(obj, key)) return false;\n\t\t\treturn true;\n\t\t},\n\t\tmix: function(to, from, deep) {\n\t\t\tfor (var i in from) {\n\t\t\t\tto[i] = from[i];\n\t\t\t}\n\t\t\treturn to;\n\t\t},\n\t\textend: function(r, s, px, sx) {\n\t\t\tif (!s || !r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tvar sp = s.prototype,\n\t\t\t\trp;\n\t\t\t// add prototype chain\n\t\t\trp = createObject(sp, r);\n\t\t\tr.prototype = this.mix(rp, r.prototype);\n\t\t\tr.superclass = createObject(sp, s);\n\t\t\t// add prototype overrides\n\t\t\tif (px) {\n\t\t\t\tthis.mix(rp, px);\n\t\t\t}\n\t\t\t// add object overrides\n\t\t\tif (sx) {\n\t\t\t\tthis.mix(r, sx);\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\t\t/**\n\t\t * test whether a string start with a specified substring\n\t\t * @param {String} str the whole string\n\t\t * @param {String} prefix a specified substring\n\t\t * @return {Boolean} whether str start with prefix\n\t\t * @member util\n\t\t */\n\t\tstartsWith: function(str, prefix) {\n\t\t\treturn str.lastIndexOf(prefix, 0) === 0;\n\t\t},\n\t\n\t\t/**\n\t\t * test whether a string end with a specified substring\n\t\t * @param {String} str the whole string\n\t\t * @param {String} suffix a specified substring\n\t\t * @return {Boolean} whether str end with suffix\n\t\t * @member util\n\t\t */\n\t\tendsWith: function(str, suffix) {\n\t\t\tvar ind = str.length - suffix.length;\n\t\t\treturn ind >= 0 && str.indexOf(suffix, ind) === ind;\n\t\t},\n\t\t/**\n\t\t * Removes the whitespace from the beginning and end of a string.\n\t\t * @method\n\t\t * @member util\n\t\t */\n\t\ttrim: _trim,\n\t\t/**\n\t\t * Substitutes keywords in a string using an object/array.\n\t\t * Removes undef keywords and ignores escaped keywords.\n\t\t * @param {String} str template string\n\t\t * @param {Object} o json data\n\t\t * @member util\n\t\t * @param {RegExp} [regexp] to match a piece of template string\n\t\t */\n\t\tsubstitute: function(str, o, regexp) {\n\t\t\tif (typeof str !== 'string' || !o) {\n\t\t\t\treturn str;\n\t\t\t}\n\t\n\t\t\treturn str.replace(regexp || SUBSTITUTE_REG, function(match, name) {\n\t\t\t\tif (match.charAt(0) === '\\\\') {\n\t\t\t\t\treturn match.slice(1);\n\t\t\t\t}\n\t\t\t\treturn (o[name] === undefined) ? EMPTY : o[name];\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * vendors\n\t\t * @return { String } webkit|moz|ms|o\n\t\t * @memberOf Util\n\t\t */\n\t\tvendor: (function() {\n\t\t\tvar el = document.createElement('div').style;\n\t\t\tvar vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],\n\t\t\t\ttransform,\n\t\t\t\ti = 0,\n\t\t\t\tl = vendors.length;\n\t\t\tfor (; i < l; i++) {\n\t\t\t\ttransform = vendors[i] + 'ransform';\n\t\t\t\tif (transform in el) return vendors[i].substr(0, vendors[i].length - 1);\n\t\t\t}\n\t\t\treturn false;\n\t\t})(),\n\t\t/**\n\t\t *  add vendor to attribute\n\t\t *  @memberOf Util\n\t\t *  @param {String} attrName name of attribute\n\t\t *  @return { String }\n\t\t **/\n\t\tprefixStyle: function(attrName) {\n\t\t\tif (this.vendor === false) return false;\n\t\t\tif (this.vendor === '') return attrName;\n\t\t\treturn this.vendor + attrName.charAt(0).toUpperCase() + attrName.substr(1);\n\t\t},\n\t\t/**\n\t\t * judge if has class\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t * @param  {String}  className\n\t\t * @return {Boolean}\n\t\t */\n\t\thasClass: function(el, className) {\n\t\t\treturn el && el.className && className && el.className.indexOf(className) != -1;\n\t\t},\n\t\t/**\n\t\t * add className for the element\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t * @param  {String}  className\n\t\t */\n\t\taddClass: function(el, className) {\n\t\t\tif (el && className && !this.hasClass(el, className)) {\n\t\t\t\tel.className += \" \" + className;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * remove className for the element\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t * @param  {String}  className\n\t\t */\n\t\tremoveClass: function(el, className) {\n\t\t\tif (el && el.className && className) {\n\t\t\t\tel.className = el.className.replace(className, \"\");\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * remove an element\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t */\n\t\tremove: function(el) {\n\t\t\tif (!el || !el.parentNode) return;\n\t\t\tel.parentNode.removeChild(el);\n\t\t},\n\t\t/**\n\t\t * get offset top\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}   el\n\t\t * @return {Number} offsetTop\n\t\t */\n\t\tgetOffsetTop: getOffsetTop,\n\t\t/**\n\t\t * get offset left\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t * @return {Number} offsetLeft\n\t\t */\n\t\tgetOffsetLeft: getOffsetLeft,\n\t\t/**\n\t\t * get offset left\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement} el\n\t\t * @param  {String} selector\n\t\t * @param  {HTMLElement} rootNode\n\t\t * @return {HTMLElement} parent element\n\t\t */\n\t\tfindParentEl: function(el, selector, rootNode) {\n\t\t\tvar rs = null,\n\t\t\t\tparent = null;\n\t\t\tvar type = /^#/.test(selector) ? \"id\" : /^\\./.test(selector) ? \"class\" : \"tag\";\n\t\t\tvar sel = selector.replace(/\\.|#/g, \"\");\n\t\t\tif (rootNode && typeof rootNode === \"string\") {\n\t\t\t\trootNode = document.querySelector(rootNode);\n\t\t\t}\n\t\t\trootNode = rootNode || document.body;\n\t\t\tif (!el || !selector) return;\n\t\t\tif (type == \"class\" && el.className && el.className.match(sel)) {\n\t\t\t\treturn el;\n\t\t\t} else if (type == \"id\" && el.id && _trim(el.id) == sel) {\n\t\t\t\treturn el;\n\t\t\t} else if (type == \"tag\" && el.tagName.toLowerCase() == sel) {\n\t\t\t\treturn el;\n\t\t\t}\n\t\t\twhile (!rs) {\n\t\t\t\tif (parent == rootNode) break;\n\t\t\t\tparent = el.parentNode;\n\t\t\t\tif (!parent) break;\n\t\t\t\tif ((type == \"class\" && parent.className && parent.className.match(sel)) || (type == \"id\" && parent.id && _trim(parent.id) == sel) || (type == \"tag\" && parent.tagName && parent.tagName.toLowerCase() == sel)) {\n\t\t\t\t\trs = parent\n\t\t\t\t\treturn rs;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tel = parent;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * Generate a unique integer id (unique within the entire client session).\n\t\t * @param  {String} prefix\n\t\t * @return {String} guid\n\t\t */\n\t\tguid: function(prefix) {\n\t\t\tvar id = ++idCounter + '';\n\t\t\treturn prefix ? prefix + id : id;\n\t\t},\n\t\t/**\n\t\t * judge if is an android os\n\t\t * @return {Boolean} [description]\n\t\t */\n\t\tisAndroid: function() {\n\t\t\treturn /Android /.test(window.navigator.appVersion);\n\t\t},\n\t\t/**\n\t\t * judge if is an android device with low  performance\n\t\t * @return {Boolean}\n\t\t */\n\t\tisBadAndroid: function() {\n\t\t\treturn /Android /.test(window.navigator.appVersion) && !(/Chrome\\/\\d/.test(window.navigator.appVersion))\n\t\t},\n\t\tpx2Num: function(px) {\n\t\t\treturn Number(px.replace(/px/, ''));\n\t\t},\n\t\tgetNodes: getNodes,\n\t\tgetNode: function(node, rootNode) {\n\t\t\tvar nodes = getNodes(node, rootNode);\n\t\t\treturn nodes && nodes[0];\n\t\t},\n\t\tstringifyStyle: function(style) {\n\t\t\tvar styleStr = \"\";\n\t\t\tfor (var i in style) {\n\t\t\t\tstyleStr += [i, \":\", style[i], \";\"].join(\"\");\n\t\t\t}\n\t\t\treturn styleStr;\n\t\t}\n\t}\n\t\n\t// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n\tvar names = ['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'];\n\tfor (var i = 0; i < names.length; i++) {\n\t\tUtil['is' + names[i]] = function(obj) {\n\t\t\treturn toString.call(obj) == '[object ' + names[i] + ']';\n\t\t};\n\t}\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Util;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Util;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Events = __webpack_require__(22);\n\t/** \n\t      @constructor \n\t      @mixes Events\n\t      */\n\tvar Base = function() {}\n\t\n\tUtil.mix(Base.prototype, Events);\n\t\n\tUtil.mix(Base.prototype, {\n\t\t/**\n\t\t * @memberof Base\n\t\t * @param  {object} plugin plug a plugin\n\t\t */\n\t\tplug: function(plugin) {\n\t\t\tvar self = this;\n\t\t\tif (!plugin || !plugin.pluginId) return;\n\t\t\tif (!self.__plugins) {\n\t\t\t\tself.__plugins = [];\n\t\t\t}\n\t\t\tvar __plugin = self.getPlugin(plugin.pluginId);\n\t\t\t__plugin && self.unplug(plugin.pluginId);\n\t\t\tplugin.pluginInitializer(self);\n\t\t\tself.__plugins.push(plugin);\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * @memberof Base\n\t\t * @param  {object|string} plugin unplug a plugin by pluginId or plugin instance\n\t\t */\n\t\tunplug: function(plugin) {\n\t\t\tvar self = this;\n\t\t\tif (!plugin || !self.__plugins) return;\n\t\t\tvar _plugin = typeof plugin == \"string\" ? self.getPlugin(plugin) : plugin;\n\t\t\t_plugin.pluginDestructor(self);\n\t\t\tfor (var i = 0, l = self.__plugins.length;i < l;i++) {\n\t\t\t\tif (self.__plugins[i] == _plugin) {\n\t\t\t\t\treturn self.__plugins.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @memberof Base\n\t\t * @param  {object|string} plugin get plugin by pluginId\n\t\t */\n\t\tgetPlugin: function(pluginId) {\n\t\t\tvar self = this;\n\t\t\tvar plugins = [];\n\t\t\tif(!self.__plugins) return;\n\t\t\tfor (var i = 0, l = self.__plugins.length;i < l;i++) {\n\t\t\t\tif (self.__plugins[i] && self.__plugins[i].pluginId == pluginId) {\n\t\t\t\t\tplugins.push(self.__plugins[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn plugins.length > 1 ? plugins : plugins[0] || null;\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Base;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Base;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Timer = __webpack_require__(9);\n\tvar Easing = __webpack_require__(8);\n\tvar Base = __webpack_require__(2);\n\t//transform\n\tvar vendorTransform = Util.prefixStyle(\"transform\");\n\t//transition webkitTransition MozTransition OTransition msTtransition\n\tvar vendorTransition = Util.prefixStyle(\"transition\");\n\t\n\tvar vendorTransitionDuration = Util.prefixStyle(\"transitionDuration\");\n\t\n\tvar vendorTransformOrigin = Util.prefixStyle(\"transformOrigin\");\n\t\n\tvar vendorTransitionEnd = Util.vendor ? Util.prefixStyle(\"transitionEnd\") : \"transitionend\";\n\t\n\tvar vendorTransformStr = Util.vendor ? [\"-\", Util.vendor, \"-transform\"].join(\"\") : \"transform\";\n\t\n\tvar translateTpl = 'translateX({translateX}px) translateY({translateY}px) translateZ(0)';\n\t//limit attrs\n\tvar animAttrs = {\n\t\t'transform': true,\n\t\t'opacity': true,\n\t\t'scrollTop': true,\n\t\t'scrollLeft': true\n\t};\n\t\n\tfunction myParse(v) {\n\t\treturn Math.round(parseFloat(v) * 1e5) / 1e5;\n\t}\n\t\n\tfunction defaultDecompose() {\n\t\treturn {\n\t\t\ttranslateX: 0,\n\t\t\ttranslateY: 0,\n\t\t\trotate: 0,\n\t\t\tskewX: 0,\n\t\t\tskewY: 0,\n\t\t\tscaleX: 1,\n\t\t\tscaleY: 1\n\t\t};\n\t}\n\t\n\tfunction toMatrixArray(matrix) {\n\t\tmatrix = matrix.split(/,/);\n\t\tmatrix = Array.prototype.map.call(matrix, function(v) {\n\t\t\treturn myParse(v);\n\t\t});\n\t\treturn matrix;\n\t}\n\t\n\tfunction decomposeMatrix(matrix) {\n\t\tmatrix = toMatrixArray(matrix);\n\t\tvar scaleX, scaleY, skew,\n\t\t\tA = matrix[0],\n\t\t\tB = matrix[1],\n\t\t\tC = matrix[2],\n\t\t\tD = matrix[3];\n\t\n\t\t// Make sure matrix is not singular\n\t\tif (A * D - B * C) {\n\t\t\tscaleX = Math.sqrt(A * A + B * B);\n\t\t\tskew = (A * C + B * D) / (A * D - C * B);\n\t\t\tscaleY = (A * D - B * C) / scaleX;\n\t\t\t// step (6)\n\t\t\tif (A * D < B * C) {\n\t\t\t\tskew = -skew;\n\t\t\t\tscaleX = -scaleX;\n\t\t\t}\n\t\t\t// matrix is singular and cannot be interpolated\n\t\t} else {\n\t\t\t// In this case the elem shouldn't be rendered, hence scale == 0\n\t\t\tscaleX = scaleY = skew = 0;\n\t\t}\n\t\n\t\t// The recomposition order is very important\n\t\t// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971\n\t\treturn {\n\t\t\ttranslateX: myParse(matrix[4]),\n\t\t\ttranslateY: myParse(matrix[5]),\n\t\t\trotate: myParse(Math.atan2(B, A) * 180 / Math.PI),\n\t\t\tskewX: myParse(Math.atan(skew) * 180 / Math.PI),\n\t\t\tskewY: 0,\n\t\t\tscaleX: myParse(scaleX),\n\t\t\tscaleY: myParse(scaleY)\n\t\t};\n\t}\n\t\n\tfunction getTransformInfo(transform) {\n\t\ttransform = transform.split(')');\n\t\tvar trim = Util.trim,\n\t\t\ti = -1,\n\t\t\tl = transform.length - 1,\n\t\t\tsplit, prop, val,\n\t\t\tret = defaultDecompose();\n\t\n\t\t// Loop through the transform properties, parse and multiply them\n\t\twhile (++i < l) {\n\t\t\tsplit = transform[i].split('(');\n\t\t\tprop = trim(split[0]);\n\t\t\tval = split[1];\n\t\t\tswitch (prop) {\n\t\t\t\tcase 'translateX':\n\t\t\t\tcase 'translateY':\n\t\t\t\tcase 'scaleX':\n\t\t\t\tcase 'scaleY':\n\t\t\t\t\tret[prop] = myParse(val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\tcase 'translate3d':\n\t\t\t\t\tval = val.split(',');\n\t\t\t\t\tret.translateX = myParse(val[0]);\n\t\t\t\t\tret.translateY = myParse(val[1] || 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tval = val.split(',');\n\t\t\t\t\tret.scaleX = myParse(val[0]);\n\t\t\t\t\tret.scaleY = myParse(val[1] || val[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'matrix':\n\t\t\t\t\treturn decomposeMatrix(val);\n\t\t\t}\n\t\t}\n\t\n\t\treturn ret;\n\t}\n\t\n\t/**\n\t * animate function\n\t * @constructor\n\t * @param {HTMLElement} el element to animate\n\t * @param {Object} config config for animate\n\t * @param {Object} config.css\n\t * @param {Number} config.duration\n\t * @param {String} config.easing\n\t * @extends {Base}\n\t */\n\tfunction Animate(el, cfg) {\n\t\tif (!el || !cfg || !cfg.css) return;\n\t\tvar self = this;\n\t\tself.cfg = cfg;\n\t\tself.el = el;\n\t\tvar duration = cfg.duration || 0,\n\t\t\teasing = cfg.easing || \"ease\",\n\t\t\tdelay = cfg.delay || 0;\n\t\t//trigger run\n\t\tif (cfg.run) {\n\t\t\t//frame animate\n\t\t\tself.timer = self.timer || new Timer({\n\t\t\t\tduration: Math.round(duration),\n\t\t\t\teasing: easing,\n\t\t\t});\n\t\t\tself.timer.on(\"run\", cfg.run);\n\t\t}\n\t\tself._bindEvt();\n\t\treturn self;\n\t}\n\t\n\tfunction computeTransform(prevTransform, destTransform) {\n\t\tvar transform = getTransformInfo(prevTransform);\n\t\tvar dest = getTransformInfo(destTransform);\n\t\tvar trans = {};\n\t\tfor (var i in dest) {\n\t\t\ttrans[i] = {\n\t\t\t\tprevVal: transform[i],\n\t\t\t\tnewVal: dest[i]\n\t\t\t}\n\t\t}\n\t\treturn trans;\n\t}\n\t\n\t//for scroll only\n\tfunction setStyle(el, styleName, prevVal, newVal, percent) {\n\t\tprevVal = isNaN(Number(prevVal)) ? 0 : Number(prevVal);\n\t\tvar curVal = ((newVal - prevVal) * percent + prevVal);\n\t\tcss(el, styleName, curVal);\n\t}\n\t\n\tfunction css(el, styleName, val) {\n\t\tswitch (styleName) {\n\t\t\tcase \"scrollTop\":\n\t\t\tcase \"scrollLeft\":\n\t\t\t\tel[styleName] = val;\n\t\t\t\tbreak;\n\t\t\tcase \"transform\":\n\t\t\t\tel.style[vendorTransform] = val;\n\t\t\tcase \"opacity\":\n\t\t\t\tel.style[styleName] = val;\n\t\t\t\tbreak;\n\t\n\t\t}\n\t}\n\t\n\tUtil.extend(Animate, Base, {\n\t\t/**\n\t\t * to start the animation\n\t\t * @memberof Animate\n\t\t * @return {Animate}\n\t\t */\n\t\trun: function() {\n\t\t\tvar self = this;\n\t\t\tvar cfg = self.cfg,\n\t\t\t\tel = self.el,\n\t\t\t\tduration = cfg.duration || 0,\n\t\t\t\teasing = cfg.easing || \"ease\",\n\t\t\t\tdelay = cfg.delay || 0;\n\t\t\tself.__isTransitionEnd = false;\n\t\t\tclearTimeout(self.__itv)\n\t\t\tself.timer && self.timer.run();\n\t\t\tif (duration <= Timer.MIN_DURATION) {\n\t\t\t\tfor (var i in cfg.css) {\n\t\t\t\t\tcss(el, i, cfg.css[i]);\n\t\t\t\t}\n\t\t\t\tself.stop()\n\t\t\t\tself.__handlers.stop.call(self);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif(Util.isBadAndroid()){\n\t\t\t\t//use frame animate on bad android device\n\t\t\t\tcfg.useTransition = false;\n\t\t\t}\n\t\n\t\t\tif (cfg.useTransition) {\n\t\t\t\t//transition\n\t\t\t\tel.style[vendorTransition] = Util.substitute('all {duration}ms {easing} {delay}ms', {\n\t\t\t\t\tduration: Math.round(duration),\n\t\t\t\t\teasing: Easing.format(easing),\n\t\t\t\t\tdelay: delay\n\t\t\t\t});\n\t\t\t\tfor (var i in cfg.css) {\n\t\t\t\t\t//set css\n\t\t\t\t\tcss(el, i, cfg.css[i]);\n\t\t\t\t}\n\t\t\t\tself.__itv = setTimeout(function() {\n\t\t\t\t\tif (!self.__isTransitionEnd) {\n\t\t\t\t\t\tself.__isTransitionEnd = true;\n\t\t\t\t\t\tself.trigger(\"transitionend\");\n\t\t\t\t\t}\n\t\t\t\t}, Number(duration) + 60);\n\t\t\t} else {\n\t\t\t\tself.computeStyle = self.computeStyle || window.getComputedStyle(el);\n\t\t\t\t//transform\n\t\t\t\tif (cfg.css.transform && self.timer) {\n\t\t\t\t\tvar transmap = self.transmap = computeTransform(self.computeStyle[vendorTransform], cfg.css.transform);\n\t\t\t\t\tself.timer.off(\"run\", self.__handlers.transRun);\n\t\t\t\t\tself.timer.on(\"run\", self.__handlers.transRun, self);\n\t\t\t\t\tself.timer.off(\"end\",self.__handlers.transRun);\n\t\t\t\t\tself.timer.on(\"end\", self.__handlers.transRun, self);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_transitionEndHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tself.stop();\n\t\t\tself.__handlers.stop.call(self);\n\t\t},\n\t\t__handlers: {\n\t\t\ttransRun: function(e) {\n\t\t\t\tvar self = this;\n\t\t\t\tvar transmap = self.transmap;\n\t\t\t\tvar el = self.el;\n\t\t\t\tvar newTrans = {};\n\t\t\t\tfor (var i in transmap) {\n\t\t\t\t\tnewTrans[i] = (transmap[i].newVal - transmap[i].prevVal) * e.percent + transmap[i].prevVal\n\t\t\t\t}\n\t\t\t\tvar ret = Util.substitute(translateTpl + ' ' +\n\t\t\t\t\t'scale({scaleX},{scaleY})', newTrans);\n\t\t\t\tel.style[vendorTransform] = ret;\n\t\t\t},\n\t\t\tstop: function(e) {\n\t\t\t\tvar self = this;\n\t\t\t\tvar cfg = self.cfg;\n\t\t\t\tcfg.end && cfg.end({\n\t\t\t\t\tpercent: 1\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tvar cfg = self.cfg;\n\t\t\tvar el = self.el;\n\t\t\tself.el.addEventListener(vendorTransitionEnd, function(e) {\n\t\t\t\tself.__isTransitionEnd = true;\n\t\t\t\tif (e.target !== e.currentTarget) return;\n\t\t\t\tself.trigger(\"transitionend\", e);\n\t\t\t})\n\t\t\tself.on(\"transitionend\", self._transitionEndHandler, self);\n\t\t\tvar cssRun = function(e) {\n\t\t\t\tself.computeStyle = self.computeStyle || window.getComputedStyle(el);\n\t\t\t\tfor (var i in cfg.css) {\n\t\t\t\t\tif (!/transform/.test(i)) {\n\t\t\t\t\t\tsetStyle(self.el, i, self.computeStyle[i], cfg.css[i], e.percent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tself.timer && self.timer.on(\"run\", cssRun);\n\t\t\tself.timer && self.timer.on(\"stop\", self.__handlers.stop, self);\n\t\t},\n\t\t/**\n\t\t * to stop the animation\n\t\t * @memberof Animate\n\t\t * @return {Animate}\n\t\t */\n\t\tstop: function() {\n\t\t\tvar self = this;\n\t\t\tif (self.cfg.useTransition && self.cfg.duration > Timer.MIN_DURATION) {\n\t\t\t\tvar computeStyle = window.getComputedStyle(this.el);\n\t\t\t\tfor (var i in self.cfg.css) {\n\t\t\t\t\tif (animAttrs[i]) {\n\t\t\t\t\t\tvar value = /transform/.test(i) ? computeStyle[vendorTransform] : computeStyle[i];\n\t\t\t\t\t\tcss(self.el, i, Util.substitute(translateTpl + ' ' + 'scale({scaleX},{scaleY})', getTransformInfo(value)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tself.el.style[vendorTransition] = \"none\";\n\t\t\t}\n\t\t\tself.timer && self.timer.stop() && self.timer.reset();\n\t\t\tself.computeStyle = null;\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * to reset the animation to a new state\n\t\t * @memberof Animate\n\t\t * @param {object} cfg cfg for new animation\n\t\t * @return {Animate}\n\t\t */\n\t\treset: function(cfg) {\n\t\t\tvar self = this;\n\t\t\tself.computeStyle = null;\n\t\t\tUtil.mix(self.cfg, cfg);\n\t\t\tthis.timer && self.timer.reset({\n\t\t\t\tduration: Math.round(self.cfg.duration),\n\t\t\t\teasing: self.cfg.easing\n\t\t\t});\n\t\t\treturn self;\n\t\t}\n\t});\n\t\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Animate;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Animate;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t/*! Hammer.JS - v2.0.4 - 2014-09-28\n\t * http://hammerjs.github.io/\n\t *\n\t * Copyright (c) 2014 Jorik Tangelder;\n\t * Licensed under the MIT license */\n\t  'use strict';\n\t\n\tvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\n\tvar TEST_ELEMENT = document.createElement('div');\n\t\n\tvar TYPE_FUNCTION = 'function';\n\t\n\tvar round = Math.round;\n\tvar abs = Math.abs;\n\tvar now = Date.now;\n\t\n\t/**\n\t * set a timeout with a given scope\n\t * @param {Function} fn\n\t * @param {Number} timeout\n\t * @param {Object} context\n\t * @returns {number}\n\t */\n\tfunction setTimeoutContext(fn, timeout, context) {\n\t    return setTimeout(bindFn(fn, context), timeout);\n\t}\n\t\n\t/**\n\t * if the argument is an array, we want to execute the fn on each entry\n\t * if it aint an array we don't want to do a thing.\n\t * this is used by all the methods that accept a single and array argument.\n\t * @param {*|Array} arg\n\t * @param {String} fn\n\t * @param {Object} [context]\n\t * @returns {Boolean}\n\t */\n\tfunction invokeArrayArg(arg, fn, context) {\n\t    if (Array.isArray(arg)) {\n\t        each(arg, context[fn], context);\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * walk objects and arrays\n\t * @param {Object} obj\n\t * @param {Function} iterator\n\t * @param {Object} context\n\t */\n\tfunction each(obj, iterator, context) {\n\t    var i;\n\t\n\t    if (!obj) {\n\t        return;\n\t    }\n\t\n\t    if (obj.forEach) {\n\t        obj.forEach(iterator, context);\n\t    } else if (obj.length !== undefined) {\n\t        i = 0;\n\t        while (i < obj.length) {\n\t            iterator.call(context, obj[i], i, obj);\n\t            i++;\n\t        }\n\t    } else {\n\t        for (i in obj) {\n\t            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * extend object.\n\t * means that properties in dest will be overwritten by the ones in src.\n\t * @param {Object} dest\n\t * @param {Object} src\n\t * @param {Boolean} [merge]\n\t * @returns {Object} dest\n\t */\n\tfunction extend(dest, src, merge) {\n\t    var keys = Object.keys(src);\n\t    var i = 0;\n\t    while (i < keys.length) {\n\t        if (!merge || (merge && dest[keys[i]] === undefined)) {\n\t            dest[keys[i]] = src[keys[i]];\n\t        }\n\t        i++;\n\t    }\n\t    return dest;\n\t}\n\t\n\t/**\n\t * merge the values from src in the dest.\n\t * means that properties that exist in dest will not be overwritten by src\n\t * @param {Object} dest\n\t * @param {Object} src\n\t * @returns {Object} dest\n\t */\n\tfunction merge(dest, src) {\n\t    return extend(dest, src, true);\n\t}\n\t\n\t/**\n\t * simple class inheritance\n\t * @param {Function} child\n\t * @param {Function} base\n\t * @param {Object} [properties]\n\t */\n\tfunction inherit(child, base, properties) {\n\t    var baseP = base.prototype,\n\t        childP;\n\t\n\t    childP = child.prototype = Object.create(baseP);\n\t    childP.constructor = child;\n\t    childP._super = baseP;\n\t\n\t    if (properties) {\n\t        extend(childP, properties);\n\t    }\n\t}\n\t\n\t/**\n\t * simple function bind\n\t * @param {Function} fn\n\t * @param {Object} context\n\t * @returns {Function}\n\t */\n\tfunction bindFn(fn, context) {\n\t    return function boundFn() {\n\t        return fn.apply(context, arguments);\n\t    };\n\t}\n\t\n\t/**\n\t * let a boolean value also be a function that must return a boolean\n\t * this first item in args will be used as the context\n\t * @param {Boolean|Function} val\n\t * @param {Array} [args]\n\t * @returns {Boolean}\n\t */\n\tfunction boolOrFn(val, args) {\n\t    if (typeof val == TYPE_FUNCTION) {\n\t        return val.apply(args ? args[0] || undefined : undefined, args);\n\t    }\n\t    return val;\n\t}\n\t\n\t/**\n\t * use the val2 when val1 is undefined\n\t * @param {*} val1\n\t * @param {*} val2\n\t * @returns {*}\n\t */\n\tfunction ifUndefined(val1, val2) {\n\t    return (val1 === undefined) ? val2 : val1;\n\t}\n\t\n\t/**\n\t * addEventListener with multiple events at once\n\t * @param {EventTarget} target\n\t * @param {String} types\n\t * @param {Function} handler\n\t */\n\tfunction addEventListeners(target, types, handler) {\n\t    each(splitStr(types), function(type) {\n\t        target.addEventListener(type, handler, false);\n\t    });\n\t}\n\t\n\t/**\n\t * removeEventListener with multiple events at once\n\t * @param {EventTarget} target\n\t * @param {String} types\n\t * @param {Function} handler\n\t */\n\tfunction removeEventListeners(target, types, handler) {\n\t    each(splitStr(types), function(type) {\n\t        target.removeEventListener(type, handler, false);\n\t    });\n\t}\n\t\n\t/**\n\t * find if a node is in the given parent\n\t * @method hasParent\n\t * @param {HTMLElement} node\n\t * @param {HTMLElement} parent\n\t * @return {Boolean} found\n\t */\n\tfunction hasParent(node, parent) {\n\t    while (node) {\n\t        if (node == parent) {\n\t            return true;\n\t        }\n\t        node = node.parentNode;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * small indexOf wrapper\n\t * @param {String} str\n\t * @param {String} find\n\t * @returns {Boolean} found\n\t */\n\tfunction inStr(str, find) {\n\t    return str.indexOf(find) > -1;\n\t}\n\t\n\t/**\n\t * split string on whitespace\n\t * @param {String} str\n\t * @returns {Array} words\n\t */\n\tfunction splitStr(str) {\n\t    return str.trim().split(/\\s+/g);\n\t}\n\t\n\t/**\n\t * find if a array contains the object using indexOf or a simple polyFill\n\t * @param {Array} src\n\t * @param {String} find\n\t * @param {String} [findByKey]\n\t * @return {Boolean|Number} false when not found, or the index\n\t */\n\tfunction inArray(src, find, findByKey) {\n\t    if (src.indexOf && !findByKey) {\n\t        return src.indexOf(find);\n\t    } else {\n\t        var i = 0;\n\t        while (i < src.length) {\n\t            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n\t                return i;\n\t            }\n\t            i++;\n\t        }\n\t        return -1;\n\t    }\n\t}\n\t\n\t/**\n\t * convert array-like objects to real arrays\n\t * @param {Object} obj\n\t * @returns {Array}\n\t */\n\tfunction toArray(obj) {\n\t    return Array.prototype.slice.call(obj, 0);\n\t}\n\t\n\t/**\n\t * unique array with objects based on a key (like 'id') or just by the array's value\n\t * @param {Array} src [{id:1},{id:2},{id:1}]\n\t * @param {String} [key]\n\t * @param {Boolean} [sort=False]\n\t * @returns {Array} [{id:1},{id:2}]\n\t */\n\tfunction uniqueArray(src, key, sort) {\n\t    var results = [];\n\t    var values = [];\n\t    var i = 0;\n\t\n\t    while (i < src.length) {\n\t        var val = key ? src[i][key] : src[i];\n\t        if (inArray(values, val) < 0) {\n\t            results.push(src[i]);\n\t        }\n\t        values[i] = val;\n\t        i++;\n\t    }\n\t\n\t    if (sort) {\n\t        if (!key) {\n\t            results = results.sort();\n\t        } else {\n\t            results = results.sort(function sortUniqueArray(a, b) {\n\t                return a[key] > b[key];\n\t            });\n\t        }\n\t    }\n\t\n\t    return results;\n\t}\n\t\n\t/**\n\t * get the prefixed property\n\t * @param {Object} obj\n\t * @param {String} property\n\t * @returns {String|Undefined} prefixed\n\t */\n\tfunction prefixed(obj, property) {\n\t    var prefix, prop;\n\t    var camelProp = property[0].toUpperCase() + property.slice(1);\n\t\n\t    var i = 0;\n\t    while (i < VENDOR_PREFIXES.length) {\n\t        prefix = VENDOR_PREFIXES[i];\n\t        prop = (prefix) ? prefix + camelProp : property;\n\t\n\t        if (prop in obj) {\n\t            return prop;\n\t        }\n\t        i++;\n\t    }\n\t    return undefined;\n\t}\n\t\n\t/**\n\t * get a unique id\n\t * @returns {number} uniqueId\n\t */\n\tvar _uniqueId = 1;\n\tfunction uniqueId() {\n\t    return _uniqueId++;\n\t}\n\t\n\t/**\n\t * get the window object of an element\n\t * @param {HTMLElement} element\n\t * @returns {DocumentView|Window}\n\t */\n\tfunction getWindowForElement(element) {\n\t    var doc = element.ownerDocument;\n\t    return (doc.defaultView || doc.parentWindow);\n\t}\n\t\n\tvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\t\n\tvar SUPPORT_TOUCH = ('ontouchstart' in window);\n\tvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n\tvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\t\n\tvar INPUT_TYPE_TOUCH = 'touch';\n\tvar INPUT_TYPE_PEN = 'pen';\n\tvar INPUT_TYPE_MOUSE = 'mouse';\n\tvar INPUT_TYPE_KINECT = 'kinect';\n\t\n\tvar COMPUTE_INTERVAL = 25;\n\t\n\tvar INPUT_START = 1;\n\tvar INPUT_MOVE = 2;\n\tvar INPUT_END = 4;\n\tvar INPUT_CANCEL = 8;\n\t\n\tvar DIRECTION_NONE = 1;\n\tvar DIRECTION_LEFT = 2;\n\tvar DIRECTION_RIGHT = 4;\n\tvar DIRECTION_UP = 8;\n\tvar DIRECTION_DOWN = 16;\n\t\n\tvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n\tvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n\tvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\t\n\tvar PROPS_XY = ['x', 'y'];\n\tvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\t\n\t/**\n\t * create new input type manager\n\t * @param {Manager} manager\n\t * @param {Function} callback\n\t * @returns {Input}\n\t * @constructor\n\t */\n\tfunction Input(manager, callback) {\n\t    var self = this;\n\t    this.manager = manager;\n\t    this.callback = callback;\n\t    this.element = manager.element;\n\t    this.target = manager.options.inputTarget;\n\t\n\t    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n\t    // so when disabled the input events are completely bypassed.\n\t    this.domHandler = function(ev) {\n\t        if (boolOrFn(manager.options.enable, [manager])) {\n\t            self.handler(ev);\n\t        }\n\t    };\n\t\n\t    this.init();\n\t\n\t}\n\t\n\tInput.prototype = {\n\t    /**\n\t     * should handle the inputEvent data and trigger the callback\n\t     * @virtual\n\t     */\n\t    handler: function() { },\n\t\n\t    /**\n\t     * bind the events\n\t     */\n\t    init: function() {\n\t        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n\t        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n\t        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t    },\n\t\n\t    /**\n\t     * unbind the events\n\t     */\n\t    destroy: function() {\n\t        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n\t        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n\t        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t    }\n\t};\n\t\n\t/**\n\t * create new input type manager\n\t * called by the Manager constructor\n\t * @param {Hammer} manager\n\t * @returns {Input}\n\t */\n\tfunction createInputInstance(manager) {\n\t    var Type;\n\t    var inputClass = manager.options.inputClass;\n\t\n\t    if (inputClass) {\n\t        Type = inputClass;\n\t    } else if (SUPPORT_POINTER_EVENTS) {\n\t        Type = PointerEventInput;\n\t    } else if (SUPPORT_ONLY_TOUCH) {\n\t        Type = TouchInput;\n\t    } else if (!SUPPORT_TOUCH) {\n\t        Type = MouseInput;\n\t    } else {\n\t        Type = TouchMouseInput;\n\t    }\n\t    return new (Type)(manager, inputHandler);\n\t}\n\t\n\t/**\n\t * handle input events\n\t * @param {Manager} manager\n\t * @param {String} eventType\n\t * @param {Object} input\n\t */\n\tfunction inputHandler(manager, eventType, input) {\n\t    var pointersLen = input.pointers.length;\n\t    var changedPointersLen = input.changedPointers.length;\n\t    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n\t    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\t\n\t    input.isFirst = !!isFirst;\n\t    input.isFinal = !!isFinal;\n\t    if (isFirst) {\n\t        manager.session = {};\n\t    }\n\t\n\t    // source event is the normalized value of the domEvents\n\t    // like 'touchstart, mouseup, pointerdown'\n\t    input.eventType = eventType;\n\t\n\t    // compute scale, rotation etc\n\t    computeInputData(manager, input);\n\t\n\t    // emit secret event\n\t    manager.emit('hammer.input', input);\n\t\n\t    manager.recognize(input);\n\t    manager.session.prevInput = input;\n\t}\n\t\n\t/**\n\t * extend the data with some usable properties like scale, rotate, velocity etc\n\t * @param {Object} manager\n\t * @param {Object} input\n\t */\n\tfunction computeInputData(manager, input) {\n\t    var session = manager.session;\n\t    var pointers = input.pointers;\n\t    var pointersLength = pointers.length;\n\t\n\t    // store the first input to calculate the distance and direction\n\t    if (!session.firstInput) {\n\t        session.firstInput = simpleCloneInputData(input);\n\t    }\n\t\n\t    // to compute scale and rotation we need to store the multiple touches\n\t    if (pointersLength > 1 && !session.firstMultiple) {\n\t        session.firstMultiple = simpleCloneInputData(input);\n\t    } else if (pointersLength === 1) {\n\t        session.firstMultiple = false;\n\t    }\n\t\n\t    var firstInput = session.firstInput;\n\t    var firstMultiple = session.firstMultiple;\n\t    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\t\n\t    var center = input.center = getCenter(pointers);\n\t    input.timeStamp = now();\n\t    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\t\n\t    input.angle = getAngle(offsetCenter, center);\n\t    input.distance = getDistance(offsetCenter, center);\n\t\n\t    computeDeltaXY(session, input);\n\t    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\t\n\t    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n\t    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\t\n\t    computeIntervalInputData(session, input);\n\t\n\t    // find the correct target\n\t    var target = manager.element;\n\t    if (hasParent(input.srcEvent.target, target)) {\n\t        target = input.srcEvent.target;\n\t    }\n\t    input.target = target;\n\t}\n\t\n\tfunction computeDeltaXY(session, input) {\n\t    var center = input.center;\n\t    var offset = session.offsetDelta || {};\n\t    var prevDelta = session.prevDelta || {};\n\t    var prevInput = session.prevInput || {};\n\t\n\t    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n\t        prevDelta = session.prevDelta = {\n\t            x: prevInput.deltaX || 0,\n\t            y: prevInput.deltaY || 0\n\t        };\n\t\n\t        offset = session.offsetDelta = {\n\t            x: center.x,\n\t            y: center.y\n\t        };\n\t    }\n\t\n\t    input.deltaX = prevDelta.x + (center.x - offset.x);\n\t    input.deltaY = prevDelta.y + (center.y - offset.y);\n\t}\n\t\n\t/**\n\t * velocity is calculated every x ms\n\t * @param {Object} session\n\t * @param {Object} input\n\t */\n\tfunction computeIntervalInputData(session, input) {\n\t    var last = session.lastInterval || input,\n\t        deltaTime = input.timeStamp - last.timeStamp,\n\t        velocity, velocityX, velocityY, direction;\n\t\n\t    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n\t        var deltaX = last.deltaX - input.deltaX;\n\t        var deltaY = last.deltaY - input.deltaY;\n\t        var v = getVelocity(deltaTime, deltaX, deltaY);\n\t        velocityX = v.x;\n\t        velocityY = v.y;\n\t        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n\t        direction = getDirection(deltaX, deltaY);\n\t\n\t        session.lastInterval = input;\n\t    } else {\n\t        // use latest velocity info if it doesn't overtake a minimum period\n\t        velocity = last.velocity;\n\t        velocityX = last.velocityX;\n\t        velocityY = last.velocityY;\n\t        direction = last.direction;\n\t    }\n\t\n\t    input.velocity = velocity;\n\t    input.velocityX = velocityX;\n\t    input.velocityY = velocityY;\n\t    input.direction = direction;\n\t}\n\t\n\t/**\n\t * create a simple clone from the input used for storage of firstInput and firstMultiple\n\t * @param {Object} input\n\t * @returns {Object} clonedInputData\n\t */\n\tfunction simpleCloneInputData(input) {\n\t    // make a simple copy of the pointers because we will get a reference if we don't\n\t    // we only need clientXY for the calculations\n\t    var pointers = [];\n\t    var i = 0;\n\t    while (i < input.pointers.length) {\n\t        pointers[i] = {\n\t            clientX: round(input.pointers[i].clientX),\n\t            clientY: round(input.pointers[i].clientY)\n\t        };\n\t        i++;\n\t    }\n\t\n\t    return {\n\t        timeStamp: now(),\n\t        pointers: pointers,\n\t        center: getCenter(pointers),\n\t        deltaX: input.deltaX,\n\t        deltaY: input.deltaY\n\t    };\n\t}\n\t\n\t/**\n\t * get the center of all the pointers\n\t * @param {Array} pointers\n\t * @return {Object} center contains `x` and `y` properties\n\t */\n\tfunction getCenter(pointers) {\n\t    var pointersLength = pointers.length;\n\t\n\t    // no need to loop when only one touch\n\t    if (pointersLength === 1) {\n\t        return {\n\t            x: round(pointers[0].clientX),\n\t            y: round(pointers[0].clientY)\n\t        };\n\t    }\n\t\n\t    var x = 0, y = 0, i = 0;\n\t    while (i < pointersLength) {\n\t        x += pointers[i].clientX;\n\t        y += pointers[i].clientY;\n\t        i++;\n\t    }\n\t\n\t    return {\n\t        x: round(x / pointersLength),\n\t        y: round(y / pointersLength)\n\t    };\n\t}\n\t\n\t/**\n\t * calculate the velocity between two points. unit is in px per ms.\n\t * @param {Number} deltaTime\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Object} velocity `x` and `y`\n\t */\n\tfunction getVelocity(deltaTime, x, y) {\n\t    return {\n\t        x: x / deltaTime || 0,\n\t        y: y / deltaTime || 0\n\t    };\n\t}\n\t\n\t/**\n\t * get the direction between two points\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Number} direction\n\t */\n\tfunction getDirection(x, y) {\n\t    if (x === y) {\n\t        return DIRECTION_NONE;\n\t    }\n\t    \n\t    if (abs(x) >= abs(y)) {\n\t        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t    }\n\t    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t}\n\t\n\t/**\n\t * calculate the absolute distance between two points\n\t * @param {Object} p1 {x, y}\n\t * @param {Object} p2 {x, y}\n\t * @param {Array} [props] containing x and y keys\n\t * @return {Number} distance\n\t */\n\tfunction getDistance(p1, p2, props) {\n\t    if (!props) {\n\t        props = PROPS_XY;\n\t    }\n\t    var x = p2[props[0]] - p1[props[0]],\n\t        y = p2[props[1]] - p1[props[1]];\n\t\n\t    return Math.sqrt((x * x) + (y * y));\n\t}\n\t\n\t/**\n\t * calculate the angle between two coordinates\n\t * @param {Object} p1\n\t * @param {Object} p2\n\t * @param {Array} [props] containing x and y keys\n\t * @return {Number} angle\n\t */\n\tfunction getAngle(p1, p2, props) {\n\t    if (!props) {\n\t        props = PROPS_XY;\n\t    }\n\t    var x = p2[props[0]] - p1[props[0]],\n\t        y = p2[props[1]] - p1[props[1]];\n\t    return Math.atan2(y, x) * 180 / Math.PI;\n\t}\n\t\n\t/**\n\t * calculate the rotation degrees between two pointersets\n\t * @param {Array} start array of pointers\n\t * @param {Array} end array of pointers\n\t * @return {Number} rotation\n\t */\n\tfunction getRotation(start, end) {\n\t    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n\t}\n\t\n\t/**\n\t * calculate the scale factor between two pointersets\n\t * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n\t * @param {Array} start array of pointers\n\t * @param {Array} end array of pointers\n\t * @return {Number} scale\n\t */\n\tfunction getScale(start, end) {\n\t    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n\t}\n\t\n\tvar MOUSE_INPUT_MAP = {\n\t    mousedown: INPUT_START,\n\t    mousemove: INPUT_MOVE,\n\t    mouseup: INPUT_END\n\t};\n\t\n\tvar MOUSE_ELEMENT_EVENTS = 'mousedown';\n\tvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\t\n\t/**\n\t * Mouse events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction MouseInput() {\n\t    this.evEl = MOUSE_ELEMENT_EVENTS;\n\t    this.evWin = MOUSE_WINDOW_EVENTS;\n\t\n\t    this.allow = true; // used by Input.TouchMouse to disable mouse events\n\t    this.pressed = false; // mousedown state\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(MouseInput, Input, {\n\t    /**\n\t     * handle mouse events\n\t     * @param {Object} ev\n\t     */\n\t    handler: function MEhandler(ev) {\n\t        var eventType = MOUSE_INPUT_MAP[ev.type];\n\t\n\t        // on start we want to have the left mouse button down\n\t        if (eventType & INPUT_START && ev.button === 0) {\n\t            this.pressed = true;\n\t        }\n\t\n\t        if (eventType & INPUT_MOVE && ev.which !== 1) {\n\t            eventType = INPUT_END;\n\t        }\n\t\n\t        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n\t        if (!this.pressed || !this.allow) {\n\t            return;\n\t        }\n\t\n\t        if (eventType & INPUT_END) {\n\t            this.pressed = false;\n\t        }\n\t\n\t        this.callback(this.manager, eventType, {\n\t            pointers: [ev],\n\t            changedPointers: [ev],\n\t            pointerType: INPUT_TYPE_MOUSE,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\tvar POINTER_INPUT_MAP = {\n\t    pointerdown: INPUT_START,\n\t    pointermove: INPUT_MOVE,\n\t    pointerup: INPUT_END,\n\t    pointercancel: INPUT_CANCEL,\n\t    pointerout: INPUT_CANCEL\n\t};\n\t\n\t// in IE10 the pointer types is defined as an enum\n\tvar IE10_POINTER_TYPE_ENUM = {\n\t    2: INPUT_TYPE_TOUCH,\n\t    3: INPUT_TYPE_PEN,\n\t    4: INPUT_TYPE_MOUSE,\n\t    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\t};\n\t\n\tvar POINTER_ELEMENT_EVENTS = 'pointerdown';\n\tvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\t\n\t// IE10 has prefixed support, and case-sensitive\n\tif (window.MSPointerEvent) {\n\t    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n\t    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n\t}\n\t\n\t/**\n\t * Pointer events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction PointerEventInput() {\n\t    this.evEl = POINTER_ELEMENT_EVENTS;\n\t    this.evWin = POINTER_WINDOW_EVENTS;\n\t\n\t    Input.apply(this, arguments);\n\t\n\t    this.store = (this.manager.session.pointerEvents = []);\n\t}\n\t\n\tinherit(PointerEventInput, Input, {\n\t    /**\n\t     * handle mouse events\n\t     * @param {Object} ev\n\t     */\n\t    handler: function PEhandler(ev) {\n\t        var store = this.store;\n\t        var removePointer = false;\n\t\n\t        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n\t        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n\t        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\t\n\t        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\t\n\t        // get index of the event in the store\n\t        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\t\n\t        // start and mouse must be down\n\t        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n\t            if (storeIndex < 0) {\n\t                store.push(ev);\n\t                storeIndex = store.length - 1;\n\t            }\n\t        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t            removePointer = true;\n\t        }\n\t\n\t        // it not found, so the pointer hasn't been down (so it's probably a hover)\n\t        if (storeIndex < 0) {\n\t            return;\n\t        }\n\t\n\t        // update the event in the store\n\t        store[storeIndex] = ev;\n\t\n\t        this.callback(this.manager, eventType, {\n\t            pointers: store,\n\t            changedPointers: [ev],\n\t            pointerType: pointerType,\n\t            srcEvent: ev\n\t        });\n\t\n\t        if (removePointer) {\n\t            // remove from the store\n\t            store.splice(storeIndex, 1);\n\t        }\n\t    }\n\t});\n\t\n\tvar SINGLE_TOUCH_INPUT_MAP = {\n\t    touchstart: INPUT_START,\n\t    touchmove: INPUT_MOVE,\n\t    touchend: INPUT_END,\n\t    touchcancel: INPUT_CANCEL\n\t};\n\t\n\tvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n\tvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t/**\n\t * Touch events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction SingleTouchInput() {\n\t    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n\t    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\t    this.started = false;\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(SingleTouchInput, Input, {\n\t    handler: function TEhandler(ev) {\n\t        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\t\n\t        // should we handle the touch events?\n\t        if (type === INPUT_START) {\n\t            this.started = true;\n\t        }\n\t\n\t        if (!this.started) {\n\t            return;\n\t        }\n\t\n\t        var touches = normalizeSingleTouches.call(this, ev, type);\n\t\n\t        // when done, reset the started state\n\t        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n\t            this.started = false;\n\t        }\n\t\n\t        this.callback(this.manager, type, {\n\t            pointers: touches[0],\n\t            changedPointers: touches[1],\n\t            pointerType: INPUT_TYPE_TOUCH,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\t/**\n\t * @this {TouchInput}\n\t * @param {Object} ev\n\t * @param {Number} type flag\n\t * @returns {undefined|Array} [all, changed]\n\t */\n\tfunction normalizeSingleTouches(ev, type) {\n\t    var all = toArray(ev.touches);\n\t    var changed = toArray(ev.changedTouches);\n\t\n\t    if (type & (INPUT_END | INPUT_CANCEL)) {\n\t        all = uniqueArray(all.concat(changed), 'identifier', true);\n\t    }\n\t\n\t    return [all, changed];\n\t}\n\t\n\tvar TOUCH_INPUT_MAP = {\n\t    touchstart: INPUT_START,\n\t    touchmove: INPUT_MOVE,\n\t    touchend: INPUT_END,\n\t    touchcancel: INPUT_CANCEL\n\t};\n\t\n\tvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t/**\n\t * Multi-user touch events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction TouchInput() {\n\t    this.evTarget = TOUCH_TARGET_EVENTS;\n\t    this.targetIds = {};\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(TouchInput, Input, {\n\t    handler: function MTEhandler(ev) {\n\t        var type = TOUCH_INPUT_MAP[ev.type];\n\t        var touches = getTouches.call(this, ev, type);\n\t        if (!touches) {\n\t            return;\n\t        }\n\t\n\t        this.callback(this.manager, type, {\n\t            pointers: touches[0],\n\t            changedPointers: touches[1],\n\t            pointerType: INPUT_TYPE_TOUCH,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\t/**\n\t * @this {TouchInput}\n\t * @param {Object} ev\n\t * @param {Number} type flag\n\t * @returns {undefined|Array} [all, changed]\n\t */\n\tfunction getTouches(ev, type) {\n\t    var allTouches = toArray(ev.touches);\n\t    var targetIds = this.targetIds;\n\t\n\t    // when there is only one touch, the process can be simplified\n\t    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n\t        targetIds[allTouches[0].identifier] = true;\n\t        return [allTouches, allTouches];\n\t    }\n\t\n\t    var i,\n\t        targetTouches,\n\t        changedTouches = toArray(ev.changedTouches),\n\t        changedTargetTouches = [],\n\t        target = this.target;\n\t\n\t    // get target touches from touches\n\t    targetTouches = allTouches.filter(function(touch) {\n\t        return hasParent(touch.target, target);\n\t    });\n\t\n\t    // collect touches\n\t    if (type === INPUT_START) {\n\t        i = 0;\n\t        while (i < targetTouches.length) {\n\t            targetIds[targetTouches[i].identifier] = true;\n\t            i++;\n\t        }\n\t    }\n\t\n\t    // filter changed touches to only contain touches that exist in the collected target ids\n\t    i = 0;\n\t    while (i < changedTouches.length) {\n\t        if (targetIds[changedTouches[i].identifier]) {\n\t            changedTargetTouches.push(changedTouches[i]);\n\t        }\n\t\n\t        // cleanup removed touches\n\t        if (type & (INPUT_END | INPUT_CANCEL)) {\n\t            delete targetIds[changedTouches[i].identifier];\n\t        }\n\t        i++;\n\t    }\n\t\n\t    if (!changedTargetTouches.length) {\n\t        return;\n\t    }\n\t\n\t    return [\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n\t        changedTargetTouches\n\t    ];\n\t}\n\t\n\t/**\n\t * Combined touch and mouse input\n\t *\n\t * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n\t * This because touch devices also emit mouse events while doing a touch.\n\t *\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction TouchMouseInput() {\n\t    Input.apply(this, arguments);\n\t\n\t    var handler = bindFn(this.handler, this);\n\t    this.touch = new TouchInput(this.manager, handler);\n\t    this.mouse = new MouseInput(this.manager, handler);\n\t}\n\t\n\tinherit(TouchMouseInput, Input, {\n\t    /**\n\t     * handle mouse and touch events\n\t     * @param {Hammer} manager\n\t     * @param {String} inputEvent\n\t     * @param {Object} inputData\n\t     */\n\t    handler: function TMEhandler(manager, inputEvent, inputData) {\n\t        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n\t            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\t\n\t        // when we're in a touch event, so  block all upcoming mouse events\n\t        // most mobile browser also emit mouseevents, right after touchstart\n\t        if (isTouch) {\n\t            this.mouse.allow = false;\n\t        } else if (isMouse && !this.mouse.allow) {\n\t            return;\n\t        }\n\t\n\t        // reset the allowMouse when we're done\n\t        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n\t            this.mouse.allow = true;\n\t        }\n\t\n\t        this.callback(manager, inputEvent, inputData);\n\t    },\n\t\n\t    /**\n\t     * remove the event listeners\n\t     */\n\t    destroy: function destroy() {\n\t        this.touch.destroy();\n\t        this.mouse.destroy();\n\t    }\n\t});\n\t\n\tvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n\tvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\t\n\t// magical touchAction value\n\tvar TOUCH_ACTION_COMPUTE = 'compute';\n\tvar TOUCH_ACTION_AUTO = 'auto';\n\tvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\tvar TOUCH_ACTION_NONE = 'none';\n\tvar TOUCH_ACTION_PAN_X = 'pan-x';\n\tvar TOUCH_ACTION_PAN_Y = 'pan-y';\n\t\n\t/**\n\t * Touch Action\n\t * sets the touchAction property or uses the js alternative\n\t * @param {Manager} manager\n\t * @param {String} value\n\t * @constructor\n\t */\n\tfunction TouchAction(manager, value) {\n\t    this.manager = manager;\n\t    this.set(value);\n\t}\n\t\n\tTouchAction.prototype = {\n\t    /**\n\t     * set the touchAction value on the element or enable the polyfill\n\t     * @param {String} value\n\t     */\n\t    set: function(value) {\n\t        // find out the touch-action by the event handlers\n\t        if (value == TOUCH_ACTION_COMPUTE) {\n\t            value = this.compute();\n\t        }\n\t\n\t        if (NATIVE_TOUCH_ACTION) {\n\t            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n\t        }\n\t        this.actions = value.toLowerCase().trim();\n\t    },\n\t\n\t    /**\n\t     * just re-set the touchAction value\n\t     */\n\t    update: function() {\n\t        this.set(this.manager.options.touchAction);\n\t    },\n\t\n\t    /**\n\t     * compute the value for the touchAction property based on the recognizer's settings\n\t     * @returns {String} value\n\t     */\n\t    compute: function() {\n\t        var actions = [];\n\t        each(this.manager.recognizers, function(recognizer) {\n\t            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n\t                actions = actions.concat(recognizer.getTouchAction());\n\t            }\n\t        });\n\t        return cleanTouchActions(actions.join(' '));\n\t    },\n\t\n\t    /**\n\t     * this method is called on each input cycle and provides the preventing of the browser behavior\n\t     * @param {Object} input\n\t     */\n\t    preventDefaults: function(input) {\n\t        // not needed with native support for the touchAction property\n\t        if (NATIVE_TOUCH_ACTION) {\n\t            return;\n\t        }\n\t\n\t        var srcEvent = input.srcEvent;\n\t        var direction = input.offsetDirection;\n\t\n\t        // if the touch action did prevented once this session\n\t        if (this.manager.session.prevented) {\n\t            srcEvent.preventDefault();\n\t            return;\n\t        }\n\t\n\t        var actions = this.actions;\n\t        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t\n\t        if (hasNone ||\n\t            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n\t            (hasPanX && direction & DIRECTION_VERTICAL)) {\n\t            return this.preventSrc(srcEvent);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n\t     * @param {Object} srcEvent\n\t     */\n\t    preventSrc: function(srcEvent) {\n\t        this.manager.session.prevented = true;\n\t        srcEvent.preventDefault();\n\t    }\n\t};\n\t\n\t/**\n\t * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n\t * @param {String} actions\n\t * @returns {*}\n\t */\n\tfunction cleanTouchActions(actions) {\n\t    // none\n\t    if (inStr(actions, TOUCH_ACTION_NONE)) {\n\t        return TOUCH_ACTION_NONE;\n\t    }\n\t\n\t    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t\n\t    // pan-x and pan-y can be combined\n\t    if (hasPanX && hasPanY) {\n\t        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n\t    }\n\t\n\t    // pan-x OR pan-y\n\t    if (hasPanX || hasPanY) {\n\t        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n\t    }\n\t\n\t    // manipulation\n\t    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n\t        return TOUCH_ACTION_MANIPULATION;\n\t    }\n\t\n\t    return TOUCH_ACTION_AUTO;\n\t}\n\t\n\t/**\n\t * Recognizer flow explained; *\n\t * All recognizers have the initial state of POSSIBLE when a input session starts.\n\t * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n\t * Example session for mouse-input: mousedown -> mousemove -> mouseup\n\t *\n\t * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n\t * which determines with state it should be.\n\t *\n\t * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n\t * POSSIBLE to give it another change on the next cycle.\n\t *\n\t *               Possible\n\t *                  |\n\t *            +-----+---------------+\n\t *            |                     |\n\t *      +-----+-----+               |\n\t *      |           |               |\n\t *   Failed      Cancelled          |\n\t *                          +-------+------+\n\t *                          |              |\n\t *                      Recognized       Began\n\t *                                         |\n\t *                                      Changed\n\t *                                         |\n\t *                                  Ended/Recognized\n\t */\n\tvar STATE_POSSIBLE = 1;\n\tvar STATE_BEGAN = 2;\n\tvar STATE_CHANGED = 4;\n\tvar STATE_ENDED = 8;\n\tvar STATE_RECOGNIZED = STATE_ENDED;\n\tvar STATE_CANCELLED = 16;\n\tvar STATE_FAILED = 32;\n\t\n\t/**\n\t * Recognizer\n\t * Every recognizer needs to extend from this class.\n\t * @constructor\n\t * @param {Object} options\n\t */\n\tfunction Recognizer(options) {\n\t    this.id = uniqueId();\n\t\n\t    this.manager = null;\n\t    this.options = merge(options || {}, this.defaults);\n\t\n\t    // default is enable true\n\t    this.options.enable = ifUndefined(this.options.enable, true);\n\t\n\t    this.state = STATE_POSSIBLE;\n\t\n\t    this.simultaneous = {};\n\t    this.requireFail = [];\n\t}\n\t\n\tRecognizer.prototype = {\n\t    /**\n\t     * @virtual\n\t     * @type {Object}\n\t     */\n\t    defaults: {},\n\t\n\t    /**\n\t     * set options\n\t     * @param {Object} options\n\t     * @return {Recognizer}\n\t     */\n\t    set: function(options) {\n\t        extend(this.options, options);\n\t\n\t        // also update the touchAction, in case something changed about the directions/enabled state\n\t        this.manager && this.manager.touchAction.update();\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * recognize simultaneous with an other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    recognizeWith: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n\t            return this;\n\t        }\n\t\n\t        var simultaneous = this.simultaneous;\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        if (!simultaneous[otherRecognizer.id]) {\n\t            simultaneous[otherRecognizer.id] = otherRecognizer;\n\t            otherRecognizer.recognizeWith(this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    dropRecognizeWith: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n\t            return this;\n\t        }\n\t\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        delete this.simultaneous[otherRecognizer.id];\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * recognizer can only run when an other is failing\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    requireFailure: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n\t            return this;\n\t        }\n\t\n\t        var requireFail = this.requireFail;\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        if (inArray(requireFail, otherRecognizer) === -1) {\n\t            requireFail.push(otherRecognizer);\n\t            otherRecognizer.requireFailure(this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * drop the requireFailure link. it does not remove the link on the other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    dropRequireFailure: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n\t            return this;\n\t        }\n\t\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        var index = inArray(this.requireFail, otherRecognizer);\n\t        if (index > -1) {\n\t            this.requireFail.splice(index, 1);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * has require failures boolean\n\t     * @returns {boolean}\n\t     */\n\t    hasRequireFailures: function() {\n\t        return this.requireFail.length > 0;\n\t    },\n\t\n\t    /**\n\t     * if the recognizer can recognize simultaneous with an other recognizer\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Boolean}\n\t     */\n\t    canRecognizeWith: function(otherRecognizer) {\n\t        return !!this.simultaneous[otherRecognizer.id];\n\t    },\n\t\n\t    /**\n\t     * You should use `tryEmit` instead of `emit` directly to check\n\t     * that all the needed recognizers has failed before emitting.\n\t     * @param {Object} input\n\t     */\n\t    emit: function(input) {\n\t        var self = this;\n\t        var state = this.state;\n\t\n\t        function emit(withState) {\n\t            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n\t        }\n\t\n\t        // 'panstart' and 'panmove'\n\t        if (state < STATE_ENDED) {\n\t            emit(true);\n\t        }\n\t\n\t        emit(); // simple 'eventName' events\n\t\n\t        // panend and pancancel\n\t        if (state >= STATE_ENDED) {\n\t            emit(true);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Check that all the require failure recognizers has failed,\n\t     * if true, it emits a gesture event,\n\t     * otherwise, setup the state to FAILED.\n\t     * @param {Object} input\n\t     */\n\t    tryEmit: function(input) {\n\t        if (this.canEmit()) {\n\t            return this.emit(input);\n\t        }\n\t        // it's failing anyway\n\t        this.state = STATE_FAILED;\n\t    },\n\t\n\t    /**\n\t     * can we emit?\n\t     * @returns {boolean}\n\t     */\n\t    canEmit: function() {\n\t        var i = 0;\n\t        while (i < this.requireFail.length) {\n\t            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n\t                return false;\n\t            }\n\t            i++;\n\t        }\n\t        return true;\n\t    },\n\t\n\t    /**\n\t     * update the recognizer\n\t     * @param {Object} inputData\n\t     */\n\t    recognize: function(inputData) {\n\t        // make a new copy of the inputData\n\t        // so we can change the inputData without messing up the other recognizers\n\t        var inputDataClone = extend({}, inputData);\n\t\n\t        // is is enabled and allow recognizing?\n\t        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n\t            this.reset();\n\t            this.state = STATE_FAILED;\n\t            return;\n\t        }\n\t\n\t        // reset when we've reached the end\n\t        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n\t            this.state = STATE_POSSIBLE;\n\t        }\n\t\n\t        this.state = this.process(inputDataClone);\n\t\n\t        // the recognizer has recognized a gesture\n\t        // so trigger an event\n\t        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n\t            this.tryEmit(inputDataClone);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * return the state of the recognizer\n\t     * the actual recognizing happens in this method\n\t     * @virtual\n\t     * @param {Object} inputData\n\t     * @returns {Const} STATE\n\t     */\n\t    process: function(inputData) { }, // jshint ignore:line\n\t\n\t    /**\n\t     * return the preferred touch-action\n\t     * @virtual\n\t     * @returns {Array}\n\t     */\n\t    getTouchAction: function() { },\n\t\n\t    /**\n\t     * called when the gesture isn't allowed to recognize\n\t     * like when another is being recognized or it is disabled\n\t     * @virtual\n\t     */\n\t    reset: function() { }\n\t};\n\t\n\t/**\n\t * get a usable string, used as event postfix\n\t * @param {Const} state\n\t * @returns {String} state\n\t */\n\tfunction stateStr(state) {\n\t    if (state & STATE_CANCELLED) {\n\t        return 'cancel';\n\t    } else if (state & STATE_ENDED) {\n\t        return 'end';\n\t    } else if (state & STATE_CHANGED) {\n\t        return 'move';\n\t    } else if (state & STATE_BEGAN) {\n\t        return 'start';\n\t    }\n\t    return '';\n\t}\n\t\n\t/**\n\t * direction cons to string\n\t * @param {Const} direction\n\t * @returns {String}\n\t */\n\tfunction directionStr(direction) {\n\t    if (direction == DIRECTION_DOWN) {\n\t        return 'down';\n\t    } else if (direction == DIRECTION_UP) {\n\t        return 'up';\n\t    } else if (direction == DIRECTION_LEFT) {\n\t        return 'left';\n\t    } else if (direction == DIRECTION_RIGHT) {\n\t        return 'right';\n\t    }\n\t    return '';\n\t}\n\t\n\t/**\n\t * get a recognizer by name if it is bound to a manager\n\t * @param {Recognizer|String} otherRecognizer\n\t * @param {Recognizer} recognizer\n\t * @returns {Recognizer}\n\t */\n\tfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n\t    var manager = recognizer.manager;\n\t    if (manager) {\n\t        return manager.get(otherRecognizer);\n\t    }\n\t    return otherRecognizer;\n\t}\n\t\n\t/**\n\t * This recognizer is just used as a base for the simple attribute recognizers.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction AttrRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(AttrRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof AttrRecognizer\n\t     */\n\t    defaults: {\n\t        /**\n\t         * @type {Number}\n\t         * @default 1\n\t         */\n\t        pointers: 1\n\t    },\n\t\n\t    /**\n\t     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n\t     * @memberof AttrRecognizer\n\t     * @param {Object} input\n\t     * @returns {Boolean} recognized\n\t     */\n\t    attrTest: function(input) {\n\t        var optionPointers = this.options.pointers;\n\t        return optionPointers === 0 || input.pointers.length === optionPointers;\n\t    },\n\t\n\t    /**\n\t     * Process the input and return the state for the recognizer\n\t     * @memberof AttrRecognizer\n\t     * @param {Object} input\n\t     * @returns {*} State\n\t     */\n\t    process: function(input) {\n\t        var state = this.state;\n\t        var eventType = input.eventType;\n\t\n\t        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n\t        var isValid = this.attrTest(input);\n\t\n\t        // on cancel input and we've recognized before, return STATE_CANCELLED\n\t        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n\t            return state | STATE_CANCELLED;\n\t        } else if (isRecognized || isValid) {\n\t            if (eventType & INPUT_END) {\n\t                return state | STATE_ENDED;\n\t            } else if (!(state & STATE_BEGAN)) {\n\t                return STATE_BEGAN;\n\t            }\n\t            return state | STATE_CHANGED;\n\t        }\n\t        return STATE_FAILED;\n\t    }\n\t});\n\t\n\t/**\n\t * Pan\n\t * Recognized when the pointer is down and moved in the allowed direction.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction PanRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t\n\t    this.pX = null;\n\t    this.pY = null;\n\t}\n\t\n\tinherit(PanRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PanRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'pan',\n\t        threshold: 10,\n\t        pointers: 1,\n\t        direction: DIRECTION_ALL\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        var direction = this.options.direction;\n\t        var actions = [];\n\t        if (direction & DIRECTION_HORIZONTAL) {\n\t            actions.push(TOUCH_ACTION_PAN_Y);\n\t        }\n\t        if (direction & DIRECTION_VERTICAL) {\n\t            actions.push(TOUCH_ACTION_PAN_X);\n\t        }\n\t        return actions;\n\t    },\n\t\n\t    directionTest: function(input) {\n\t        var options = this.options;\n\t        var hasMoved = true;\n\t        var distance = input.distance;\n\t        var direction = input.direction;\n\t        var x = input.deltaX;\n\t        var y = input.deltaY;\n\t\n\t        // lock to axis?\n\t        if (!(direction & options.direction)) {\n\t            if (options.direction & DIRECTION_HORIZONTAL) {\n\t                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t                hasMoved = x != this.pX;\n\t                distance = Math.abs(input.deltaX);\n\t            } else {\n\t                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n\t                hasMoved = y != this.pY;\n\t                distance = Math.abs(input.deltaY);\n\t            }\n\t        }\n\t        input.direction = direction;\n\t        return hasMoved && distance > options.threshold && direction & options.direction;\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n\t            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n\t    },\n\t\n\t    emit: function(input) {\n\t        this.pX = input.deltaX;\n\t        this.pY = input.deltaY;\n\t\n\t        var direction = directionStr(input.direction);\n\t        if (direction) {\n\t            this.manager.emit(this.options.event + direction, input);\n\t        }\n\t\n\t        this._super.emit.call(this, input);\n\t    },\n\t    reset:function(){\n\t        \n\t    }\n\t});\n\t\n\t/**\n\t * Pinch\n\t * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction PinchRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(PinchRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PinchRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'pinch',\n\t        threshold: 0,\n\t        pointers: 2\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_NONE];\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return this._super.attrTest.call(this, input) &&\n\t            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n\t    },\n\t\n\t    emit: function(input) {\n\t        this._super.emit.call(this, input);\n\t        if (input.scale !== 1) {\n\t            var inOut = input.scale < 1 ? 'in' : 'out';\n\t            this.manager.emit(this.options.event + inOut, input);\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Press\n\t * Recognized when the pointer is down for x ms without any movement.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction PressRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t\n\t    this._timer = null;\n\t    this._input = null;\n\t}\n\t\n\tinherit(PressRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PressRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'press',\n\t        pointers: 1,\n\t        time: 500, // minimal time of the pointer to be pressed\n\t        threshold: 5 // a minimal movement is ok, but keep it low\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_AUTO];\n\t    },\n\t\n\t    process: function(input) {\n\t        var options = this.options;\n\t        var validPointers = input.pointers.length === options.pointers;\n\t        var validMovement = input.distance < options.threshold;\n\t        var validTime = input.deltaTime > options.time;\n\t\n\t        this._input = input;\n\t\n\t        // we only allow little movement\n\t        // and we've reached an end event, so a tap is possible\n\t        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n\t            this.reset();\n\t        } else if (input.eventType & INPUT_START) {\n\t            this.reset();\n\t            this._timer = setTimeoutContext(function() {\n\t                this.state = STATE_RECOGNIZED;\n\t                this.tryEmit();\n\t            }, options.time, this);\n\t        } else if (input.eventType & INPUT_END) {\n\t            return STATE_RECOGNIZED;\n\t        }\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    reset: function() {\n\t        clearTimeout(this._timer);\n\t    },\n\t\n\t    emit: function(input) {\n\t        if (this.state !== STATE_RECOGNIZED) {\n\t            return;\n\t        }\n\t\n\t        if (input && (input.eventType & INPUT_END)) {\n\t            this.manager.emit(this.options.event + 'up', input);\n\t        } else {\n\t            this._input.timeStamp = now();\n\t            this.manager.emit(this.options.event, this._input);\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Rotate\n\t * Recognized when two or more pointer are moving in a circular motion.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction RotateRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(RotateRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof RotateRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'rotate',\n\t        threshold: 0,\n\t        pointers: 2\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_NONE];\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return this._super.attrTest.call(this, input) &&\n\t            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n\t    }\n\t});\n\t\n\t/**\n\t * Swipe\n\t * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction SwipeRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(SwipeRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof SwipeRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'swipe',\n\t        threshold: 10,\n\t        velocity: 0.65,\n\t        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n\t        pointers: 1\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return PanRecognizer.prototype.getTouchAction.call(this);\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        var direction = this.options.direction;\n\t        var velocity;\n\t\n\t        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n\t            velocity = input.velocity;\n\t        } else if (direction & DIRECTION_HORIZONTAL) {\n\t            velocity = input.velocityX;\n\t        } else if (direction & DIRECTION_VERTICAL) {\n\t            velocity = input.velocityY;\n\t        }\n\t\n\t        return this._super.attrTest.call(this, input) &&\n\t            direction & input.direction &&\n\t            input.distance > this.options.threshold &&\n\t            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n\t    },\n\t\n\t    emit: function(input) {\n\t        var direction = directionStr(input.direction);\n\t        if (direction) {\n\t            this.manager.emit(this.options.event + direction, input);\n\t        }\n\t\n\t        this.manager.emit(this.options.event, input);\n\t    }\n\t});\n\t\n\t/**\n\t * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n\t * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n\t * a single tap.\n\t *\n\t * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n\t * multi-taps being recognized.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction TapRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t\n\t    // previous time and center,\n\t    // used for tap counting\n\t    this.pTime = false;\n\t    this.pCenter = false;\n\t\n\t    this._timer = null;\n\t    this._input = null;\n\t    this.count = 0;\n\t}\n\t\n\tinherit(TapRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PinchRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'tap',\n\t        pointers: 1,\n\t        taps: 1,\n\t        interval: 300, // max time between the multi-tap taps\n\t        time: 250, // max time of the pointer to be down (like finger on the screen)\n\t        threshold: 10, // a minimal movement is ok, but keep it low\n\t        posThreshold: 10 // a multi-tap can be a bit off the initial position\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_MANIPULATION];\n\t    },\n\t\n\t    process: function(input) {\n\t        var options = this.options;\n\t        var validPointers = input.pointers.length === options.pointers;\n\t        var validMovement = input.distance < options.threshold;\n\t        var validTouchTime = input.deltaTime < options.time;\n\t        this.reset();\n\t\n\t        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n\t            return this.failTimeout();\n\t        }\n\t        // we only allow little movement\n\t        // and we've reached an end event, so a tap is possible\n\t        if (validMovement && validTouchTime && validPointers) {\n\t            if (input.eventType != INPUT_END) {\n\t                return this.failTimeout();\n\t            }\n\t\n\t            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n\t            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\t\n\t            this.pTime = input.timeStamp;\n\t            this.pCenter = input.center;\n\t            if (!validMultiTap || !validInterval) {\n\t                this.count = 1;\n\t            } else {\n\t                this.count += 1;\n\t            }\n\t\n\t            this._input = input;\n\t\n\t            // if tap count matches we have recognized it,\n\t            // else it has began recognizing...\n\t            var tapCount = this.count % options.taps;\n\t            if (tapCount === 0) {\n\t                // no failing requirements, immediately trigger the tap event\n\t                // or wait as long as the multitap interval to trigger\n\t                if (!this.hasRequireFailures()) {\n\t                    return STATE_RECOGNIZED;\n\t                } else {\n\t                    this._timer = setTimeoutContext(function() {\n\t                        this.state = STATE_RECOGNIZED;\n\t                        this.tryEmit();\n\t                    }, options.interval, this);\n\t                    return STATE_BEGAN;\n\t                }\n\t            }\n\t        }\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    failTimeout: function() {\n\t        this._timer = setTimeoutContext(function() {\n\t            this.state = STATE_FAILED;\n\t        }, this.options.interval, this);\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    reset: function() {\n\t        clearTimeout(this._timer);\n\t    },\n\t\n\t    emit: function() {\n\t        if (this.state == STATE_RECOGNIZED ) {\n\t            this._input.tapCount = this.count;\n\t            this.manager.emit(this.options.event, this._input);\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Simple way to create an manager with a default set of recognizers.\n\t * @param {HTMLElement} element\n\t * @param {Object} [options]\n\t * @constructor\n\t */\n\tfunction Hammer(element, options) {\n\t    options = options || {};\n\t    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n\t    return new Manager(element, options);\n\t}\n\t\n\t/**\n\t * @const {string}\n\t */\n\tHammer.VERSION = '2.0.4';\n\t\n\t/**\n\t * default settings\n\t * @namespace\n\t */\n\tHammer.defaults = {\n\t    /**\n\t     * set if DOM events are being triggered.\n\t     * But this is slower and unused by simple implementations, so disabled by default.\n\t     * @type {Boolean}\n\t     * @default false\n\t     */\n\t    domEvents: false,\n\t\n\t    /**\n\t     * The value for the touchAction property/fallback.\n\t     * When set to `compute` it will magically set the correct value based on the added recognizers.\n\t     * @type {String}\n\t     * @default compute\n\t     */\n\t    touchAction: TOUCH_ACTION_COMPUTE,\n\t\n\t    /**\n\t     * @type {Boolean}\n\t     * @default true\n\t     */\n\t    enable: true,\n\t\n\t    /**\n\t     * EXPERIMENTAL FEATURE -- can be removed/changed\n\t     * Change the parent input target element.\n\t     * If Null, then it is being set the to main element.\n\t     * @type {Null|EventTarget}\n\t     * @default null\n\t     */\n\t    inputTarget: null,\n\t\n\t    /**\n\t     * force an input class\n\t     * @type {Null|Function}\n\t     * @default null\n\t     */\n\t    inputClass: null,\n\t\n\t    /**\n\t     * Default recognizer setup when calling `Hammer()`\n\t     * When creating a new Manager these will be skipped.\n\t     * @type {Array}\n\t     */\n\t    preset: [\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n\t        [RotateRecognizer, { enable: false }],\n\t        [PinchRecognizer, { enable: false }, ['rotate']],\n\t        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\n\t        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n\t        [TapRecognizer],\n\t        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n\t        [PressRecognizer]\n\t    ],\n\t\n\t    /**\n\t     * Some CSS properties can be used to improve the working of Hammer.\n\t     * Add them to this method and they will be set when creating a new Manager.\n\t     * @namespace\n\t     */\n\t    cssProps: {\n\t        /**\n\t         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        userSelect: 'none',\n\t\n\t        /**\n\t         * Disable the Windows Phone grippers when pressing an element.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        touchSelect: 'none',\n\t\n\t        /**\n\t         * Disables the default callout shown when you touch and hold a touch target.\n\t         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n\t         * a callout containing information about the link. This property allows you to disable that callout.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        touchCallout: 'none',\n\t\n\t        /**\n\t         * Specifies whether zooming is enabled. Used by IE10>\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        contentZooming: 'none',\n\t\n\t        /**\n\t         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        userDrag: 'none',\n\t\n\t        /**\n\t         * Overrides the highlight color shown when the user taps a link or a JavaScript\n\t         * clickable element in iOS. This property obeys the alpha value, if specified.\n\t         * @type {String}\n\t         * @default 'rgba(0,0,0,0)'\n\t         */\n\t        tapHighlightColor: 'rgba(0,0,0,0)'\n\t    }\n\t};\n\t\n\tvar STOP = 1;\n\tvar FORCED_STOP = 2;\n\t\n\t/**\n\t * Manager\n\t * @param {HTMLElement} element\n\t * @param {Object} [options]\n\t * @constructor\n\t */\n\tfunction Manager(element, options) {\n\t    options = options || {};\n\t\n\t    this.options = merge(options, Hammer.defaults);\n\t    this.options.inputTarget = this.options.inputTarget || element;\n\t    this.handlers = {};\n\t    this.session = {};\n\t    this.recognizers = [];\n\t\n\t    this.element = element;\n\t    this.input = createInputInstance(this);\n\t    this.touchAction = new TouchAction(this, this.options.touchAction);\n\t\n\t    toggleCssProps(this, true);\n\t\n\t    each(options.recognizers, function(item) {\n\t        var recognizer = this.add(new (item[0])(item[1]));\n\t        item[2] && recognizer.recognizeWith(item[2]);\n\t        item[3] && recognizer.requireFailure(item[3]);\n\t    }, this);\n\t}\n\t\n\tManager.prototype = {\n\t    /**\n\t     * set options\n\t     * @param {Object} options\n\t     * @returns {Manager}\n\t     */\n\t    set: function(options) {\n\t        extend(this.options, options);\n\t\n\t        // Options that need a little more setup\n\t        if (options.touchAction) {\n\t            this.touchAction.update();\n\t        }\n\t        if (options.inputTarget) {\n\t            // Clean up existing event listeners and reinitialize\n\t            this.input.destroy();\n\t            this.input.target = options.inputTarget;\n\t            this.input.init();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * stop recognizing for this session.\n\t     * This session will be discarded, when a new [input]start event is fired.\n\t     * When forced, the recognizer cycle is stopped immediately.\n\t     * @param {Boolean} [force]\n\t     */\n\t    stop: function(force) {\n\t        this.session.stopped = force ? FORCED_STOP : STOP;\n\t    },\n\t\n\t    /**\n\t     * run the recognizers!\n\t     * called by the inputHandler function on every movement of the pointers (touches)\n\t     * it walks through all the recognizers and tries to detect the gesture that is being made\n\t     * @param {Object} inputData\n\t     */\n\t    recognize: function(inputData) {\n\t        var session = this.session;\n\t        if (session.stopped) {\n\t            return;\n\t        }\n\t\n\t        // run the touch-action polyfill\n\t        this.touchAction.preventDefaults(inputData);\n\t\n\t        var recognizer;\n\t        var recognizers = this.recognizers;\n\t\n\t        // this holds the recognizer that is being recognized.\n\t        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n\t        // if no recognizer is detecting a thing, it is set to `null`\n\t        var curRecognizer = session.curRecognizer;\n\t\n\t        // reset when the last recognizer is recognized\n\t        // or when we're in a new session\n\t        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n\t            curRecognizer = session.curRecognizer = null;\n\t        }\n\t\n\t        var i = 0;\n\t        while (i < recognizers.length) {\n\t            recognizer = recognizers[i];\n\t\n\t            // find out if we are allowed try to recognize the input for this one.\n\t            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n\t            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n\t            //      that is being recognized.\n\t            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n\t            //      this can be setup with the `recognizeWith()` method on the recognizer.\n\t            if (session.stopped !== FORCED_STOP && ( // 1\n\t                    !curRecognizer || recognizer == curRecognizer || // 2\n\t                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n\t                recognizer.recognize(inputData);\n\t            } else {\n\t                recognizer.reset();\n\t            }\n\t\n\t            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n\t            // current active recognizer. but only if we don't already have an active recognizer\n\t            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n\t                curRecognizer = session.curRecognizer = recognizer;\n\t            }\n\t            i++;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * get a recognizer by its event name.\n\t     * @param {Recognizer|String} recognizer\n\t     * @returns {Recognizer|Null}\n\t     */\n\t    get: function(recognizer) {\n\t        if (recognizer instanceof Recognizer) {\n\t            return recognizer;\n\t        }\n\t\n\t        var recognizers = this.recognizers;\n\t        for (var i = 0; i < recognizers.length; i++) {\n\t            if (recognizers[i].options.event == recognizer) {\n\t                return recognizers[i];\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * add a recognizer to the manager\n\t     * existing recognizers with the same event name will be removed\n\t     * @param {Recognizer} recognizer\n\t     * @returns {Recognizer|Manager}\n\t     */\n\t    add: function(recognizer) {\n\t        if (invokeArrayArg(recognizer, 'add', this)) {\n\t            return this;\n\t        }\n\t\n\t        // remove existing\n\t        var existing = this.get(recognizer.options.event);\n\t        if (existing) {\n\t            this.remove(existing);\n\t        }\n\t\n\t        this.recognizers.push(recognizer);\n\t        recognizer.manager = this;\n\t\n\t        this.touchAction.update();\n\t        return recognizer;\n\t    },\n\t\n\t    /**\n\t     * remove a recognizer by name or instance\n\t     * @param {Recognizer|String} recognizer\n\t     * @returns {Manager}\n\t     */\n\t    remove: function(recognizer) {\n\t        if (invokeArrayArg(recognizer, 'remove', this)) {\n\t            return this;\n\t        }\n\t\n\t        var recognizers = this.recognizers;\n\t        recognizer = this.get(recognizer);\n\t        recognizers.splice(inArray(recognizers, recognizer), 1);\n\t\n\t        this.touchAction.update();\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * bind event\n\t     * @param {String} events\n\t     * @param {Function} handler\n\t     * @returns {EventEmitter} this\n\t     */\n\t    on: function(events, handler) {\n\t        var handlers = this.handlers;\n\t        each(splitStr(events), function(event) {\n\t            handlers[event] = handlers[event] || [];\n\t            handlers[event].push(handler);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * unbind event, leave emit blank to remove all handlers\n\t     * @param {String} events\n\t     * @param {Function} [handler]\n\t     * @returns {EventEmitter} this\n\t     */\n\t    off: function(events, handler) {\n\t        var handlers = this.handlers;\n\t        each(splitStr(events), function(event) {\n\t            if (!handler) {\n\t                delete handlers[event];\n\t            } else {\n\t                handlers[event].splice(inArray(handlers[event], handler), 1);\n\t            }\n\t        });\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * emit event to the listeners\n\t     * @param {String} event\n\t     * @param {Object} data\n\t     */\n\t    emit: function(event, data) {\n\t        // we also want to trigger dom events\n\t        if (this.options.domEvents) {\n\t            triggerDomEvent(event, data);\n\t        }\n\t\n\t        // no handlers, so skip it all\n\t        var handlers = this.handlers[event] && this.handlers[event].slice();\n\t        if (!handlers || !handlers.length) {\n\t            return;\n\t        }\n\t\n\t        data.type = event;\n\t        data.preventDefault = function() {\n\t            data.srcEvent.preventDefault();\n\t        };\n\t\n\t        var i = 0;\n\t        while (i < handlers.length) {\n\t            handlers[i](data);\n\t            i++;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * destroy the manager and unbinds all events\n\t     * it doesn't unbind dom events, that is the user own responsibility\n\t     */\n\t    destroy: function() {\n\t        this.element && toggleCssProps(this, false);\n\t\n\t        this.handlers = {};\n\t        this.session = {};\n\t        this.input.destroy();\n\t        this.element = null;\n\t    }\n\t};\n\t\n\t/**\n\t * add/remove the css properties as defined in manager.options.cssProps\n\t * @param {Manager} manager\n\t * @param {Boolean} add\n\t */\n\tfunction toggleCssProps(manager, add) {\n\t    var element = manager.element;\n\t    each(manager.options.cssProps, function(value, name) {\n\t        element.style[prefixed(element.style, name)] = add ? value : '';\n\t    });\n\t}\n\t\n\t/**\n\t * trigger dom event\n\t * @param {String} event\n\t * @param {Object} data\n\t */\n\tfunction triggerDomEvent(event, data) {\n\t    var gestureEvent = document.createEvent('Event');\n\t    gestureEvent.initEvent(event, true, true);\n\t    gestureEvent.gesture = data;\n\t    data.target.dispatchEvent(gestureEvent);\n\t}\n\t\n\textend(Hammer, {\n\t    INPUT_START: INPUT_START,\n\t    INPUT_MOVE: INPUT_MOVE,\n\t    INPUT_END: INPUT_END,\n\t    INPUT_CANCEL: INPUT_CANCEL,\n\t\n\t    STATE_POSSIBLE: STATE_POSSIBLE,\n\t    STATE_BEGAN: STATE_BEGAN,\n\t    STATE_CHANGED: STATE_CHANGED,\n\t    STATE_ENDED: STATE_ENDED,\n\t    STATE_RECOGNIZED: STATE_RECOGNIZED,\n\t    STATE_CANCELLED: STATE_CANCELLED,\n\t    STATE_FAILED: STATE_FAILED,\n\t\n\t    DIRECTION_NONE: DIRECTION_NONE,\n\t    DIRECTION_LEFT: DIRECTION_LEFT,\n\t    DIRECTION_RIGHT: DIRECTION_RIGHT,\n\t    DIRECTION_UP: DIRECTION_UP,\n\t    DIRECTION_DOWN: DIRECTION_DOWN,\n\t    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n\t    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n\t    DIRECTION_ALL: DIRECTION_ALL,\n\t\n\t    Manager: Manager,\n\t    Input: Input,\n\t    TouchAction: TouchAction,\n\t\n\t    TouchInput: TouchInput,\n\t    MouseInput: MouseInput,\n\t    PointerEventInput: PointerEventInput,\n\t    TouchMouseInput: TouchMouseInput,\n\t    SingleTouchInput: SingleTouchInput,\n\t\n\t    Recognizer: Recognizer,\n\t    AttrRecognizer: AttrRecognizer,\n\t    Tap: TapRecognizer,\n\t    Pan: PanRecognizer,\n\t    Swipe: SwipeRecognizer,\n\t    Pinch: PinchRecognizer,\n\t    Rotate: RotateRecognizer,\n\t    Press: PressRecognizer,\n\t\n\t    on: addEventListeners,\n\t    off: removeEventListeners,\n\t    each: each,\n\t    merge: merge,\n\t    extend: extend,\n\t    inherit: inherit,\n\t    bindFn: bindFn,\n\t    prefixed: prefixed\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t    module.exports = Hammer;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t    return Hammer;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t    Base = __webpack_require__(2),\n\t    Animate = __webpack_require__(3),\n\t    Boundry = __webpack_require__(17),\n\t    Hammer = __webpack_require__(6),\n\t    Sticky = __webpack_require__(21),\n\t    Fixed = __webpack_require__(19);\n\t// boundry checked bounce effect\n\tvar BOUNDRY_CHECK_DURATION = 500;\n\tvar BOUNDRY_CHECK_EASING = \"ease\";\n\tvar BOUNDRY_CHECK_ACCELERATION = 0.1;\n\t/** \n\t * @constructor\n\t * @param {object} cfg config for scroll\n\t * @param {number} cfg.SCROLL_ACCELERATION  acceleration for scroll, min value make the scrolling smoothly\n\t * @param {number} cfg.BOUNDRY_CHECK_DURATION duration for boundry bounce\n\t * @param {number} cfg.BOUNDRY_CHECK_EASING easing for boundry bounce\n\t * @param {number} cfg.BOUNDRY_CHECK_ACCELERATION acceleration for boundry bounce\n\t * @param {boolean} cfg.lockX just like overflow-x:hidden\n\t * @param {boolean} cfg.lockY just like overflow-y:hidden\n\t * @param {boolean} cfg.scrollbarX config if the scrollbar-x is visible\n\t * @param {boolean} cfg.scrollbarY config if the scrollbar-y is visible\n\t * @param {boolean} cfg.useTransition config if use css3 transition or raf for scroll animation\n\t * @param {boolean} cfg.useOriginScroll config if use simulate or origin scroll\n\t * @param {boolean} cfg.bounce config if use has the bounce effect when scrolling outside of the boundry\n\t * @param {boolean} cfg.boundryCheck config if scrolling inside of the boundry\n\t * @param {boolean} cfg.preventDefault prevent touchstart\n\t * @param {boolean} cfg.preventTouchMove prevent touchmove\n\t * @param {string|HTMLElement}  cfg.container config for scroller's container which default value is \".xs-container\"\n\t * @param {string|HTMLElement}  cfg.content config for scroller's content which default value is \".xs-content\"\n\t * @param {object}  cfg.indicatorInsets  config scrollbars position {top: number, left: number, bottom: number, right: number}\n\t * @param {string}  cfg.stickyElements config for sticky-positioned elements\n\t * @param {string}  cfg.fixedElements config for fixed-positioned elements\n\t * @param {string}  cfg.touchAction config for touchAction of the scroller\n\t * @extends XScroll\n\t * @example\n\t * var xscroll = new XScroll({\n\t *    renderTo:\"#scroll\",\n\t *    lockX:false,\n\t *    scrollbarX:true\n\t * });\n\t * xscroll.render();\n\t */\n\tfunction XScroll(cfg) {\n\t    XScroll.superclass.constructor.call(this);\n\t    this.userConfig = cfg;\n\t    this.init();\n\t}\n\t\n\tUtil.extend(XScroll, Base, {\n\t    /**\n\t     * version\n\t     * @memberof XScroll\n\t     * @type {string}\n\t     */\n\t    version: \"3.0.13\",\n\t    /**\n\t     * init scroll\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    init: function() {\n\t        var self = this;\n\t        var defaultCfg = {\n\t            preventDefault: true,\n\t            bounce: true,\n\t            boundryCheck: true,\n\t            useTransition: true,\n\t            gpuAcceleration: true,\n\t            BOUNDRY_CHECK_EASING: BOUNDRY_CHECK_EASING,\n\t            BOUNDRY_CHECK_DURATION: BOUNDRY_CHECK_DURATION,\n\t            BOUNDRY_CHECK_ACCELERATION: BOUNDRY_CHECK_ACCELERATION,\n\t            useOriginScroll: false,\n\t            zoomType: \"y\",\n\t            indicatorInsets: {\n\t                top: 3,\n\t                bottom: 3,\n\t                left: 3,\n\t                right: 3,\n\t                width: 3,\n\t                spacing: 5\n\t            },\n\t            container: \".xs-container\",\n\t            content: \".xs-content\",\n\t            stickyElements: \".xs-sticky\",\n\t            fixedElements: \".xs-fixed\",\n\t            touchAction: \"auto\"\n\t        };\n\t        //generate guid\n\t        self.guid = Util.guid();\n\t        self.renderTo = Util.getNode(self.userConfig.renderTo);\n\t        //timer for animtion\n\t        self.__timers = {};\n\t        //config attributes on element\n\t        var elCfg = JSON.parse(self.renderTo.getAttribute('xs-cfg'));\n\t        var userConfig = self.userConfig = Util.mix(Util.mix(defaultCfg, elCfg), self.userConfig);\n\t        self.container = Util.getNode(userConfig.container,self.renderTo);\n\t        self.content = Util.getNode(userConfig.content,self.renderTo);\n\t        self.boundry = new Boundry();\n\t        self.boundry.refresh();\n\t        return self;\n\t    },\n\t    /**\n\t     * destroy scroll\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    destroy: function() {\n\t        var self = this;\n\t        self.mc && self.mc.destroy();\n\t        self.sticky && self.sticky.destroy();\n\t        self.fixed && self.fixed.destroy();\n\t    },\n\t    _initContainer: function() {},\n\t    /**\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    enableGPUAcceleration: function() {\n\t        this.userConfig.gpuAcceleration = true;\n\t        return this;\n\t    },\n\t    /**\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    disableGPUAcceleration: function() {\n\t        this.userConfig.gpuAcceleration = false;\n\t        return this;\n\t    },\n\t    /**\n\t     * get scroll offset\n\t     * @memberof XScroll\n\t     * @return {Object} {scrollTop:scrollTop,scrollLeft:scrollLeft}\n\t     */\n\t    getScrollPos: function() {\n\t        var self = this;\n\t        return {\n\t            scrollLeft: self.getScrollLeft(),\n\t            scrollTop: self.getScrollTop()\n\t        }\n\t    },\n\t    /**\n\t     * get scroll top value\n\t     * @memberof XScroll\n\t     * @return {number} scrollTop\n\t     */\n\t    getScrollTop: function() {},\n\t    /**\n\t     * get scroll left value\n\t     * @memberof XScroll\n\t     * @return {number} scrollLeft\n\t     */\n\t    getScrollLeft: function() {},\n\t    /**\n\t     * scroll absolute to the destination\n\t     * @memberof XScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollTo: function(scrollLeft, scrollTop, duration, easing, callback) {\n\t        var self = this;\n\t        var scrollLeft = (undefined === scrollLeft || isNaN(scrollLeft)) ? -self.getScrollLeft() : scrollLeft;\n\t        var scrollTop = (undefined === scrollTop || isNaN(scrollTop)) ? -self.getScrollTop() : scrollTop;\n\t        self.scrollLeft(scrollLeft, duration, easing, callback);\n\t        self.scrollTop(scrollTop, duration, easing, callback);\n\t    },\n\t    /**\n\t     * scroll relative to the destination\n\t     * @memberof XScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollBy: function(scrollLeft, scrollTop, duration, easing, callback) {\n\t        this.scrollByX(scrollLeft, duration, easing, callback);\n\t        this.scrollByY(scrollTop, duration, easing, callback);\n\t    },\n\t    /**\n\t     * horizontal scroll relative to the destination\n\t     * @memberof XScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollLeftBy: function(scrollLeft, duration, easing, callback) {\n\t        this.scrollLeft(Number(scrollLeft) + Number(this.getScrollLeft()), duration, easing, callback);\n\t    },\n\t    /**\n\t     * vertical scroll relative to the destination\n\t     * @memberof XScroll\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollTopBy: function(scrollTop, duration, easing, callback) {\n\t        this.scrollTop(Number(scrollTop) + Number(this.getScrollTop()), duration, easing, callback);\n\t    },\n\t    /**\n\t     * horizontal scroll absolute to the destination\n\t     * @memberof XScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollLeft: function(scrollLeft, duration, easing, callback) {},\n\t    /**\n\t     * vertical scroll absolute to the destination\n\t     * @memberof XScroll\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollTop: function(scrollTop, duration, easing, callback) {},\n\t    /**\n\t     * reset the boundry size\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    resetSize: function() {\n\t        var self = this;\n\t        if(!self.container || !self.content) return;\n\t        var userConfig = self.userConfig;\n\t        var renderToStyle = getComputedStyle(self.renderTo);\n\t        var width = self.width = (userConfig.width || self.renderTo.offsetWidth) - Util.px2Num(renderToStyle['padding-left']) - Util.px2Num(renderToStyle['padding-right']);\n\t        var height = self.height = (userConfig.height || self.renderTo.offsetHeight) - Util.px2Num(renderToStyle['padding-top']) - Util.px2Num(renderToStyle['padding-bottom']);;\n\t        var containerWidth = userConfig.containerWidth || self.content.offsetWidth;\n\t        var containerHeight = userConfig.containerHeight || self.content.offsetHeight;\n\t        self.containerWidth = containerWidth < self.width ? self.width : containerWidth;\n\t        self.containerHeight = containerHeight < self.height ? self.height : containerHeight;\n\t        self.boundry.refresh({\n\t            width: self.width,\n\t            height: self.height\n\t        });\n\t        return self;\n\t    },\n\t    /**\n\t     * render scroll\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    render: function() {\n\t        var self = this;\n\t        self.resetSize();\n\t        //init stickies\n\t        self.initSticky();\n\t        //init fixed elements\n\t        self.initFixed();\n\t\n\t        self.trigger(\"afterrender\", {\n\t            type: \"afterrender\"\n\t        });\n\t        self._bindEvt();\n\t        //update touch-action \n\t        self.initTouchAction();\n\t        return self;\n\t    },\n\t    /**\n\t     * init touch action\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    initTouchAction: function() {\n\t        var self = this;\n\t        self.mc.set({\n\t            touchAction: self.userConfig.touchAction\n\t        });\n\t        return self;\n\t    },\n\t    initFixed: function() {\n\t        var self = this,\n\t            userConfig = self.userConfig;\n\t        self.fixed = self.fixed || new Fixed({\n\t            fixedElements:userConfig.fixedElements,\n\t            xscroll:self,\n\t            fixedRenderTo:userConfig.fixedRenderTo\n\t        });\n\t        self.fixed.render();\n\t        self.resetSize();\n\t        return self;\n\t    },\n\t    initSticky:function(){\n\t        var self = this,userConfig = self.userConfig;\n\t        var sticky = self.sticky = self.sticky || new Sticky({\n\t            xscroll:self,\n\t            zoomType:userConfig.zoomType,\n\t            stickyRenderTo:userConfig.stickyRenderTo\n\t        });\n\t        sticky.render();\n\t    },\n\t    /**\n\t     * bounce to the boundry vertical and horizontal\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    boundryCheck: function() {\n\t        return this;\n\t    },\n\t    /**\n\t     * bounce to the boundry horizontal\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    boundryCheckX: function() {\n\t        return this;\n\t    },\n\t    /**\n\t     * bounce to the boundry vertical\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    boundryCheckY: function() {\n\t        return this;\n\t    },\n\t    _bindEvt: function() {\n\t        var self = this;\n\t        if (self.___isEvtBind) return;\n\t        self.___isEvtBind = true;\n\t        var mc = self.mc = new Hammer.Manager(self.renderTo);\n\t        var tap = new Hammer.Tap();\n\t        var pan = new Hammer.Pan();\n\t        var pinch = new Hammer.Pinch();\n\t        mc.add([tap, pan]);\n\t        //trigger all events \n\t        self.mc.on(\"panstart pan panend pancancel pinchstart pinchmove pinchend pinchcancel pinchin pinchout\", function(e) {\n\t            self.trigger(e.type, e);\n\t        });\n\t        //trigger touch events\n\t        var touchEvents = ['touchstart', 'touchmove', 'touchend', 'touchcancel','mousedown'];\n\t        for (var i = 0, l = touchEvents.length; i < l; i++) {\n\t            self.renderTo.addEventListener(touchEvents[i], function(e) {\n\t                self.trigger(e.type, e);\n\t            });\n\t        }\n\t        self.mc.on(\"tap\", function(e) {\n\t            if (e.tapCount == 1) {\n\t                e.type = \"tap\";\n\t                self.trigger(e.type, e);\n\t            } else if (e.tapCount == 2) {\n\t                e.type = \"doubletap\";\n\t                self.trigger(\"doubletap\", e);\n\t            }\n\t        });\n\t        return self;\n\t    },\n\t    _resetLockConfig: function() {},\n\t    stop: function() {}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t    module.exports = XScroll;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t    return XScroll;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\t//easing\n\tvar Easing = {\n\t\t\"linear\": [0, 0, 1, 1],\n\t\t\"ease\": [.25, .1, .25, 1],\n\t\t\"ease-in\":[.42,0,1,1],\n\t\t\"ease-out\": [0, 0, .58, 1],\n\t\t\"ease-in-out\": [.42, 0, .58, 1],\n\t\t\"quadratic\": [0.33, 0.66, 0.66, 1],\n\t\t\"circular\": [0.1, 0.57, 0.1, 1],\n\t\t\"bounce\": [.71, 1.35, .47, 1.41],\n\t\tformat: function(easing) {\n\t\t\tif (!easing) return;\n\t\t\tif (typeof easing === \"string\" && this[easing]) {\n\t\t\t\treturn this[easing] instanceof Array ? [\" cubic-bezier(\", this[easing], \") \"].join(\"\") : this[easing];\n\t\t\t}\n\t\t\tif (easing instanceof Array) {\n\t\t\t\treturn [\" cubic-bezier(\", easing, \") \"].join(\"\");\n\t\t\t}\n\t\t\treturn easing;\n\t\t}\n\t}\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Easing;\n\t}\n\t/** ignored by jsdoc **/\n\t else {\n\t\treturn Easing;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\tvar Easing = __webpack_require__(8);\n\t\n\tvar RAF = window.requestAnimationFrame ||\n\t\twindow.webkitRequestAnimationFrame ||\n\t\twindow.mozRequestAnimationFrame ||\n\t\twindow.oRequestAnimationFrame ||\n\t\twindow.msRequestAnimationFrame ||\n\t\tfunction(callback) {\n\t\t\twindow.setTimeout(callback, 1000 / 60);\n\t\t};\n\t\n\tvar vendors = ['webkit', 'moz', 'ms', 'o'];\n\tvar cancelRAF = window.cancelAnimationFrame;\n\tfor (var i = 0; i < vendors.length; i++) {\n\t\tif (window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame']) {\n\t\t\tcancelRAF = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];\n\t\t}\n\t}\n\tcancelRAF = cancelRAF || window.clearTimeout;\n\t\n\tfunction Bezier(x1, y1, x2, y2, epsilon) {\n\t\tvar curveX = function(t) {\n\t\t\tvar v = 1 - t;\n\t\t\treturn 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;\n\t\t};\n\t\n\t\tvar curveY = function(t) {\n\t\t\tvar v = 1 - t;\n\t\t\treturn 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;\n\t\t};\n\t\n\t\tvar derivativeCurveX = function(t) {\n\t\t\tvar v = 1 - t;\n\t\t\treturn 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (-t * t * t + 2 * v * t) * x2;\n\t\t};\n\t\n\t\treturn function(t) {\n\t\n\t\t\tvar x = t,\n\t\t\t\tt0, t1, t2, x2, d2, i;\n\t\n\t\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\t\tfor (t2 = x, i = 0; i < 8; i++) {\n\t\t\t\tx2 = curveX(t2) - x;\n\t\t\t\tif (Math.abs(x2) < epsilon) return curveY(t2);\n\t\t\t\td2 = derivativeCurveX(t2);\n\t\t\t\tif (Math.abs(d2) < 1e-6) break;\n\t\t\t\tt2 = t2 - x2 / d2;\n\t\t\t}\n\t\n\t\t\tt0 = 0, t1 = 1, t2 = x;\n\t\n\t\t\tif (t2 < t0) return curveY(t0);\n\t\t\tif (t2 > t1) return curveY(t1);\n\t\n\t\t\t// Fallback to the bisection method for reliability.\n\t\t\twhile (t0 < t1) {\n\t\t\t\tx2 = curveX(t2);\n\t\t\t\tif (Math.abs(x2 - x) < epsilon) return curveY(t2);\n\t\t\t\tif (x > x2) t0 = t2;\n\t\t\t\telse t1 = t2;\n\t\t\t\tt2 = (t1 - t0) * .5 + t0;\n\t\t\t}\n\t\n\t\t\t// Failure\n\t\t\treturn curveY(t2);\n\t\n\t\t};\n\t\n\t};\n\t\n\t\n\t\n\tfunction Timer(cfg) {\n\t\tvar self = this;\n\t\tself.cfg = Util.mix({\n\t\t\teasing: \"linear\"\n\t\t}, cfg)\n\t}\n\t\n\tTimer.MIN_DURATION = 1;\n\t\n\tUtil.extend(Timer, Base, {\n\t\treset: function(cfg) {\n\t\t\tvar self = this;\n\t\t\tUtil.mix(self.cfg, cfg);\n\t\t\tself.isfinished = false;\n\t\t\tself.percent = 0;\n\t\t\tself._stop = null;\n\t\t},\n\t\trun: function() {\n\t\t\tvar self = this;\n\t\t\tvar duration = self.cfg.duration;\n\t\t\tif (duration <= Timer.MIN_DURATION) {\n\t\t\t\tself.isfinished = true;\n\t\t\t\tself.trigger(\"run\", {\n\t\t\t\t\tpercent: 1\n\t\t\t\t});\n\t\t\t\tself.trigger(\"end\", {\n\t\t\t\t\tpercent: 1\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (self.isfinished) return;\n\t\t\tself._hasFinishedPercent = self._stop && self._stop.percent || 0;\n\t\t\tself._stop = null;\n\t\t\tself.start = Date.now();\n\t\t\tself.percent = 0;\n\t\t\t// epsilon determines the precision of the solved values\n\t\t\tvar epsilon = (1000 / 60 / duration) / 4;\n\t\t\tvar b = Easing[self.cfg.easing];\n\t\t\tself.easingFn = Bezier(b[0], b[1], b[2], b[3], epsilon);\n\t\t\tself._run();\n\t\t},\n\t\t_run: function() {\n\t\t\tvar self = this;\n\t\t\tcancelRAF(self._raf);\n\t\t\tself._raf = RAF(function() {\n\t\t\t\tself.now = Date.now();\n\t\t\t\tself.duration = self.now - self.start >= self.cfg.duration ? self.cfg.duration : self.now - self.start;\n\t\t\t\tself.progress = self.easingFn(self.duration / self.cfg.duration);\n\t\t\t\tself.percent = self.duration / self.cfg.duration + self._hasFinishedPercent;\n\t\t\t\tif (self.percent >= 1 || self._stop) {\n\t\t\t\t\tself.percent = self._stop && self._stop.percent ? self._stop.percent : 1;\n\t\t\t\t\tself.duration = self._stop && self._stop.duration ? self._stop.duration : self.duration;\n\t\t\t\t\tvar param = {\n\t\t\t\t\t\tpercent: self.percent\n\t\t\t\t\t};\n\t\t\t\t\tself.trigger(\"stop\", param);\n\t\t\t\t\tif (self.percent >= 1) {\n\t\t\t\t\t\tself.isfinished = true;\n\t\t\t\t\t\tself.trigger(\"end\", {\n\t\t\t\t\t\t\tpercent: 1\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tself.trigger(\"run\", {\n\t\t\t\t\tpercent: self.progress,\n\t\t\t\t\toriginPercent:self.percent\n\t\t\t\t});\n\t\t\t\tself._run();\n\t\t\t})\n\t\t},\n\t\tstop: function() {\n\t\t\tvar self = this;\n\t\t\tself._stop = {\n\t\t\t\tpercent: self.percent,\n\t\t\t\tnow: self.now\n\t\t\t};\n\t\t\tcancelRAF(self._raf)\n\t\t}\n\t});\n\t\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Timer;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Timer;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(React) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(14);\n\t\n\t__webpack_require__(15);\n\t\n\tvar _xscroll = __webpack_require__(28);\n\t\n\tvar _xscroll2 = _interopRequireDefault(_xscroll);\n\t\n\tvar _pullup = __webpack_require__(26);\n\t\n\tvar _pullup2 = _interopRequireDefault(_pullup);\n\t\n\tvar _pulldown = __webpack_require__(25);\n\t\n\tvar _pulldown2 = _interopRequireDefault(_pulldown);\n\t\n\tvar _infinite = __webpack_require__(24);\n\t\n\tvar _infinite2 = _interopRequireDefault(_infinite);\n\t\n\tvar _classnames = __webpack_require__(29);\n\t\n\tvar _classnames2 = _interopRequireDefault(_classnames);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar uid = 0;\n\t\n\tvar ReactXScroll = function (_React$Component) {\n\t  _inherits(ReactXScroll, _React$Component);\n\t\n\t  function ReactXScroll(props) {\n\t    _classCallCheck(this, ReactXScroll);\n\t\n\t    var _this = _possibleConstructorReturn(this, (ReactXScroll.__proto__ || Object.getPrototypeOf(ReactXScroll)).call(this, props));\n\t\n\t    _this._renderId = 'rn-xscroll-' + uid++;\n\t    _this.state = {\n\t      cssClass: props.cssClass\n\t    };\n\t    return _this;\n\t  }\n\t\n\t  _createClass(ReactXScroll, [{\n\t    key: 'createIscroll',\n\t    value: function createIscroll() {\n\t      var options = Object.assign({\n\t        renderTo: '#' + this._renderId\n\t      }, this.props.xscrollOptions);\n\t      return new _xscroll2.default(options);\n\t    }\n\t  }, {\n\t    key: 'createPullUpPlugin',\n\t    value: function createPullUpPlugin() {\n\t      if (this.props.pullupOptions) {\n\t        var self = this;\n\t        var pullup = new _pullup2.default(this.props.pullupOptions);\n\t        pullup.on('loading', function () {\n\t          self.props.onInfinite(self);\n\t        });\n\t        this._xscroll.plug(pullup);\n\t        return pullup;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'createPullDownPlugin',\n\t    value: function createPullDownPlugin() {\n\t      if (this.props.pulldownOptions) {\n\t        var self = this;\n\t        var pulldown = new _pulldown2.default(this.props.pulldownOptions);\n\t        pulldown.on('loading', function (e) {\n\t          self.props.onRefresh(self);\n\t        });\n\t        this._xscroll.plug(pulldown);\n\t        return pulldown;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'createInfinitePlugin',\n\t    value: function createInfinitePlugin() {\n\t      if (this.props.infiniteOptions) {\n\t        var infinite = new _infinite2.default(this.props.infiniteOptions);\n\t        this._xscroll.plug(infinite);\n\t        return infinite;\n\t      }\n\t    }\n\t  }, {\n\t    key: 'componentDidMount',\n\t    value: function componentDidMount() {\n\t      var self = this;\n\t      var xscroll = this._xscroll = this.createIscroll();\n\t      xscroll.render();\n\t    }\n\t  }, {\n\t    key: 'attachPlugins',\n\t    value: function attachPlugins() {\n\t      this._infinite = this.createInfinitePlugin();\n\t      this._pullup = this.createPullUpPlugin();\n\t      this._pulldown = this.createPullDownPlugin();\n\t      //initial once:?\n\t      this.props.onInfinite && this.props.onInfinite(this);\n\t    }\n\t  }, {\n\t    key: 'invoke',\n\t    value: function invoke(inName) {\n\t      var args = [].slice.call(arguments, 1);\n\t      return this._xscroll[inName].apply(this._xscroll, args);\n\t    }\n\t  }, {\n\t    key: 'componentWillReceiveProps',\n\t    value: function componentWillReceiveProps(nextProps) {\n\t      this.setState(nextProps);\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render() {\n\t      return React.createElement(\n\t        'div',\n\t        { id: this._renderId,\n\t          className: (0, _classnames2.default)('react-xscroll', this.state.cssClass) },\n\t        React.createElement(\n\t          'div',\n\t          { className: 'xs-container' },\n\t          React.createElement(\n\t            'div',\n\t            { className: 'xs-content' },\n\t            this.props.children\n\t          )\n\t        )\n\t      );\n\t    }\n\t  }]);\n\t\n\t  return ReactXScroll;\n\t}(React.Component);\n\t\n\tReactXScroll.propTypes = {\n\t  cssClass: React.PropTypes.string,\n\t  xscrollOptions: React.PropTypes.object,\n\t  pulldownOptions: React.PropTypes.object,\n\t  pullupOptions: React.PropTypes.object,\n\t  infiniteOptions: React.PropTypes.object,\n\t  onRefresh: React.PropTypes.func,\n\t  onInfinite: React.PropTypes.func\n\t};\n\tReactXScroll.defaultProps = {\n\t  xscrollOptions: {},\n\t  pulldownOptions: null,\n\t  pullupOptions: null,\n\t  infiniteOptions: null,\n\t  onRefresh: null,\n\t  onInfinite: null\n\t};\n\texports.default = ReactXScroll;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".xs-plugin-pulldown-container{text-align:center;width:100%;line-height:50px}.xs-plugin-pulldown-up .up{display:inline}.xs-plugin-pulldown-down .up,.xs-plugin-pulldown-up .down{display:none}.xs-plugin-pulldown-down .down{display:inline}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".xs-plugin-pullup-container{line-height:40px;text-align:center}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".react-xscroll{width:100%;position:absolute}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(11);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(12);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(13);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\t var Util = __webpack_require__(1);\n\t\n\t function Boundry(cfg) {\n\t     this.cfg = Util.mix({\n\t         width: 0,\n\t         height: 0\n\t     }, cfg)\n\t     this.init();\n\t }\n\t Util.mix(Boundry.prototype, {\n\t     init: function() {\n\t         var self = this;\n\t         self._xtop = 0;\n\t         self._xright = 0;\n\t         self._xleft = 0;\n\t         self._xbottom = 0;\n\t         self.refresh({\n\t             width: self.cfg.width,\n\t             height: self.cfg.height\n\t         });\n\t     },\n\t     reset: function() {\n\t         this.resetTop();\n\t         this.resetLeft();\n\t         this.resetBottom();\n\t         this.resetRight();\n\t         return this;\n\t     },\n\t     resetTop: function() {\n\t         this._xtop = 0;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     resetLeft: function() {\n\t         this._xleft = 0;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     resetBottom: function() {\n\t         this._xbottom = 0;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     resetRight: function() {\n\t         this._xright = 0;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     expandTop: function(top) {\n\t         this._xtop = top;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     expandLeft: function(left) {\n\t         this._xleft = left;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     expandRight: function(right) {\n\t         this._xright = right;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     expandBottom: function(bottom) {\n\t         this._xbottom = bottom;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     refresh: function(cfg) {\n\t         Util.mix(this.cfg, cfg);\n\t         this.top = this._xtop;\n\t         this.left = this._xleft;\n\t         this.bottom = (cfg && cfg.height || this.cfg.height || 0) - this._xbottom;\n\t         this.right = (cfg && cfg.width || this.cfg.width || 0) - this._xright;\n\t         this.width = this.right - this.left > 0 ? this.right - this.left : 0;\n\t         this.height = this.bottom - this.top > 0 ? this.bottom - this.top : 0;\n\t         return this;\n\t     }\n\t });\n\t\n\t\n\t if (typeof module == 'object' && module.exports) {\n\t     module.exports = Boundry;\n\t }\n\t /** ignored by jsdoc **/\n\t else{\n\t    return Boundry;\n\t }\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t/*\n\t\twrapped scroll controller\n\t*/\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t\tBase = __webpack_require__(2);\n\t\n\tvar Controller = function(cfg) {\n\t\tController.superclass.constructor.call(this, cfg);\n\t\tthis.userConfig = Util.mix({}, cfg);\n\t\tthis.init();\n\t}\n\t\n\tUtil.extend(Controller, Base, {\n\t\tinit: function() {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = self.userConfig.xscroll;\n\t\t},\n\t\tadd: function(scroll, cfg) {\n\t\t\tvar self = this;\n\t\t\tcfg = Util.extend({\n\t\t\t\tcaptureBounce: false,\n\t\t\t\tstopPropagation: true\n\t\t\t}, cfg)\n\t\t\tif (!self.__scrolls) {\n\t\t\t\tself.__scrolls = {};\n\t\t\t}\n\t\t\tif (scroll.guid && !self.__scrolls[scroll.guid]) {\n\t\t\t\tscroll.parentscroll = self.xscroll;\n\t\t\t\tself._bind(scroll);\n\t\t\t\treturn self.__scrolls[scroll.guid] = scroll;\n\t\t\t}\n\t\t\treturn;\n\t\t},\n\t\tremove: function(scroll) {\n\t\t\tvar self = this;\n\t\t\tif (!scroll || !scroll.guid) return;\n\t\t\tvar subscroll = self.__scrolls[scroll.guid];\n\t\t\tif (subscroll) {\n\t\t\t\tsubscroll.parentscroll = null;\n\t\t\t\tself._unbind(scroll);\n\t\t\t\tsubscroll = null;\n\t\t\t}\n\t\t},\n\t\tget: function(guid) {\n\t\t\tif (guid) {\n\t\t\t\treturn this.__scrolls[guid];\n\t\t\t}\n\t\t\treturn this.__scrolls;\n\t\t},\n\t\n\t\t_unbind: function(sub) {\n\t\n\t\t},\n\t\n\t\t_bind: function(sub) {\n\t\t\tvar self = this,\n\t\t\t\txscroll = self.xscroll;\n\t\t\txscroll.renderTo.addEventListener(\"touchstart\", function() {\n\t\t\t\txscroll._resetLockConfig();\n\t\t\t});\n\t\t\tsub.renderTo.addEventListener(\"touchstart\", function() {\n\t\t\t\tsub._resetLockConfig();\n\t\t\t});\n\t\t\txscroll.on(\"panend\", xscroll._resetLockConfig);\n\t\t\tsub.on(\"panend\", sub._resetLockConfig);\n\t\t\tsub.on(\"panstart\", function(e) {\n\t\t\t\t//vertical scroll enabled\n\t\t\t\tif (!sub.userConfig.lockY && !xscroll.userConfig.lockY) {\n\t\t\t\t\t//outside of boundry\n\t\t\t\t\tif (sub.isBoundryOut()) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.direction == 16 && sub.getBoundryOutTop() >= 0) {\n\t\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t\t} else if (e.direction == 8 && sub.getBoundryOutTop() >= 0 && sub.getBoundryOutBottom() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.direction == 8 && sub.getBoundryOutBottom() >= 0) {\n\t\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t\t} else if (e.direction == 16 && sub.getBoundryOutBottom() >= 0 && sub.getBoundryOutTop() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (sub.getBoundryOutTop() < 0 && sub.getBoundryOutBottom() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//horizontal scroll enabled\n\t\t\t\tif (!sub.userConfig.lockX && !xscroll.userConfig.lockX) {\n\t\t\t\t\tif (sub.isBoundryOut()) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.direction == 4 && sub.getBoundryOutLeft() >= 0) {\n\t\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t\t} else if (e.direction == 2 && sub.getBoundryOutLeft() >= 0 && sub.getBoundryOutRight() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.direction == 2 && sub.getBoundryOutRight() >= 0) {\n\t\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t\t} else if (e.direction == 4 && sub.getBoundryOutRight() >= 0 && sub.getBoundryOutLeft() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (sub.getBoundryOutLeft() < 0 && sub.getBoundryOutRight() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!sub.userConfig.lockX && xscroll.userConfig.lockX) {\n\t\t\t\t\t//pan x\n\t\t\t\t\tif (e.direction == 2 || e.direction == 4) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!sub.userConfig.lockY && xscroll.userConfig.lockY) {\n\t\t\t\t\t//pan y\n\t\t\t\t\tif (e.direction == 8 || e.direction == 16) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Controller;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Controller;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\tvar transform = Util.prefixStyle(\"transform\");\n\t\n\tvar Fixed = function(cfg) {\n\t  Fixed.superclass.constructor.call(this, cfg);\n\t  this.userConfig = Util.mix({\n\t    fixedRenderTo: undefined,\n\t    fixedElements: \".xs-fixed\",\n\t    prefix: \"xs-fixed-container\",\n\t    zoomType: \"y\"\n\t  }, cfg);\n\t  this.init();\n\t}\n\t\n\tUtil.extend(Fixed, Base, {\n\t  fixedElements: [],\n\t  init: function() {\n\t    var self = this,\n\t      userConfig = self.userConfig,\n\t      xscroll = self.xscroll = userConfig.xscroll,\n\t      xscrollConfig = self.xscrollConfig = xscroll.userConfig;\n\t    self.isY = !!(userConfig.zoomType == \"y\");\n\t    self._ = self.isY ? {\n\t      top: \"top\",\n\t      height: \"height\",\n\t      width: \"width\",\n\t      offsetTop:\"offsetTop\"\n\t    } : {\n\t      top: \"left\",\n\t      height: \"width\",\n\t      width: \"height\",\n\t      offsetTop:\"offsetLeft\"\n\t    };\n\t    self.fixedRenderTo = Util.getNode(userConfig.fixedRenderTo);\n\t    return self;\n\t  },\n\t  render: function() {\n\t    var self = this;\n\t    var xscroll = self.xscroll;\n\t    self.infinite = xscroll.getPlugin(\"infinite\");\n\t    if (!self.fixedRenderTo) {\n\t      self.fixedRenderTo = document.createElement('div');\n\t      xscroll.renderTo.appendChild(self.fixedRenderTo);\n\t    }\n\t    Util.addClass(self.fixedRenderTo, self.userConfig.prefix);\n\t    var originalFixedElements = self.originalFixedElements = self.getFixedElements();\n\t    for (var i = 0, l = originalFixedElements.length; i < l; i++) {\n\t      self.renderFixedElement(originalFixedElements[i], i,self.fixedRenderTo);\n\t    }\n\t    return self;\n\t  },\n\t  getFixedElements: function() {\n\t    var self = this;\n\t    var infinite = self.infinite;\n\t    var userConfig = self.userConfig;\n\t    if (infinite) {\n\t      var els = [];\n\t      for (var i in infinite.__serializedData) {\n\t        var data = infinite.__serializedData[i];\n\t        if (data && data.style && data.style.position == \"fixed\") {\n\t          els.push(data);\n\t        }\n\t      }\n\t      return els;\n\t    } else {\n\t      return Util.getNodes(userConfig.fixedElements, self.xscroll.content);\n\t    }\n\t  },\n\t  renderFixedElement: function(el, fixedIndex,fixedRenderTo) {\n\t    var self = this;\n\t    var isRender = true;\n\t    var _ = self._;\n\t    var xscroll = self.xscroll;\n\t    var userConfig = self.userConfig;\n\t    var xscrollConfig = self.xscrollConfig;\n\t    var useOriginScroll = xscrollConfig.useOriginScroll;\n\t    var infinite = self.infinite;\n\t    var fixedElement = self.fixedElements[fixedIndex];\n\t    if (!self.fixedElements[fixedIndex]) {\n\t      isRender = false;\n\t      if (useOriginScroll && !infinite) {\n\t        //use original position:fixed stylesheet\n\t        el.style.position = \"fixed\";\n\t        el.style.display = \"block\";\n\t      } else {\n\t        //deep clone fixed nodes and hide original nodes\n\t        fixedElement = document.createElement(\"div\");\n\t        if (infinite) {\n\t          fixedElement.setAttribute(\"style\", Util.stringifyStyle(Util.mix(el.style, {\n\t            display: \"block\",\n\t            width: \"100%\"\n\t          })));\n\t          fixedElement.style[_.top] = (el.style[_.top] >= 0 ? el.style[_.top] : el._top) + \"px\";\n\t          if (el.style[_.height]) {\n\t            fixedElement.style[_.height] = el.style[_.height] + \"px\";\n\t          }\n\t          infinite.userConfig.renderHook.call(self, fixedElement, el);\n\t        } else {\n\t          fixedElement.style.display = \"block\";\n\t          fixedElement.style.position = \"absolute\";\n\t          fixedElement.style[_.width] = \"100%\";\n\t          fixedElement.innerHTML = el.innerHTML;\n\t          fixedElement.className = el.className;\n\t          fixedElement.setAttribute(\"style\", el.getAttribute(\"style\"));\n\t          fixedElement.style[_.top] = el[_.offsetTop] + \"px\";\n\t          el.style.display = \"none\";\n\t        }\n\t        fixedRenderTo.appendChild(fixedElement);\n\t        self.fixedElements.push(fixedElement);\n\t      }\n\t    }\n\t    xscroll.trigger(\"fixedchange\", {\n\t      fixedIndex: fixedIndex,\n\t      fixedElement: useOriginScroll ? el : fixedElement,\n\t      originalFixedElement: el,\n\t      isRender: isRender\n\t    });\n\t  },\n\t  destroy: function() {\n\t    var self = this;\n\t    self.fixedElements = undefined;\n\t  }\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t  module.exports = Fixed;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t  return Fixed;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Animate = __webpack_require__(3);\n\tvar MAX_BOUNCE_DISTANCE = 40;\n\tvar MIN_BAR_SCROLLED_SIZE = 10;\n\tvar MIN_BAR_SIZE = 50;\n\tvar transform = Util.prefixStyle(\"transform\");\n\tvar transformStr = Util.vendor ? [\"-\", Util.vendor, \"-transform\"].join(\"\") : \"transform\";\n\tvar transition = Util.prefixStyle(\"transition\");\n\tvar borderRadius = Util.prefixStyle(\"borderRadius\");\n\tvar transitionDuration = Util.prefixStyle(\"transitionDuration\");\n\t\n\tvar ScrollBar = function(cfg) {\n\t\tthis.userConfig = Util.mix({\n\t\t\tMIN_BAR_SCROLLED_SIZE:MIN_BAR_SCROLLED_SIZE,\n\t\t\tMIN_BAR_SIZE:MIN_BAR_SIZE,\n\t\t\tMAX_BOUNCE_DISTANCE:MAX_BOUNCE_DISTANCE,\n\t\t\tspacing:5\n\t\t}, cfg);\n\t\tthis.init(cfg.xscroll);\n\t}\n\t\n\tUtil.mix(ScrollBar.prototype, {\n\t\tinit: function(xscroll) {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = xscroll;\n\t\t\tself.type = self.userConfig.type;\n\t\t\tself.isY = self.type == \"y\" ? true : false;\n\t\t\tself.scrollTopOrLeft = self.isY ? \"scrollTop\" : \"scrollLeft\";\n\t\t},\n\t\tdestroy: function() {\n\t\t\tvar self = this;\n\t\t\tUtil.remove(self.scrollbar);\n\t\t\tself.xscroll.off(\"scroll\", self._scrollHandler, self);\n\t\t\tself.xscroll.off(\"scrollend\", self._scrollEndHandler, self);\n\t\t},\n\t\trender: function() {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar boundry = xscroll.boundry;\n\t\t\tvar indicatorInsets = self.xscroll.userConfig.indicatorInsets;\n\t\t\tvar translateZ = xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\tvar transform = translateZ ? transformStr + \":\" + translateZ + \";\" : \"\";\n\t\t\tvar commonCss = \"opacity:0;position:absolute;z-index:999;overflow:hidden;-webkit-border-radius:3px;-moz-border-radius:3px;-o-border-radius:3px;\" + transform;\n\t\t\tindicatorInsets._xright =  indicatorInsets.right + indicatorInsets.spacing;\n\t\t\tindicatorInsets._xbottom =  indicatorInsets.bottom + indicatorInsets.spacing;\n\t\t\tvar css = self.isY ?\n\t\t\t\tUtil.substitute(\"width:{width}px;bottom:{_xbottom}px;top:{top}px;right:{right}px;\", indicatorInsets) + commonCss :\n\t\t\t\tUtil.substitute(\"height:{width}px;left:{left}px;right:{_xright}px;bottom:{bottom}px;\",indicatorInsets) + commonCss;\n\t\t\t\n\t\n\t\t\tif(!self.scrollbar){\n\t\t\t\tself.scrollbar = document.createElement(\"div\");\t\n\t\t\t\tself.indicate = document.createElement(\"div\");\n\t\t\t\txscroll.renderTo.appendChild(self.scrollbar);\n\t\t\t\tself.scrollbar.appendChild(self.indicate);\n\t\t\t}\n\t\t\tself.scrollbar.style.cssText = css;\n\t\t\tvar size = self.isY ? \"width:100%;\" : \"height:100%;\";\n\t\t\tself.indicate.style.cssText = size + \"position:absolute;background:rgba(0,0,0,0.3);-webkit-border-radius:3px;-moz-border-radius:3px;-o-border-radius:3px;\"\n\t\t\tself._update();\n\t\t\tself.hide(0);\n\t\t\tself._bindEvt();\n\t\t},\n\t\t_update: function(pos, duration, easing, callback) {\n\t\t\tvar self = this;\n\t\t\tvar pos = undefined === pos ? (self.isY ? self.xscroll.getScrollTop() : self.xscroll.getScrollLeft()) : pos;\n\t\t\tvar barInfo = self.computeScrollBar(pos);\n\t\t\tvar size = self.isY ? \"height\" : \"width\";\n\t\t\tself.indicate.style[size] = Math.round(barInfo.size) + \"px\";\n\t\t\tif (duration && easing) {\n\t\t\t\tself.scrollTo(barInfo.pos, duration, easing, callback);\n\t\t\t} else {\n\t\t\t\tself.moveTo(barInfo.pos);\n\t\t\t}\n\t\t},\n\t\t//compute the position and size of the scrollbar\n\t\tcomputeScrollBar: function(pos) {\n\t\t\tvar self = this;\n\t\t\tvar type = self.isY ? \"y\" : \"x\";\n\t\t\tvar spacing = self.userConfig.spacing;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar boundry = xscroll.boundry;\n\t\t\tvar userConfig = self.userConfig;\n\t\t\tvar pos = self.isY ? Math.round(pos) + boundry._xtop : Math.round(pos) + boundry._xleft;\n\t\t\tvar MIN_BAR_SCROLLED_SIZE = userConfig.MIN_BAR_SCROLLED_SIZE;\n\t\t\tvar MIN_BAR_SIZE = userConfig.MIN_BAR_SIZE;\n\t\t\tvar MAX_BOUNCE_DISTANCE = userConfig.MAX_BOUNCE_DISTANCE;\n\t\t\tself.containerSize = self.isY ? xscroll.containerHeight + boundry._xtop + boundry._xbottom : self.xscroll.containerWidth + boundry._xright + boundry._xleft;\n\t\t\tself.size = self.isY ? boundry.cfg.height : boundry.cfg.width;\n\t\t\tself.indicateSize = self.isY ? boundry.cfg.height - spacing * 2 : boundry.cfg.width - spacing * 2;\n\t\t\tvar indicateSize = self.indicateSize;\n\t\t\tvar containerSize = self.containerSize;\n\t\t\tvar barPos = indicateSize * pos / containerSize;\n\t\t\tvar barSize = Math.round(indicateSize * self.size / containerSize);\n\t\t\tvar overTop = self.isY ? xscroll.getBoundryOutTop() : xscroll.getBoundryOutLeft();\n\t\t\tvar overBottom = self.isY ? xscroll.getBoundryOutBottom() : xscroll.getBoundryOutRight();\n\t\t\tvar barShiftSize = MIN_BAR_SIZE - barSize > 0 ? MIN_BAR_SIZE - barSize : 0;\n\t\t\tbarSize = barSize < MIN_BAR_SIZE ? MIN_BAR_SIZE : barSize;\n\t\t\tbarPos = (indicateSize - barShiftSize) * pos / containerSize;\n\t\t\tif (overTop >= 0) {\n\t\t\t\tvar pct = overTop / MAX_BOUNCE_DISTANCE;\n\t\t\t\tpct = pct > 1 ? 1 : pct;\n\t\t\t\tbarPos = - pct * (barSize -  MIN_BAR_SCROLLED_SIZE)\n\t\t\t}\n\t\t\tif (overBottom >= 0) {\n\t\t\t\tvar pct = overBottom / MAX_BOUNCE_DISTANCE;\n\t\t\t\tpct = pct > 1 ? 1 : pct;\n\t\t\t\tbarPos = pct * (barSize - MIN_BAR_SCROLLED_SIZE) + indicateSize - barSize; \n\t\t\t}\n\t\t\tself.barPos = Math.round(barPos);\n\t\t\treturn {\n\t\t\t\tsize: Math.round(barSize),\n\t\t\t\tpos: self.barPos\n\t\t\t};\n\t\t},\n\t\tscrollTo: function(pos, duration, easing, callback) {\n\t\t\tvar self = this;\n\t\t\tself.show();\n\t\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\tvar config = {\n\t\t\t\tcss: {\n\t\t\t\t\ttransform: self.isY ? \"translateY(\" + pos + \"px)\" + translateZ : \"translateX(\" + pos + \"px)\" + translateZ\n\t\t\t\t},\n\t\t\t\tduration: duration,\n\t\t\t\teasing: easing,\n\t\t\t\tuseTransition: self.xscroll.userConfig.useTransition,\n\t\t\t\tend: callback\n\t\t\t};\n\t\t\tself.__timer = self.__timer || new Animate(self.indicate, config);\n\t\t\t//run\n\t\t\tself.__timer.stop();\n\t\t\tself.__timer.reset(config);\n\t\t\tself.__timer.run();\n\t\t},\n\t\tmoveTo: function(pos) {\n\t\t\tvar self = this;\n\t\t\tself.show();\n\t\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\tself.isY ? self.indicate.style[transform] = \"translateY(\" + pos + \"px) \" + translateZ : self.indicate.style[transform] = \"translateX(\" + pos + \"px) \" + translateZ\n\t\t\tself.indicate.style[transition] = \"\";\n\t\t},\n\t\t_scrollHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tself._update(e[self.scrollTopOrLeft]);\n\t\t\treturn self;\n\t\t},\n\t\tisBoundryOut: function() {\n\t\t\tvar self = this;\n\t\t\treturn !self.isY ? (self.xscroll.isBoundryOutLeft() || self.xscroll.isBoundryOutRight()) : (self.xscroll.isBoundryOutTop() || self.xscroll.isBoundryOutBottom());\n\t\t},\n\t\t_scrollEndHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tif (!self.isBoundryOut()) {\n\t\t\t\tself._update(e[self.scrollTopOrLeft]);\n\t\t\t\tself.hide();\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tif (self.__isEvtBind) return;\n\t\t\tself.__isEvtBind = true;\n\t\t\tself.xscroll.on(\"scroll\", self._scrollHandler, self);\n\t\t\tself.xscroll.on(\"scrollend\", self._scrollEndHandler, self);\n\t\t},\n\t\treset: function() {\n\t\t\tvar self = this;\n\t\t\tself.pos = 0;\n\t\t\tself._update();\n\t\t},\n\t\thide: function(duration, easing, delay) {\n\t\t\tvar self = this;\n\t\t\tvar duration = duration >= 0 ? duration : 300;\n\t\t\tvar easing = easing || \"ease-out\";\n\t\t\tvar delay = delay >= 0 ? delay : 100;\n\t\t\tself.scrollbar.style.opacity = 0;\n\t\t\tself.scrollbar.style[transition] = [\"opacity \", duration, \"ms \", \" ease-out \", delay, \"ms\"].join(\"\");\n\t\t},\n\t\tshow: function() {\n\t\t\tvar self = this;\n\t\t\tself.scrollbar.style.opacity = 1;\n\t\t\tself.scrollbar.style[transition] = \"\";\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = ScrollBar;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn ScrollBar;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\t//transform\n\tvar transform = Util.prefixStyle(\"transform\");\n\t// default render function for position:sticky elements\n\tvar defaultStickyRenderFunc = function(e) {\n\t  var stickyElement = e.stickyElement;\n\t  var curStickyElement = e.curStickyElement;\n\t  var xscroll = e.xscroll;\n\t  var _ = e._;\n\t  var infinite = xscroll.getPlugin(\"infinite\");\n\t  if (infinite) {\n\t    infinite.userConfig.renderHook.call(self, stickyElement, curStickyElement);\n\t    stickyElement.setAttribute(\"xs-guid\", curStickyElement.guid);\n\t    Util.addClass(stickyElement, curStickyElement.className);\n\t    for (var attrName in curStickyElement.style) {\n\t      if (attrName != \"display\" && attrName != \"position\") {\n\t        //copy styles\n\t        stickyElement.style[attrName] = attrName == _.height ? curStickyElement.style[attrName] + 'px' : curStickyElement.style[attrName];\n\t      }\n\t    }\n\t  } else {\n\t    var style = curStickyElement.getAttribute(\"style\");\n\t    stickyElement.innerHTML = curStickyElement.innerHTML;\n\t    stickyElement.className = curStickyElement.className;\n\t    style && stickyElement.setAttribute(\"style\", style);\n\t  }\n\t}\n\t\n\tvar Sticky = function(cfg) {\n\t  Sticky.superclass.constructor.call(this, cfg);\n\t  this.userConfig = Util.mix({\n\t    stickyRenderTo: undefined,\n\t    forceSticky: true,\n\t    prefix: \"xs-sticky-container\",\n\t    stickyRenderFunc: defaultStickyRenderFunc,\n\t    zoomType: \"y\"\n\t  }, cfg);\n\t  this.init();\n\t}\n\t\n\tUtil.extend(Sticky, Base, {\n\t  init: function() {\n\t    var self = this,\n\t      userConfig = self.userConfig,\n\t      xscroll = self.xscroll = userConfig.xscroll;\n\t    var isY = self.isY = !!(userConfig.zoomType == \"y\");\n\t    self._ = {\n\t      top: self.isY ? \"top\" : \"left\",\n\t      left: self.isY ? \"left\" : \"bottom\",\n\t      right: self.isY ? \"right\" : \"top\",\n\t      height: self.isY ? \"height\" : \"width\",\n\t      width: self.isY ? \"width\" : \"height\"\n\t    };\n\t    self.stickyRenderTo = Util.getNode(userConfig.stickyRenderTo);\n\t    self._handlers = [];\n\t    return self;\n\t  },\n\t  getStickiesPos: function() {\n\t    var self = this;\n\t    var xscroll = self.xscroll;\n\t    var isInfinite = self.isInfinite;\n\t    var isY = self.isY;\n\t    var _ = self._;\n\t    var stickiesPos = [];\n\t    var getPos = function(sticky) {\n\t      var pos = {};\n\t      if (isInfinite) {\n\t        pos[_.top] = isY ? sticky._top : sticky._left;\n\t        pos[_.height] = isY ? sticky._height : sticky._width;\n\t      } else {\n\t        pos[_.top] = self.isY ? Util.getOffsetTop(sticky) : Util.getOffsetLeft(sticky);\n\t        pos[_.height] = self.isY ? sticky.offsetHeight : sticky.offsetWidth;\n\t      }\n\t      return pos;\n\t    }\n\t    for (var i = 0; i < self.stickiesNum; i++) {\n\t      var pos = getPos(self.stickyElements[i]);\n\t      self._handlers[i] = self._handlers[i] || self.createStickyEl();\n\t      pos.el = self._handlers[i];\n\t      pos.isRender = false;\n\t      stickiesPos.push(pos);\n\t    }\n\t    return stickiesPos\n\t  },\n\t  getStickyElements: function() {\n\t    var self = this;\n\t    var xscroll = self.xscroll;\n\t    var userConfig = self.userConfig;\n\t    var isInfinite = self.isInfinite;\n\t    var infinite = xscroll.getPlugin(\"infinite\");\n\t    if (infinite) {\n\t      var stickyElements = [],\n\t        serializedData = infinite.__serializedData;\n\t      for (var i in serializedData) {\n\t        var rowData = serializedData[i];\n\t        if (rowData && rowData.style && \"sticky\" == rowData.style.position) {\n\t          stickyElements.push(rowData);\n\t        }\n\t      }\n\t      return stickyElements;\n\t    } else {\n\t      return Util.getNodes(xscroll.userConfig.stickyElements, xscroll.content);\n\t    }\n\t  },\n\t  render: function(force) {\n\t    var self = this;\n\t    var userConfig = self.userConfig;\n\t    var xscroll = self.xscroll;\n\t    self.isInfinite = !!xscroll.getPlugin(\"infinite\");\n\t    var _ = self._;\n\t    self.stickyElements = self.getStickyElements();\n\t    self.stickiesNum = self.stickyElements && self.stickyElements.length;\n\t    if (!self.stickiesNum) return;\n\t    if (!self.stickyRenderTo) {\n\t      self.stickyRenderTo = document.createElement('div');\n\t      xscroll.renderTo.appendChild(self.stickyRenderTo);\n\t    }\n\t    self.stickiesPos = self.getStickiesPos();\n\t    var stickyRenderTo = self.stickyRenderTo;\n\t    stickyRenderTo.style[_.top] = 0;\n\t    stickyRenderTo.style[_.left] = 0;\n\t    stickyRenderTo.style[_.right] = 0;\n\t    stickyRenderTo.style.position = xscroll.userConfig.useOriginScroll ? \"fixed\" : \"absolute\";\n\t    Util.addClass(self.stickyRenderTo, userConfig.prefix);\n\t    self.stickyHandler(force);\n\t    self._bindEvt();\n\t  },\n\t  createStickyEl: function() {\n\t    var self = this;\n\t    var el = document.createElement('div');\n\t    el.style.display = \"none\";\n\t    Util.addClass(el, \"xs-sticky-handler\");\n\t    self.stickyRenderTo.appendChild(el);\n\t    return el;\n\t  },\n\t  _bindEvt: function() {\n\t    var self = this,\n\t      xscroll = self.xscroll;\n\t    xscroll.on(\"scroll\", self.stickyHandler, self);\n\t  },\n\t  stickyHandler: function(force) {\n\t    var self = this;\n\t    var xscroll = self.xscroll;\n\t    var userConfig = self.userConfig;\n\t    var scrollTop = self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft();\n\t    var stickiesPos = self.stickiesPos;\n\t    var _ = self._;\n\t    var indexes = [];\n\t    for (var i = 0, l = stickiesPos.length; i < l; i++) {\n\t      var top = stickiesPos[i][_.top];\n\t      if (scrollTop > top) {\n\t        indexes.push(i);\n\t      }\n\t    }\n\t    if (!indexes.length) {\n\t      if (self.stickyElement) {\n\t        self.stickyElement.style.display = \"none\";\n\t      }\n\t      self.curStickyIndex = undefined;\n\t      return;\n\t    }\n\t\n\t    var curStickyIndex = Math.max.apply(null, indexes);\n\t    if (self.curStickyIndex != curStickyIndex || force) {\n\t      var prevStickyIndex = self.curStickyIndex;\n\t      self.curStickyIndex = curStickyIndex;\n\t      self.curStickyElement = self.stickyElements[curStickyIndex];\n\t      self.curStickyPos = stickiesPos[curStickyIndex];\n\t      self.stickyElement = self.curStickyPos.el;\n\t      for (var i = 0, l = stickiesPos.length; i < l; i++) {\n\t        stickiesPos[i].el.style.display = \"none\";\n\t      }\n\t      var eventsObj = {\n\t        stickyElement: self.stickyElement,\n\t        curStickyIndex: self.curStickyIndex,\n\t        prevStickyIndex: prevStickyIndex,\n\t        curStickyPos: self.curStickyPos,\n\t        isRender: self.curStickyPos.isRender\n\t      };\n\t      xscroll.trigger(\"beforestickychange\", eventsObj);\n\t      self._stickyRenderFunc(self);\n\t      xscroll.trigger(\"stickychange\", eventsObj);\n\t    }\n\t\n\t    var trans = 0;\n\t    if (self.stickiesPos[self.curStickyIndex + 1]) {\n\t      var cur = self.stickiesPos[self.curStickyIndex];\n\t      var next = self.stickiesPos[self.curStickyIndex + 1];\n\t      if (scrollTop + cur[_.height] > next[_.top] && scrollTop + cur[_.height] < next[_.top] + cur[_.height]) {\n\t        trans = cur[_.height] + scrollTop - next[_.top];\n\t      } else {\n\t        trans = 0;\n\t      }\n\t    }\n\t    self.stickyElement.style[transform] = self.isY ? \"translateY(-\" + (trans) + \"px) translateZ(0)\" : \"translateX(-\" + (trans) + \"px) translateZ(0)\";\n\t  },\n\t  _stickyRenderFunc: function(e) {\n\t    var self = this;\n\t    var _ = self._;\n\t    var stickyRenderFunc = self.userConfig.stickyRenderFunc;\n\t    var el = self.curStickyPos.el;\n\t    if (!self.curStickyPos.isRender) {\n\t      el.style[_.left] = 0;\n\t      el.style[_.right] = 0;\n\t      stickyRenderFunc && stickyRenderFunc.call(self, e);\n\t    }\n\t    el.style.display = \"block\";\n\t    self.curStickyPos.isRender = true;\n\t  },\n\t  destroy: function() {\n\t    var self = this;\n\t    self.stickyElements = undefined;\n\t    self.stickiesNum = undefined;\n\t    self.stickiesPos = undefined;\n\t    Util.remove(self.stickyElement);\n\t    self.stickyElement = undefined;\n\t  }\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t  module.exports = Sticky;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t  return Sticky;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\t// Returns a function that will be executed at most one time, no matter how\n\t// often you call it. Useful for lazy initialization.\n\tvar _once = function(func) {\n\t  var ran = false,\n\t    memo;\n\t  return function() {\n\t    if (ran) return memo;\n\t    ran = true;\n\t    memo = func.apply(this, arguments);\n\t    func = null;\n\t    return memo;\n\t  };\n\t};\n\t\n\t\n\t/**\n\t * @discription events\n\t * @mixin\n\t */\n\tvar Events = {\n\t  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n\t  // the callback to all events fired.\n\t  on: function(name, callback, context) {\n\t    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n\t    this._events || (this._events = {});\n\t    var events = this._events[name] || (this._events[name] = []);\n\t    events.push({\n\t      callback: callback,\n\t      context: context,\n\t      ctx: context || this\n\t    });\n\t    return this;\n\t  },\n\t\n\t\n\t  // Bind an event to only be triggered a single time. After the first time\n\t  // the callback is invoked, it will be removed.\n\t  once: function(name, callback, context) {\n\t    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n\t    var self = this;\n\t    var once = _once(function() {\n\t      self.off(name, once);\n\t      callback.apply(this, arguments);\n\t    });\n\t    once._callback = callback;\n\t    return this.on(name, once, context);\n\t  },\n\t\n\t  // Remove one or many callbacks. If `context` is null, removes all\n\t  // callbacks with that function. If `callback` is null, removes all\n\t  // callbacks for the event. If `name` is null, removes all bound\n\t  // callbacks for all events.\n\t  off: function(name, callback, context) {\n\t    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n\t\n\t    // Remove all callbacks for all events.\n\t    if (!name && !callback && !context) {\n\t      this._events = void 0;\n\t      return this;\n\t    }\n\t\n\t    var names = name ? [name] : Object.keys(this._events);\n\t    for (var i = 0, length = names.length; i < length; i++) {\n\t      name = names[i];\n\t\n\t      // Bail out if there are no events stored.\n\t      var events = this._events[name];\n\t      if (!events) continue;\n\t\n\t      // Remove all callbacks for this event.\n\t      if (!callback && !context) {\n\t        delete this._events[name];\n\t        continue;\n\t      }\n\t\n\t      // Find any remaining events.\n\t      var remaining = [];\n\t      for (var j = 0, k = events.length; j < k; j++) {\n\t        var event = events[j];\n\t        if (\n\t          callback && callback !== event.callback &&\n\t          callback !== event.callback._callback ||\n\t          context && context !== event.context\n\t        ) {\n\t          remaining.push(event);\n\t        }\n\t      }\n\t\n\t      // Replace events if there are any remaining.  Otherwise, clean up.\n\t      if (remaining.length) {\n\t        this._events[name] = remaining;\n\t      } else {\n\t        delete this._events[name];\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  // Trigger one or many events, firing all bound callbacks. Callbacks are\n\t  // passed the same arguments as `trigger` is, apart from the event name\n\t  // (unless you're listening on `\"all\"`, which will cause your callback to\n\t  // receive the true name of the event as the first argument).\n\t  trigger: function(name) {\n\t    if (!this._events) return this;\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    if (!eventsApi(this, 'trigger', name, args)) return this;\n\t    var events = this._events[name];\n\t    var allEvents = this._events.all;\n\t    if (events) triggerEvents(events, args);\n\t    if (allEvents) triggerEvents(allEvents, arguments);\n\t    return this;\n\t  },\n\t\n\t  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n\t  // listen to an event in another object ... keeping track of what it's\n\t  // listening to.\n\t  listenTo: function(obj, name, callback) {\n\t    var listeningTo = this._listeningTo || (this._listeningTo = {});\n\t    var id = obj._listenId || (obj._listenId = Util.guid('l'));\n\t    listeningTo[id] = obj;\n\t    if (!callback && typeof name === 'object') callback = this;\n\t    obj.on(name, callback, this);\n\t    return this;\n\t  },\n\t\n\t  listenToOnce: function(obj, name, callback) {\n\t    if (typeof name === 'object') {\n\t      for (var event in name) this.listenToOnce(obj, event, name[event]);\n\t      return this;\n\t    }\n\t    var cb = _once(function() {\n\t      this.stopListening(obj, name, cb);\n\t      callback.apply(this, arguments);\n\t    });\n\t    cb._callback = callback;\n\t    return this.listenTo(obj, name, cb);\n\t  },\n\t\n\t  // Tell this object to stop listening to either specific events ... or\n\t  // to every object it's currently listening to.\n\t  stopListening: function(obj, name, callback) {\n\t    var listeningTo = this._listeningTo;\n\t    if (!listeningTo) return this;\n\t    var remove = !name && !callback;\n\t    if (!callback && typeof name === 'object') callback = this;\n\t    if (obj)(listeningTo = {})[obj._listenId] = obj;\n\t    for (var id in listeningTo) {\n\t      obj = listeningTo[id];\n\t      obj.off(name, callback, this);\n\t      if (remove || Util.isEmpty(obj._events)) delete this._listeningTo[id];\n\t    }\n\t    return this;\n\t  }\n\t\n\t};\n\t\n\t// Regular expression used to split event strings.\n\tvar eventSplitter = /\\s+/;\n\t\n\t// Implement fancy features of the Events API such as multiple event\n\t// names `\"change blur\"` and jQuery-style event maps `{change: action}`\n\t// in terms of the existing API.\n\tvar eventsApi = function(obj, action, name, rest) {\n\t  if (!name) return true;\n\t\n\t  // Handle event maps.\n\t  if (typeof name === 'object') {\n\t    for (var key in name) {\n\t      obj[action].apply(obj, [key, name[key]].concat(rest));\n\t    }\n\t    return false;\n\t  }\n\t\n\t  // Handle space separated event names.\n\t  if (eventSplitter.test(name)) {\n\t    var names = name.split(eventSplitter);\n\t    for (var i = 0, length = names.length; i < length; i++) {\n\t      obj[action].apply(obj, [names[i]].concat(rest));\n\t    }\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t// A difficult-to-believe, but optimized internal dispatch function for\n\t// triggering events. Tries to keep the usual cases speedy (most internal\n\tvar triggerEvents = function(events, args) {\n\t  var ev, i = -1,\n\t    l = events.length,\n\t    a1 = args[0],\n\t    a2 = args[1],\n\t    a3 = args[2];\n\t  switch (args.length) {\n\t    case 0:\n\t      while (++i < l)(ev = events[i]).callback.call(ev.ctx);\n\t      return;\n\t    case 1:\n\t      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1);\n\t      return;\n\t    case 2:\n\t      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);\n\t      return;\n\t    case 3:\n\t      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\t      return;\n\t    default:\n\t      while (++i < l)(ev = events[i]).callback.apply(ev.ctx, args);\n\t      return;\n\t  }\n\t};\n\t\n\t// Aliases for backwards compatibility.\n\tEvents.bind = Events.on;\n\tEvents.unbind = Events.off;\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t  module.exports = Events;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t  return Events;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t    Base = __webpack_require__(2),\n\t    Core = __webpack_require__(7),\n\t    Animate = __webpack_require__(3);\n\t\n\tvar transformOrigin = Util.prefixStyle(\"transformOrigin\");\n\t/** \n\t * @constructor\n\t * @param {object} cfg config for scroll\n\t * @extends XScroll\n\t * @example\n\t * var xscroll = new OriginScroll({\n\t *    renderTo:\"#scroll\"\n\t * });\n\t * xscroll.render();\n\t */\n\tfunction OriginScroll(cfg) {\n\t    OriginScroll.superclass.constructor.call(this, cfg);\n\t}\n\t\n\tUtil.extend(OriginScroll, Core, {\n\t    init: function() {\n\t        var self = this;\n\t        OriginScroll.superclass.init.call(this);\n\t        self.resetSize();\n\t    },\n\t    /**\n\t     * get scroll top value\n\t     * @memberof OriginScroll\n\t     * @return {number} scrollTop\n\t     */\n\t    getScrollTop: function() {\n\t        return this.renderTo.scrollTop;\n\t    },\n\t    /**\n\t     * get scroll left value\n\t     * @memberof OriginScroll\n\t     * @return {number} scrollLeft\n\t     */\n\t    getScrollLeft: function() {\n\t        return this.renderTo.scrollLeft;\n\t    },\n\t    /**\n\t     * vertical scroll absolute to the destination\n\t     * @memberof SimuScroll\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollTop: function(y, duration, easing, callback) {\n\t        var self = this;\n\t        var y = Math.round(y);\n\t        if (self.userConfig.lockY) return;\n\t        var duration = duration || 0;\n\t        var easing = easing || \"quadratic\";\n\t        var config = {\n\t            css: {\n\t                scrollTop: y\n\t            },\n\t            duration: duration,\n\t            easing: easing,\n\t            run: function(e) {\n\t                //trigger scroll event\n\t                self.trigger(\"scroll\", {\n\t                    scrollTop: self.getScrollTop(),\n\t                    scrollLeft: self.getScrollLeft()\n\t                });\n\t            },\n\t            useTransition: false, //scrollTop \n\t            end: callback\n\t        };\n\t        self.__timers.y = self.__timers.y || new Animate(self.renderTo, config);\n\t        //run\n\t        self.__timers.y.stop();\n\t        self.__timers.y.reset(config);\n\t        self.__timers.y.run();\n\t    },\n\t    /**\n\t     * horizontal scroll absolute to the destination\n\t     * @memberof SimuScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollLeft: function(x, duration, easing, callback) {\n\t        var self = this;\n\t        var x = Math.round(x);\n\t        if (self.userConfig.lockX) return;\n\t        var duration = duration || 0;\n\t        var easing = easing || \"quadratic\";\n\t        var config = {\n\t            css: {\n\t                scrollLeft: x\n\t            },\n\t            duration: duration,\n\t            easing: easing,\n\t            run: function(e) {\n\t                //trigger scroll event\n\t                self.trigger(\"scroll\", {\n\t                    scrollTop: self.getScrollTop(),\n\t                    scrollLeft: self.getScrollLeft()\n\t                });\n\t            },\n\t            useTransition: false, //scrollTop \n\t            end: callback\n\t        };\n\t        self.__timers.x = self.__timers.x || new Animate(self.renderTo, config);\n\t        //run\n\t        self.__timers.x.stop();\n\t        self.__timers.x.reset(config);\n\t        self.__timers.x.run();\n\t    },\n\t    _bindEvt: function() {\n\t        OriginScroll.superclass._bindEvt.call(this);\n\t        var self = this;\n\t        if (self.__isEvtBind) return;\n\t        self.__isEvtBind = true;\n\t        self.renderTo.addEventListener(\"scroll\", function(e) {\n\t            self.trigger(\"scroll\", {\n\t                type: \"scroll\",\n\t                scrollTop: self.getScrollTop(),\n\t                scrollLeft: self.getScrollLeft()\n\t            })\n\t        }, false)\n\t    }\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t    module.exports = OriginScroll;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t    return OriginScroll;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t\tBase = __webpack_require__(2);\n\t\n\tvar transform = Util.prefixStyle(\"transform\");\n\tvar transition = Util.prefixStyle(\"transition\");\n\t\n\t/**\n\t * An infinity dom-recycled list plugin for xscroll.\n\t * @constructor\n\t * @param {object} cfg\n\t * @param {string} cfg.transition recomposition cell with a transition\n\t * @param {string} cfg.infiniteElements dom-selector for reused elements\n\t * @param {function} cfg.renderHook render function for cell by per col or per row duration scrolling\n\t * @extends {Base}\n\t */\n\tvar Infinite = function(cfg) {\n\t\tInfinite.superclass.constructor.call(this, cfg);\n\t\tthis.userConfig = Util.mix({\n\t\t\ttransition: 'all 0.5s ease'\n\t\t}, cfg);\n\t}\n\t\n\tUtil.extend(Infinite, Base, {\n\t\t/**\n\t\t * a pluginId\n\t\t * @memberOf Infinite\n\t\t * @type {string}\n\t\t */\n\t\tpluginId: \"infinite\",\n\t\t/**\n\t\t * store the visible elements inside of view.\n\t\t * @memberOf Infinite\n\t\t * @type {object}\n\t\t */\n\t\tvisibleElements: {},\n\t\t/**\n\t\t * store all elements data.\n\t\t * @memberOf Infinite\n\t\t * @type {object}\n\t\t */\n\t\tsections: {},\n\t\t/**\n\t\t * plugin initializer\n\t\t * @memberOf Infinite\n\t\t * @override Base\n\t\t * @return {Infinite}\n\t\t */\n\t\tpluginInitializer: function(xscroll) {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = xscroll;\n\t\t\tself.isY = !!(xscroll.userConfig.zoomType == \"y\");\n\t\t\tself._ = {\n\t\t\t\t_top:self.isY ? \"_top\" : \"_left\",\n\t\t\t\t_height:self.isY ? \"_height\" : \"_width\",\n\t\t\t\ttop:self.isY ? \"top\" : \"left\",\n\t\t\t\theight:self.isY ? \"height\" : \"width\",\n\t\t\t\twidth:self.isY ? \"width\" : \"height\",\n\t\t\t\ty:self.isY ? \"y\" : \"x\",\n\t\t\t\ttranslate:self.isY ? \"translateY\" : \"translateX\",\n\t\t\t\tcontainerHeight:self.isY ? \"containerHeight\" : \"containerWidth\",\n\t\t\t\tscrollTop:self.isY ? \"scrollTop\" : \"scrollLeft\",\n\t\t\t}\n\t\t\tself._initInfinite();\n\t\t\txscroll.on(\"afterrender\", function() {\n\t\t\t\tself.render();\n\t\t\t\tself._bindEvt();\n\t\t\t});\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * detroy the plugin\n\t\t * @memberOf Infinite\n\t\t * @override Base\n\t\t * @return {Infinite}\n\t\t */\n\t\tpluginDestructor: function() {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\tself.infiniteElements[i].style[_.top] = \"auto\";\n\t\t\t\tself.infiniteElements[i].style[transform] = \"none\";\n\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t}\n\t\t\tself.xscroll && self.xscroll.off(\"scroll\", self._updateByScroll, self);\n\t\t\tself.xscroll && self.xscroll.off(\"tap panstart pan panend\", self._cellEventsHandler, self);\n\t\t\treturn self;\n\t\t},\n\t\t_initInfinite: function() {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar _ = self._;\n\t\t\tself.sections = {};\n\t\t\tself.infiniteElements = xscroll.renderTo.querySelectorAll(self.userConfig.infiniteElements);\n\t\t\tself.infiniteLength = self.infiniteElements.length;\n\t\t\tself.infiniteElementsCache = (function() {\n\t\t\t\tvar tmp = []\n\t\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\t\ttmp.push({});\n\t\t\t\t\tself.infiniteElements[i].style.position = \"absolute\";\n\t\t\t\t\tself.infiniteElements[i].style[_.top] = 0;\n\t\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t\t\tself.infiniteElements[i].style.display = \"block\";\n\t\t\t\t\tUtil.addClass(self.infiniteElements[i], \"_xs_infinite_elements_\");\n\t\t\t\t}\n\t\t\t\treturn tmp;\n\t\t\t})();\n\t\t\tself.elementsPos = {};\n\t\t\treturn self;\n\t\t},\n\t\t_renderUnRecycledEl: function() {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tvar translateZ = self.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\tfor (var i in self.__serializedData) {\n\t\t\t\tvar unrecycledEl = self.__serializedData[i];\n\t\t\t\tif (self.__serializedData[i]['recycled'] === false) {\n\t\t\t\t\tvar el = unrecycledEl.id && document.getElementById(unrecycledEl.id.replace(\"#\", \"\")) || document.createElement(\"div\");\n\t\t\t\t\tvar randomId = Util.guid(\"xs-row-\");\n\t\t\t\t\tel.id = unrecycledEl.id || randomId;\n\t\t\t\t\tunrecycledEl.id = el.id;\n\t\t\t\t\tself.xscroll.content.appendChild(el);\n\t\t\t\t\tfor (var attrName in unrecycledEl.style) {\n\t\t\t\t\t\tif (attrName != _.height && attrName != \"display\" && attrName != \"position\") {\n\t\t\t\t\t\t\tel.style[attrName] = unrecycledEl.style[attrName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tel.style[_.top] = 0;\n\t\t\t\t\tel.style.position = \"absolute\";\n\t\t\t\t\tel.style.display = \"block\";\n\t\t\t\t\tel.style[_.height] = unrecycledEl[_._height] + \"px\";\n\t\t\t\t\tel.style[transform] = _.translate + \"(\" + unrecycledEl[_._top] + \"px) \" + translateZ;\n\t\t\t\t\tUtil.addClass(el, unrecycledEl.className);\n\t\t\t\t\tself.userConfig.renderHook.call(self, el, unrecycledEl);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * render or update the scroll contents\n\t\t * @memberOf Infinite\n\t\t * @return {Infinite}\n\t\t */\n\t\trender: function() {\n\t\t\tvar self = this;\n\t\t\tvar _  = self._;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar offset = self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft();\n\t\t\tself.visibleElements = self.getVisibleElements(offset);\n\t\t\tself.__serializedData = self._computeDomPositions();\n\t\t\txscroll.sticky && xscroll.sticky.render(true); //force render\n\t\t\txscroll.fixed && xscroll.fixed.render();\n\t\t\tvar size = xscroll[_.height];\n\t\t\tvar containerSize = self._containerSize;\n\t\t\tif (containerSize < size) {\n\t\t\t\tcontainerSize = size;\n\t\t\t}\n\t\t\txscroll[_.containerHeight] = containerSize;\n\t\t\txscroll.container.style[_.height] = containerSize + \"px\";\n\t\t\txscroll.content.style[_.height] = containerSize + \"px\";\n\t\t\tself._renderUnRecycledEl();\n\t\t\tself._updateByScroll();\n\t\t\tself._updateByRender(offset);\n\t\t\tself.xscroll.boundryCheck();\n\t\t\treturn self;\n\t\t},\n\t\t_getChangedRows: function(newElementsPos) {\n\t\t\tvar self = this;\n\t\t\tvar changedRows = {};\n\t\t\tfor (var i in self.elementsPos) {\n\t\t\t\tif (!newElementsPos.hasOwnProperty(i)) {\n\t\t\t\t\tchangedRows[i] = \"delete\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in newElementsPos) {\n\t\t\t\tif (newElementsPos[i].recycled && !self.elementsPos.hasOwnProperty(i)) {\n\t\t\t\t\tchangedRows[i] = \"add\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.elementsPos = newElementsPos;\n\t\t\treturn changedRows;\n\t\t},\n\t\t_updateByScroll: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar _ = self._;\n\t\t\tvar _pos = e && e[_.scrollTop];\n\t\t\tvar pos = _pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : _pos;\n\t\t\tvar elementsPos = self.getVisibleElements(pos);\n\t\t\tvar changedRows = self.changedRows = self._getChangedRows(elementsPos);\n\t\t\ttry{\n\t\t\t\tfor (var i in changedRows) {\n\t\t\t\t\tif (changedRows[i] == \"delete\") {\n\t\t\t\t\t\tself._pushEl(i);\n\t\t\t\t\t}\n\t\t\t\t\tif (changedRows[i] == \"add\") {\n\t\t\t\t\t\tvar elObj = self._popEl(elementsPos[i][self.guid]);\n\t\t\t\t\t\tvar index = elObj.index;\n\t\t\t\t\t\tvar el = elObj.el;\n\t\t\t\t\t\tif (el) {\n\t\t\t\t\t\t\tself.infiniteElementsCache[index].guid = elementsPos[i].guid;\n\t\t\t\t\t\t\tself.__serializedData[elementsPos[i].guid].__infiniteIndex = index;\n\t\t\t\t\t\t\tself._renderData(el, elementsPos[i]);\n\t\t\t\t\t\t\tself._renderStyle(el, elementsPos[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}catch(e){\n\t\t\t\tconsole.warn('Not enough infiniteElements setted!');\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_updateByRender: function(pos) {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar pos = pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : pos;\n\t\t\tvar prevElementsPos = self.visibleElements;\n\t\t\tvar newElementsPos = self.getVisibleElements(pos);\n\t\t\tvar prevEl, newEl;\n\t\t\t//repaint\n\t\t\tfor (var i in newElementsPos) {\n\t\t\t\tnewEl = newElementsPos[i];\n\t\t\t\tfor (var j in prevElementsPos) {\n\t\t\t\t\tprevEl = prevElementsPos[j];\n\t\t\t\t\tif (prevEl.guid === newEl.guid) {\n\t\t\t\t\t\tif (newEl.style != prevEl.style || newEl[_._top] != prevEl[_._top] || newEl[_._height] != prevEl[_._height]) {\n\t\t\t\t\t\t\tself._renderStyle(self.infiniteElements[newEl.__infiniteIndex], newEl, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (JSON.stringify(newEl.data) != JSON.stringify(prevEl.data)) {\n\t\t\t\t\t\t\tself._renderData(self.infiniteElements[newEl.__infiniteIndex], newEl);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// paint\n\t\t\t\t\t\tif (self.__serializedData[newEl.guid].recycled && self.__serializedData[newEl.guid].__infiniteIndex === undefined) {\n\t\t\t\t\t\t\tvar elObj = self._popEl();\n\t\t\t\t\t\t\tself.__serializedData[newEl.guid].__infiniteIndex = elObj.index;\n\t\t\t\t\t\t\tself._renderData(elObj.el, newEl);\n\t\t\t\t\t\t\tself._renderStyle(elObj.el, newEl);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.visibleElements = newElementsPos;\n\t\t},\n\t\t/**\n\t\t * get all element posInfo such as top,height,template,html\n\t\t * @return {Array}\n\t\t **/\n\t\t_computeDomPositions: function() {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tvar pos = 0,\n\t\t\t\tsize = 0,\n\t\t\t\tsections = self.sections,\n\t\t\t\tsection;\n\t\t\tvar data = [];\n\t\t\tvar serializedData = {};\n\t\t\tfor (var i in sections) {\n\t\t\t\tfor (var j = 0, len = sections[i].length; j < len; j++) {\n\t\t\t\t\tsection = sections[i][j];\n\t\t\t\t\tsection.sectionId = i;\n\t\t\t\t\tsection.index = j;\n\t\t\t\t\tdata.push(section);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t//f = v/itemSize*1000 < 60 => v = 0.06 * itemSize\n\t\t\tself.userConfig.maxSpeed = 0.06 * 50;\n\t\t\tfor (var i = 0, l = data.length; i < l; i++) {\n\t\t\t\tvar item = data[i];\n\t\t\t\tsize = item.style && item.style[_.height] >= 0 && item.style.position != \"fixed\" ? item.style[_.height] : 0;\n\t\t\t\titem.guid = item.guid || Util.guid();\n\t\t\t\titem[_._top] = pos;\n\t\t\t\titem[_._height] = size;\n\t\t\t\titem.recycled = item.recycled === false ? false : true;\n\t\t\t\tpos += size;\n\t\t\t\tserializedData[item.guid] = item;\n\t\t\t}\n\t\t\tself._containerSize = pos;\n\t\t\treturn serializedData;\n\t\t},\n\t\t/**\n\t\t * get all elements inside of the view.\n\t\t * @memberOf Infinite\n\t\t * @param {number} pos scrollLeft or scrollTop\n\t\t * @return {object} visibleElements\n\t\t */\n\t\tgetVisibleElements: function(pos) {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar _ = self._;\n\t\t\tvar pos = pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : pos;\n\t\t\tvar threshold = self.userConfig.threshold >= 0 ? self.userConfig.threshold : xscroll[_.height] / 3;\n\t\t\tvar tmp = {},\n\t\t\t\titem;\n\t\t\tvar data = self.__serializedData;\n\t\t\tfor (var i in data) {\n\t\t\t\titem = data[i];\n\t\t\t\tif (item[_._top] >= pos - threshold && item[_._top] <= pos + xscroll[_.height] + threshold) {\n\t\t\t\t\ttmp[item.guid] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn JSON.parse(JSON.stringify(tmp));\n\t\t},\n\t\t_popEl: function() {\n\t\t\tvar self = this;\n\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\tif (!self.infiniteElementsCache[i]._visible) {\n\t\t\t\t\tself.infiniteElementsCache[i]._visible = true;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tel: self.infiniteElements[i]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_pushEl: function(guid) {\n\t\t\tvar self = this;\n\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\tif (self.infiniteElementsCache[i].guid == guid) {\n\t\t\t\t\tself.infiniteElementsCache[i]._visible = false;\n\t\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t\t\tself.infiniteElementsCache[i].guid = null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_renderData: function(el, elementObj) {\n\t\t\tvar self = this;\n\t\t\tif (!el || !elementObj || elementObj.style.position == \"fixed\") return;\n\t\t\tself.userConfig.renderHook.call(self, el, elementObj);\n\t\t},\n\t\t_renderStyle: function(el, elementObj, useTransition) {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tif (!el) return;\n\t\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\t//update style\n\t\t\tfor (var attrName in elementObj.style) {\n\t\t\t\tif (attrName != _.height && attrName != \"display\" && attrName != \"position\") {\n\t\t\t\t\tel.style[attrName] = elementObj.style[attrName];\n\t\t\t\t}\n\t\t\t}\n\t\t\tel.setAttribute(\"xs-index\", elementObj.index);\n\t\t\tel.setAttribute(\"xs-sectionid\", elementObj.sectionId);\n\t\t\tel.setAttribute(\"xs-guid\", elementObj.guid);\n\t\t\tel.style.visibility = \"visible\";\n\t\t\tel.style[_.height] = elementObj[_._height] + \"px\";\n\t\t\tel.style[transform] = _.translate + \"(\" + elementObj[_._top] + \"px) \" + translateZ;\n\t\t\tel.style[transition] = useTransition ? self.userConfig.transition : \"none\";\n\t\t},\n\t\tgetCell: function(e) {\n\t\t\tvar self = this,\n\t\t\t\tcell;\n\t\t\tvar el = Util.findParentEl(e.target, \"._xs_infinite_elements_\", self.xscroll.renderTo);\n\t\t\tif(!el){\n\t\t\t\tel = Util.findParentEl(e.target, \".xs-sticky-handler\", self.xscroll.renderTo);\n\t\t\t}\n\t\t\tvar guid = el && el.getAttribute(\"xs-guid\");\n\t\t\tif (undefined === guid) return;\n\t\t\treturn {\n\t\t\t\tdata:self.__serializedData[guid],\n\t\t\t\tel:el\n\t\t\t};\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tif (self._isEvtBinded) return;\n\t\t\tself._isEvtBinded = true;\n\t\t\tself.xscroll.renderTo.addEventListener(\"webkitTransitionEnd\", function(e) {\n\t\t\t\tif (e.target.className.match(/xs-row/)) {\n\t\t\t\t\te.target.style.webkitTransition = \"\";\n\t\t\t\t}\n\t\t\t});\n\t\t\tself.xscroll.on(\"scroll\", self._updateByScroll, self);\n\t\t\tself.xscroll.on(\"tap panstart pan panend\", self._cellEventsHandler, self);\n\t\t\treturn self;\n\t\t},\n\t\t_cellEventsHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar cell = self.getCell(e);\n\t\t\te.cell = cell.data;\n\t\t\te.cellEl = cell.el;\n\t\t\te.cell && self[e.type].call(self, e);\n\t\t},\n\t\t/**\n\t\t * tap event\n\t\t * @memberOf Infinite\n\t\t * @param {object} e events data include cell object\n\t\t * @event\n\t\t */\n\t\ttap: function(e) {\n\t\t\tthis.trigger(\"tap\", e);\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * panstart event\n\t\t * @memberOf Infinite\n\t\t * @param {object} e events data include cell object\n\t\t * @event\n\t\t */\n\t\tpanstart: function(e) {\n\t\t\tthis.trigger(\"panstart\", e);\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * pan event\n\t\t * @memberOf Infinite\n\t\t * @param {object} e events data include cell object\n\t\t * @event\n\t\t */\n\t\tpan: function(e) {\n\t\t\tthis.trigger(\"pan\", e);\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * panend event\n\t\t * @memberOf Infinite\n\t\t * @param {object} e events data include cell object\n\t\t * @event\n\t\t */\n\t\tpanend: function(e) {\n\t\t\tthis.trigger(\"panend\", e);\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * insert data before a position\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId of the target cell\n\t\t * @param {number} index index of the target cell\n\t\t * @param {object} data data to insert\n\t\t * @return {Infinite}\n\t\t */\n\t\tinsertBefore: function(sectionId, index, data) {\n\t\t\tvar self = this;\n\t\t\tif (sectionId === undefined || index === undefined || data === undefined) return self;\n\t\t\tif (!self.sections[sectionId]) {\n\t\t\t\tself.sections[sectionId] = [];\n\t\t\t}\n\t\t\tself.sections[sectionId].splice(index, 0, data);\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * insert data after a position\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId of the target cell\n\t\t * @param {number} index index of the target cell\n\t\t * @param {object} data data to insert\n\t\t * @return {Infinite}\n\t\t */\n\t\tinsertAfter: function(sectionId, index, data) {\n\t\t\tvar self = this;\n\t\t\tif (sectionId === undefined || index === undefined || data === undefined) return self;\n\t\t\tif (!self.sections[sectionId]) {\n\t\t\t\tself.sections[sectionId] = [];\n\t\t\t}\n\t\t\tself.sections[sectionId].splice(Number(index) + 1, 0, data);\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * append data after a section\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId for the append cell\n\t\t * @param {object} data data to append\n\t\t * @return {Infinite}\n\t\t */\n\t\tappend: function(sectionId, data) {\n\t\t\tvar self = this;\n\t\t\tif (!self.sections[sectionId]) {\n\t\t\t\tself.sections[sectionId] = [];\n\t\t\t}\n\t\t\tself.sections[sectionId] = self.sections[sectionId].concat(data);\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * remove some data by sectionId,from,number\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId for the append cell\n\t\t * @param {number} from removed index from\n\t\t * @param {number} number removed data number\n\t\t * @return {Infinite}\n\t\t */\n\t\tremove: function(sectionId, from, number) {\n\t\t\tvar self = this;\n\t\t\tvar number = number || 1;\n\t\t\tif (undefined === sectionId || !self.sections[sectionId]) return self;\n\t\t\t//remove a section\n\t\t\tif (undefined === from) {\n\t\t\t\tself.sections[sectionId] = null;\n\t\t\t\treturn self;\n\t\t\t}\n\t\t\t//remove some data in section\n\t\t\tif (self.sections[sectionId] && self.sections[sectionId][from]) {\n\t\t\t\tself.sections[sectionId].splice(from, number);\n\t\t\t\treturn self;\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * replace some data by sectionId and index\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId to replace\n\t\t * @param {number} index removed index from\n\t\t * @param {object} data new data to replace\n\t\t * @return {Infinite}\n\t\t */\n\t\treplace: function(sectionId, index, data) {\n\t\t\tvar self = this;\n\t\t\tif (undefined === sectionId || !self.sections[sectionId]) return self;\n\t\t\tself.sections[sectionId][index] = data;\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * get data by sectionId and index\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId\n\t\t * @param {number} index index in the section\n\t\t * @return {object} data data\n\t\t */\n\t\tget: function(sectionId, index) {\n\t\t\tif (undefined === sectionId) return;\n\t\t\tif (undefined === index) return this.sections[sectionId];\n\t\t\treturn this.sections[sectionId][index];\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Infinite;\n\t}\n\t/** ignored by jsdoc **/\n\telse if (window.XScroll && window.XScroll.Plugins) {\n\t\treturn XScroll.Plugins.Infinite = Infinite;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\tvar clsPrefix;\n\tvar containerCls;\n\tvar content = \"Pull Down To Refresh\";\n\tvar loadingContent = \"Loading...\";\n\t/**\n\t * A pulldown to refresh plugin for xscroll.\n\t * @constructor\n\t * @param {object} cfg\n\t * @param {number} cfg.height\n\t * @param {string} cfg.content default html for pulldown\n\t * @param {string} cfg.downContent html for pulldown when scrollTop is smaller than cfg.height\n\t * @param {string} cfg.upContent html for pulldown when scrollTop is larger than cfg.height\n\t * @param {string} cfg.loadingContent html for pulldown when released\n\t * @param {string} cfg.clsPrefix  class prefix which default value is \"xs-plugin-pulldown-\"\n\t * @extends {Base}\n\t */\n\tvar PullDown = function(cfg) {\n\t\tPullDown.superclass.constructor.call(this, cfg);\n\t\tthis.userConfig = Util.mix({\n\t\t\tcontent: content,\n\t\t\theight: 60,\n\t\t\tautoRefresh: true,\n\t\t\tdownContent: \"Pull Down To Refresh\",\n\t\t\tupContent: \"Release To Refresh\",\n\t\t\tloadingContent: loadingContent,\n\t\t\tclsPrefix: \"xs-plugin-pulldown-\"\n\t\t}, cfg);\n\t}\n\tUtil.extend(PullDown, Base, {\n\t\t/**\n\t\t * a pluginId\n\t\t * @memberOf PullDown\n\t\t * @type {string}\n\t\t */\n\t\tpluginId: \"pulldown\",\n\t\t/**\n\t\t * plugin initializer\n\t\t * @memberOf PullDown\n\t\t * @override Base\n\t\t * @return {PullDown}\n\t\t */\n\t\tpluginInitializer: function(xscroll) {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = xscroll.render();\n\t\t\tclsPrefix = self.userConfig.clsPrefix;\n\t\t\tself.render();\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * detroy the plugin\n\t\t * @memberOf PullDown\n\t\t * @override Base\n\t\t * @return {PullDown}\n\t\t */\n\t\tpluginDestructor: function() {\n\t\t\tvar self = this;\n\t\t\tUtil.remove(self.pulldown);\n\t\t\tself.xscroll.off(\"panstart\", self._panStartHandler, self);\n\t\t\tself.xscroll.off(\"pan\", self._panHandler, self);\n\t\t\tself.xscroll.off(\"panend\", self._panEndHandler, self);\n\t\t\tself.__isRender = false;\n\t\t\tself._evtBinded = false;\n\t\t},\n\t\t/**\n\t\t * render pulldown plugin\n\t\t * @memberOf PullDown\n\t\t * @return {PullDown}\n\t\t */\n\t\trender: function() {\n\t\t\tvar self = this;\n\t\t\tif (self.__isRender) return;\n\t\t\tself.__isRender = true;\n\t\t\tvar containerCls = clsPrefix + \"container\";\n\t\t\tvar height = self.userConfig.height || 60;\n\t\t\tvar pulldown = self.pulldown = document.createElement(\"div\");\n\t\t\tpulldown.className = containerCls;\n\t\t\tpulldown.style.position = \"absolute\";\n\t\t\tpulldown.style.width = \"100%\";\n\t\t\tpulldown.style.height = height + \"px\";\n\t\t\tpulldown.style.lineHeight = height + \"px\";\n\t\t\tpulldown.style.top = -height + \"px\";\n\t\t\tpulldown.style.textAlign = \"center\";\n\t\t\tself.xscroll.container.appendChild(pulldown);\n\t\t\tself.status = 'up';\n\t\t\tUtil.addClass(pulldown, clsPrefix + self.status);\n\t\t\tpulldown.innerHTML = self.userConfig[self.status + \"Content\"] || self.userConfig.content;\n\t\t\tself._bindEvt();\n\t\t\treturn self;\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tif (self._evtBinded) return;\n\t\t\tself._evtBinded = true;\n\t\t\tvar pulldown = self.pulldown;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\txscroll.on(\"pan\", self._panHandler, self);\n\t\t\txscroll.on(\"panstart\", self._panStartHandler, self);\n\t\t\txscroll.on(\"panend\", self._panEndHandler, self);\n\t\t},\n\t\t_changeStatus: function(status) {\n\t\t\tvar prevVal = this.status;\n\t\t\tthis.status = status;\n\t\t\tUtil.removeClass(this.pulldown, clsPrefix + prevVal)\n\t\t\tUtil.addClass(this.pulldown, clsPrefix + status);\n\t\t\tif (this.userConfig[status + \"Content\"]) {\n\t\t\t\tthis.pulldown.innerHTML = this.userConfig[status + \"Content\"];\n\t\t\t}\n\t\t\tif (prevVal != status) {\n\t\t\t\tthis.trigger(\"statuschange\", {\n\t\t\t\t\tprevVal: prevVal,\n\t\t\t\t\tnewVal: status\n\t\t\t\t});\n\t\t\t\tif (status == \"loading\") {\n\t\t\t\t\tthis.trigger(\"loading\");\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * reset the pulldown plugin\n\t\t * @memberOf PullDown\n\t\t * @param {function} callback\n\t\t * @return {PullDown}\n\t\t */\n\t\treset: function(callback) {\n\t\t\tthis.xscroll.boundry.resetTop()\n\t\t\tthis.xscroll.boundryCheckY(callback);\n\t\t\tthis._expanded = false;\n\t\t\treturn this;\n\t\t},\n\t\t_panStartHandler: function(e) {\n\t\t\tclearTimeout(this.loadingItv);\n\t\t},\n\t\t_panHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar scrollTop = self.xscroll.getScrollTop();\n\t\t\tif (scrollTop > 0) return;\n\t\t\tself._changeStatus(Math.abs(scrollTop) < self.userConfig.height ? \"down\" : \"up\");\n\t\t},\n\t\t_panEndHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar height = self.userConfig.height || 60;\n\t\t\tvar scrollTop = xscroll.getScrollTop();\n\t\t\tif (scrollTop < -height) {\n\t\t\t\t//prevent default bounce\n\t\t\t\te.preventDefault();\n\t\t\t\txscroll.boundry.resetTop();\n\t\t\t\txscroll.boundry.expandTop(height);\n\t\t\t\txscroll.boundryCheckY(function() {\n\t\t\t\t\tself._changeStatus(\"loading\");\n\t\t\t\t});\n\t\t\t\tif (self.userConfig.autoRefresh) {\n\t\t\t\t\tclearTimeout(self.loadingItv);\n\t\t\t\t\tself.loadingItv = setTimeout(function() {\n\t\t\t\t\t\txscroll.boundry.resetTop();\n\t\t\t\t\t\txscroll.boundryCheckY(function() {\n\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t})\n\t\t\t\t\t}, 800);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = PullDown;\n\t}\n\t/** ignored by jsdoc **/\n\telse if (window.XScroll && window.XScroll.Plugins) {\n\t\treturn XScroll.Plugins.PullDown = PullDown;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\tvar clsPrefix;\n\tvar containerCls;\n\tvar loadingContent = \"Loading...\";\n\tvar upContent = \"Pull Up To Refresh\";\n\tvar downContent = \"Release To Refresh\";\n\tvar PULL_UP_HEIGHT = 60;\n\tvar HEIGHT = 40;\n\t/**\n\t * A pullup to load plugin for xscroll.\n\t * @constructor\n\t * @param {object} cfg\n\t * @param {number} cfg.height\n\t * @param {string} cfg.downContent\n\t * @param {string} cfg.upContent\n\t * @param {string} cfg.loadingContent\n\t * @param {string} cfg.clsPrefix  class prefix which default value is \"xs-plugin-pullup-\"\n\t * @param {number} cfg.bufferHeight preload data before scrolling to the bottom of the boundry\n\t * @extends {Base}\n\t */\n\tvar PullUp = function(cfg) {\n\t\tPullUp.superclass.constructor.call(this);\n\t\tthis.userConfig = Util.mix({\n\t\t\tupContent: upContent,\n\t\t\tdownContent: downContent,\n\t\t\tpullUpHeight: PULL_UP_HEIGHT,\n\t\t\theight: HEIGHT,\n\t\t\tloadingContent: loadingContent,\n\t\t\tbufferHeight: 0,\n\t\t\tclsPrefix: \"xs-plugin-pullup-\"\n\t\t}, cfg);\n\t}\n\tUtil.extend(PullUp, Base, {\n\t\t/**\n\t\t * a pluginId\n\t\t * @memberOf PullUp\n\t\t * @type {string}\n\t\t */\n\t\tpluginId: \"pullup\",\n\t\t/**\n\t\t * plugin initializer\n\t\t * @memberOf PullUp\n\t\t * @override Base\n\t\t * @return {PullUp}\n\t\t */\n\t\tpluginInitializer: function(xscroll) {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = xscroll.render();\n\t\t\tclsPrefix = self.userConfig.clsPrefix;\n\t\t\tself.render();\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * detroy the plugin\n\t\t * @memberOf PullUp\n\t\t * @override Base\n\t\t * @return {PullUp}\n\t\t */\n\t\tpluginDestructor: function() {\n\t\t\tvar self = this;\n\t\t\tUtil.remove(self.pullup);\t\t\n\t\t\tself.xscroll.off(\"scrollend\", self._scrollEndHandler, self);\n\t\t\tself.xscroll.off(\"scroll\", self._scrollHandler, self);\n\t\t\tself.xscroll.off(\"pan\", self._panHandler, self);\n\t\t\tself.xscroll.boundry.resetBottom();\n\t\t\tself.__isRender = false;\n\t\t\tself._evtBinded = false;\n\t\t},\n\t\t/**\n\t\t * render pullup plugin\n\t\t * @memberOf PullUp\n\t\t * @return {PullUp}\n\t\t */\n\t\trender: function() {\n\t\t\tvar self = this;\n\t\t\tif (self.__isRender) return;\n\t\t\tself.__isRender = true;\n\t\t\tvar containerCls = clsPrefix + \"container\";\n\t\t\tvar height = self.userConfig.height;\n\t\t\tvar pullup = self.pullup = document.createElement(\"div\");\n\t\t\tpullup.className = containerCls;\n\t\t\tpullup.style.position = \"absolute\";\n\t\t\tpullup.style.width = \"100%\";\n\t\t\tpullup.style.height = height + \"px\";\n\t\t\tpullup.style.bottom = -height + \"px\";\n\t\t\tself.xscroll.container.appendChild(pullup);\n\t\t\tself.xscroll.boundry.expandBottom(self.userConfig.height);\n\t\t\tself.status = 'up';\n\t\t\tUtil.addClass(pullup, clsPrefix + self.status);\n\t\t\tpullup.innerHTML = self.userConfig[self.status + \"Content\"] || self.userConfig.content;\n\t\t\tself._bindEvt();\n\t\t\treturn self;\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tif (self._evtBinded) return;\n\t\t\tself._evtBinded = true;\n\t\t\tvar pullup = self.pullup;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\txscroll.on(\"pan\", self._panHandler, self);\n\t\t\t//load width a buffer\n\t\t\tif (self.userConfig.bufferHeight > 0) {\n\t\t\t\txscroll.on(\"scroll\", self._scrollHandler, self);\n\t\t\t}\n\t\t\t//bounce bottom\n\t\t\txscroll.on(\"scrollend\", self._scrollEndHandler, self);\n\t\t\treturn self;\n\t\t},\n\t\t_scrollEndHandler: function(e) {\n\t\t\tvar self = this,\n\t\t\t\txscroll = self.xscroll,\n\t\t\t\tscrollTop = xscroll.getScrollTop();\n\t\t\tif (scrollTop == xscroll.containerHeight - xscroll.height + self.userConfig.height) {\n\t\t\t\tself._changeStatus(\"loading\");\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_scrollHandler: function(e) {\n\t\t\tvar self = this,\n\t\t\t\txscroll = self.xscroll;\n\t\t\tif (!self.isLoading && Math.abs(e.scrollTop) + xscroll.height + self.userConfig.height + self.userConfig.bufferHeight >= xscroll.containerHeight + xscroll.boundry._xtop + xscroll.boundry._xbottom) {\n\t\t\t\tself._changeStatus(\"loading\");\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_panHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar offsetTop = -xscroll.getScrollTop();\n\t\t\tif (offsetTop < xscroll.height - xscroll.containerHeight - self.userConfig.pullUpHeight) {\n\t\t\t\tself._changeStatus(\"down\")\n\t\t\t} else {\n\t\t\t\tself._changeStatus(\"up\");\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_changeStatus: function(status) {\n\t\t\tif (status != \"loading\" && this.isLoading) return;\n\t\t\tvar prevVal = this.status;\n\t\t\tthis.status = status;\n\t\t\tUtil.removeClass(this.pullup, clsPrefix + prevVal)\n\t\t\tUtil.addClass(this.pullup, clsPrefix + status);\n\t\t\tthis.pullup.innerHTML = this.userConfig[status + \"Content\"];\n\t\t\tif (prevVal != status) {\n\t\t\t\tthis.trigger(\"statuschange\", {\n\t\t\t\t\tprevVal: prevVal,\n\t\t\t\t\tnewVal: status\n\t\t\t\t});\n\t\t\t\tif (status == \"loading\") {\n\t\t\t\t\tthis.isLoading = true;\n\t\t\t\t\tthis.trigger(\"loading\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * notify pullup plugin to complete state after a remote data request\n\t\t * @memberOf PullUp\n\t\t * @return {PullUp}\n\t\t */\n\t\tcomplete: function() {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tself.isLoading = false;\n\t\t\tself._changeStatus(\"up\");\n\t\t\treturn self;\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = PullUp;\n\t}\n\t/** ignored by jsdoc **/\n\telse if (window.XScroll && window.XScroll.Plugins) {\n\t\treturn XScroll.Plugins.PullUp = PullUp;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t  Base = __webpack_require__(2),\n\t  Core = __webpack_require__(7),\n\t  Animate = __webpack_require__(3),\n\t  Hammer = __webpack_require__(6),\n\t  ScrollBar = __webpack_require__(20),\n\t  Controller = __webpack_require__(18);\n\t//reduced boundry pan distance\n\tvar PAN_RATE = 1 - 0.618;\n\t//constant for scrolling acceleration\n\tvar SCROLL_ACCELERATION = 0.0005;\n\t//constant for outside of boundry acceleration\n\tvar BOUNDRY_ACCELERATION = 0.03;\n\t//transform-origin\n\tvar transformOrigin = Util.prefixStyle(\"transformOrigin\");\n\t//transform\n\tvar transform = Util.prefixStyle(\"transform\");\n\t/** \n\t * @constructor\n\t * @param {object} cfg config for scroll\n\t * @param {number} cfg.SCROLL_ACCELERATION  acceleration for scroll, min value make the scrolling smoothly\n\t * @param {number} cfg.BOUNDRY_CHECK_DURATION duration for boundry bounce\n\t * @param {number} cfg.BOUNDRY_CHECK_EASING easing for boundry bounce\n\t * @param {number} cfg.BOUNDRY_CHECK_ACCELERATION acceleration for boundry bounce\n\t * @param {boolean} cfg.lockX just like overflow-x:hidden\n\t * @param {boolean} cfg.lockY just like overflow-y:hidden\n\t * @param {boolean} cfg.scrollbarX config if the scrollbar-x is visible\n\t * @param {boolean} cfg.scrollbarY config if the scrollbar-y is visible\n\t * @param {boolean} cfg.useTransition config if use css3 transition or raf for scroll animation\n\t * @param {boolean} cfg.bounce config if use has the bounce effect when scrolling outside of the boundry\n\t * @param {boolean} cfg.boundryCheck config if scrolling inside of the boundry\n\t * @param {boolean} cfg.preventDefault prevent touchstart\n\t * @param {boolean} cfg.preventTouchMove prevent touchmove\n\t * @param {string|HTMLElement}  cfg.container config for scroller's container which default value is \".xs-container\"\n\t * @param {string|HTMLElement}  cfg.content config for scroller's content which default value is \".xs-content\"\n\t * @param {object}  cfg.indicatorInsets  config scrollbars position {top: number, left: number, bottom: number, right: number}\n\t * @param {string}  cfg.stickyElements config for sticky-positioned elements\n\t * @param {string}  cfg.fixedElements config for fixed-positioned elements\n\t * @param {string}  cfg.touchAction config for touchAction of the scroller\n\t * @extends XScroll\n\t * @example\n\t * var xscroll = new SimuScroll({\n\t *    renderTo:\"#scroll\",\n\t *    lockX:false,\n\t *    scrollbarX:true\n\t * });\n\t * xscroll.render();\n\t */\n\tfunction SimuScroll(cfg) {\n\t  SimuScroll.superclass.constructor.call(this, cfg);\n\t}\n\t\n\tUtil.extend(SimuScroll, Core, {\n\t  /** \n\t   * @memberof SimuScroll\n\t   * @override\n\t   */\n\t  init: function() {\n\t    var self = this;\n\t    var defaultCfg = {\n\t      preventDefault: true,\n\t      preventTouchMove: true\n\t    };\n\t    SimuScroll.superclass.init.call(this);\n\t    self.userConfig = Util.mix(defaultCfg, self.userConfig);\n\t    self.SCROLL_ACCELERATION = self.userConfig.SCROLL_ACCELERATION || SCROLL_ACCELERATION;\n\t    self.BOUNDRY_ACCELERATION = self.userConfig.BOUNDRY_ACCELERATION || BOUNDRY_ACCELERATION;\n\t    self._initContainer();\n\t    self.resetSize();\n\t    //set overflow behaviors\n\t    self._setOverflowBehavior();\n\t    self.defaltConfig = {\n\t      lockY: self.userConfig.lockY,\n\t      lockX: self.userConfig.lockX\n\t    }\n\t    return self;\n\t  },\n\t  destroy: function() {\n\t    var self = this;\n\t    SimuScroll.superclass.destroy.call(this);\n\t    self.renderTo.style.overflow = \"\";\n\t    self.renderTo.style.touchAction = \"\";\n\t    self.container.style.transform = \"\";\n\t    self.container.style.transformOrigin = \"\";\n\t    self.content.style.transform = \"\";\n\t    self.content.style.transformOrigin = \"\";\n\t    self.off(\"touchstart mousedown\", self._ontouchstart);\n\t    self.off(\"touchmove\", self._ontouchmove);\n\t    self.destroyScrollBars();\n\t  },\n\t  /**\n\t   * set overflow behavior\n\t   * @return {boolean} [description]\n\t   */\n\t  _setOverflowBehavior: function() {\n\t    var self = this;\n\t    var renderTo = self.renderTo;\n\t    var computeStyle = getComputedStyle(renderTo);\n\t    self.userConfig.lockX = undefined === self.userConfig.lockX ? ((computeStyle['overflow-x'] == \"hidden\" || self.width == self.containerWidth) ? true : false) : self.userConfig.lockX;\n\t    self.userConfig.lockY = undefined === self.userConfig.lockY ? ((computeStyle['overflow-y'] == \"hidden\" || self.height == self.containerHeight) ? true : false) : self.userConfig.lockY;\n\t    self.userConfig.scrollbarX = undefined === self.userConfig.scrollbarX ? (self.userConfig.lockX ? false : true) : self.userConfig.scrollbarX;\n\t    self.userConfig.scrollbarY = undefined === self.userConfig.scrollbarY ? (self.userConfig.lockY ? false : true) : self.userConfig.scrollbarY;\n\t    return self;\n\t  },\n\t  /**\n\t   * reset lockX or lockY config to the default value\n\t   */\n\t  _resetLockConfig: function() {\n\t    var self = this;\n\t    self.userConfig.lockX = self.defaltConfig.lockX;\n\t    self.userConfig.lockY = self.defaltConfig.lockY;\n\t    return self;\n\t  },\n\t  /**\n\t   * init container\n\t   * @override\n\t   * @return {SimuScroll}\n\t   */\n\t  _initContainer: function() {\n\t    var self = this;\n\t    SimuScroll.superclass._initContainer.call(self);\n\t    if (self.__isContainerInited || !self.container || !self.content) return;\n\t    self.container.style[transformOrigin] = \"0 0\";\n\t    self.content.style[transformOrigin] = \"0 0\";\n\t    self.translate(0, 0);\n\t    self.__isContainerInited = true;\n\t    return self;\n\t  },\n\t  /**\n\t   * get scroll top value\n\t   * @memberof SimuScroll\n\t   * @return {number} scrollTop\n\t   */\n\t  getScrollTop: function() {\n\t    var transY = window.getComputedStyle(this.container)[transform].match(/[-\\d\\.*\\d*]+/g);\n\t    return transY ? Math.round(transY[5]) === 0 ? 0 : -Math.round(transY[5]) : 0;\n\t  },\n\t  /**\n\t   * get scroll left value\n\t   * @memberof SimuScroll\n\t   * @return {number} scrollLeft\n\t   */\n\t  getScrollLeft: function() {\n\t    var transX = window.getComputedStyle(this.content)[transform].match(/[-\\d\\.*\\d*]+/g);\n\t    return transX ? Math.round(transX[4]) === 0 ? 0 : -Math.round(transX[4]) : 0;\n\t  },\n\t  /**\n\t   * horizontal scroll absolute to the destination\n\t   * @memberof SimuScroll\n\t   * @param scrollLeft {number} scrollLeft\n\t   * @param duration {number} duration for animte\n\t   * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t   **/\n\t  scrollLeft: function(x, duration, easing, callback) {\n\t    if (this.userConfig.lockX) return;\n\t    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t    this.x = (undefined === x || isNaN(x) || 0 === x) ? 0 : -Math.round(x);\n\t    this._animate(\"x\", \"translateX(\" + this.x + \"px) scale(\" + this.scale + \")\" + translateZ, duration, easing, callback);\n\t    return this;\n\t  },\n\t  /**\n\t   * vertical scroll absolute to the destination\n\t   * @memberof SimuScroll\n\t   * @param scrollTop {number} scrollTop\n\t   * @param duration {number} duration for animte\n\t   * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t   **/\n\t  scrollTop: function(y, duration, easing, callback) {\n\t    if (this.userConfig.lockY) return;\n\t    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t    this.y = (undefined === y || isNaN(y) || 0 === y) ? 0 : -Math.round(y);\n\t    this._animate(\"y\", \"translateY(\" + this.y + \"px) \" + translateZ, duration, easing, callback);\n\t    return this;\n\t  },\n\t  /**\n\t   * translate the scroller to a new destination includes x , y , scale\n\t   * @memberof SimuScroll\n\t   * @param x {number} x\n\t   * @param y {number} y\n\t   * @param scale {number} scale\n\t   **/\n\t  translate: function(x, y, scale) {\n\t    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t    this.x = x || this.x || 0;\n\t    this.y = y || this.y || 0;\n\t    this.scale = scale || this.scale || 1;\n\t    this.content.style[transform] = \"translate(\" + this.x + \"px,0px) scale(\" + this.scale + \") \" + translateZ;\n\t    this.container.style[transform] = \"translate(0px,\" + this.y + \"px) \" + translateZ;\n\t    return this;\n\t  },\n\t  _animate: function(type, transform, duration, easing, callback) {\n\t    var self = this;\n\t    var duration = duration || 0;\n\t    var easing = easing || \"quadratic\";\n\t    var el = type == \"y\" ? self.container : self.content;\n\t    var config = {\n\t      css: {\n\t        transform: transform\n\t      },\n\t      duration: duration,\n\t      easing: easing,\n\t      run: function(e) {\n\t        /**\n\t         * @event {@link SimuScroll#\"scroll\"}\n\t         */\n\t        self.trigger(\"scroll\", {\n\t          scrollTop: self.getScrollTop(),\n\t          scrollLeft: self.getScrollLeft(),\n\t          type: \"scroll\"\n\t        });\n\t      },\n\t      useTransition: self.userConfig.useTransition,\n\t      end: function(e) {\n\t        callback && callback();\n\t        if ((self[\"_bounce\" + type] === 0 || self[\"_bounce\" + type] === undefined) && easing != \"linear\") {\n\t          self['isScrolling' + type.toUpperCase()] = false;\n\t          self['isRealScrolling' + type.toUpperCase()] = false;\n\t          self.trigger(\"scrollend\", {\n\t            type: \"scrollend\",\n\t            scrollTop: self.getScrollTop(),\n\t            scrollLeft: self.getScrollLeft(),\n\t            zoomType: type,\n\t            duration: duration,\n\t            easing: easing\n\t          });\n\t        }\n\t      }\n\t    };\n\t    var timer = self.__timers[type] = self.__timers[type] || new Animate(el, config);\n\t    timer.stop();\n\t    timer.reset(config);\n\t    timer.run();\n\t    self.trigger(\"scrollanimate\", {\n\t      type: \"scrollanimate\",\n\t      scrollTop: -self.y,\n\t      scrollLeft: -self.x,\n\t      duration: duration,\n\t      easing: easing,\n\t      zoomType: type\n\t    })\n\t    return this;\n\t  },\n\t  _ontap: function(e) {\n\t    var self = this;\n\t    self.boundryCheck();\n\t    self._unPreventHref(e);\n\t    if (!self.isRealScrollingX && !self.isRealScrollingY) {\n\t      self._triggerClick(e);\n\t    }\n\t    self._preventHref(e);\n\t    self.isRealScrollingY = false;\n\t    self.isRealScrollingY = false;\n\t  },\n\t  _bindEvt: function() {\n\t    SimuScroll.superclass._bindEvt.call(this);\n\t    var self = this;\n\t    if (self.__isEvtBind) return;\n\t    self.__isEvtBind = true;\n\t    var pinch = new Hammer.Pinch();\n\t    self.mc.add(pinch);\n\t    self.on(\"touchstart mousedown\", self._ontouchstart, self);\n\t    self.on(\"touchmove\", self._ontouchmove, self);\n\t    self.on(\"tap\", self._ontap, self);\n\t    self.on(\"panstart\", self._onpanstart, self);\n\t    self.on(\"pan\", self._onpan, self);\n\t    self.on(\"panend\", self._onpanend, self);\n\t    //window resize\n\t    window.addEventListener(\"resize\", function(e) {\n\t      setTimeout(function() {\n\t        self.resetSize();\n\t        self.boundryCheck(0);\n\t        self.render();\n\t      }, 100);\n\t    }, self);\n\t\n\t    return this;\n\t  },\n\t  _ontouchstart: function(e) {\n\t    var self = this;\n\t    if (!(/(SELECT|INPUT|TEXTAREA)/i).test(e.target.tagName) && self.userConfig.preventDefault) {\n\t      e.preventDefault();\n\t    }\n\t    self.stop();\n\t  },\n\t  _ontouchmove: function(e) {\n\t    this.userConfig.preventTouchMove && e.preventDefault();\n\t  },\n\t  _onpanstart: function(e) {\n\t    this.userConfig.preventTouchMove && e.preventDefault();\n\t    var self = this;\n\t    var scrollLeft = self.getScrollLeft();\n\t    var scrollTop = self.getScrollTop();\n\t    self.stop();\n\t    self.translate(-scrollLeft, -scrollTop);\n\t    var threshold = self.mc.get(\"pan\").options.threshold;\n\t    self.thresholdY = e.direction == \"8\" ? threshold : e.direction == \"16\" ? -threshold : 0;\n\t    self.thresholdX = e.direction == \"2\" ? threshold : e.direction == \"4\" ? -threshold : 0;\n\t    return self;\n\t  },\n\t  _onpan: function(e) {\n\t    this.userConfig.preventTouchMove && e.preventDefault();\n\t    var self = this;\n\t    var boundry = self.boundry;\n\t    var userConfig = self.userConfig;\n\t    var boundryCheck = userConfig.boundryCheck;\n\t    var bounce = userConfig.bounce;\n\t    var scrollTop = self.__topstart || (self.__topstart = -self.getScrollTop());\n\t    var scrollLeft = self.__leftstart || (self.__leftstart = -self.getScrollLeft());\n\t    var y = userConfig.lockY ? Number(scrollTop) : Number(scrollTop) + (e.deltaY + self.thresholdY);\n\t    var x = userConfig.lockX ? Number(scrollLeft) : Number(scrollLeft) + (e.deltaX + self.thresholdX);\n\t    var containerWidth = self.containerWidth;\n\t    var containerHeight = self.containerHeight;\n\t    if (boundryCheck) {\n\t      //over top\n\t      y = y > boundry.top ? bounce ? (y - boundry.top) * PAN_RATE + boundry.top : boundry.top : y;\n\t      //over bottom\n\t      y = y < boundry.bottom - containerHeight ? bounce ? y + (boundry.bottom - containerHeight - y) * PAN_RATE : boundry.bottom - containerHeight : y;\n\t      //over left\n\t      x = x > boundry.left ? bounce ? (x - boundry.left) * PAN_RATE + boundry.left : boundry.left : x;\n\t      //over right\n\t      x = x < boundry.right - containerWidth ? bounce ? x + (boundry.right - containerWidth - x) * PAN_RATE : boundry.right - containerWidth : x;\n\t    }\n\t    //move to x,y\n\t    self.translate(x, y);\n\t    //pan trigger the opposite direction\n\t    self.directionX = e.type == 'panleft' ? 'right' : e.type == 'panright' ? 'left' : '';\n\t    self.directionY = e.type == 'panup' ? 'down' : e.type == 'pandown' ? 'up' : '';\n\t    self.trigger(\"scroll\", {\n\t      scrollTop: -y,\n\t      scrollLeft: -x,\n\t      triggerType: \"pan\",\n\t      type: \"scroll\"\n\t    });\n\t    return self;\n\t  },\n\t  _onpanend: function(e) {\n\t    var self = this;\n\t    var userConfig = self.userConfig;\n\t    var transX = self.computeScroll(\"x\", e.velocityX);\n\t    var transY = self.computeScroll(\"y\", e.velocityY);\n\t    var scrollLeft = transX ? transX.pos : 0;\n\t    var scrollTop = transY ? transY.pos : 0;\n\t    var duration;\n\t    if (transX && transY && transX.status == \"inside\" && transY.status == \"inside\" && transX.duration && transY.duration) {\n\t      //ensure the same duration\n\t      duration = Math.max(transX.duration, transY.duration);\n\t    }\n\t    transX && self.scrollLeft(scrollLeft, duration || transX.duration, transX.easing, function(e) {\n\t      self.boundryCheckX();\n\t    });\n\t    transY && self.scrollTop(scrollTop, duration || transY.duration, transY.easing, function(e) {\n\t      self.boundryCheckY();\n\t    });\n\t    //judge the direction\n\t    self.directionX = e.velocityX < 0 ? \"left\" : \"right\";\n\t    self.directionY = e.velocityY < 0 ? \"up\" : \"down\";\n\t    //clear start\n\t    self.__topstart = null;\n\t    self.__leftstart = null;\n\t    return self;\n\t  },\n\t  /**\n\t   * judge the scroller is out of boundry horizontally and vertically\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOut: function() {\n\t    return this.isBoundryOutLeft() || this.isBoundryOutRight() || this.isBoundryOutTop() || this.isBoundryOutBottom();\n\t  },\n\t  /**\n\t   * judge if the scroller is outsideof left\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOutLeft: function() {\n\t    return this.getBoundryOutLeft() > 0 ? true : false;\n\t  },\n\t  /**\n\t   * judge if the scroller is outsideof right\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOutRight: function() {\n\t    return this.getBoundryOutRight() > 0 ? true : false;\n\t  },\n\t  /**\n\t   * judge if the scroller is outsideof top\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOutTop: function() {\n\t    return this.getBoundryOutTop() > 0 ? true : false;\n\t  },\n\t  /**\n\t   * judge if the scroller is outsideof bottom\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOutBottom: function() {\n\t    return this.getBoundryOutBottom() > 0 ? true : false;\n\t  },\n\t  /**\n\t   * get the offset value outsideof top\n\t   * @memberof SimuScroll\n\t   * @return {number} offset\n\t   **/\n\t  getBoundryOutTop: function() {\n\t    return -this.boundry.top - this.getScrollTop();\n\t  },\n\t  /**\n\t   * get the offset value outsideof left\n\t   * @memberof SimuScroll\n\t   * @return {number} offset\n\t   **/\n\t  getBoundryOutLeft: function() {\n\t    return -this.boundry.left - this.getScrollLeft();\n\t  },\n\t  /**\n\t   * get the offset value outsideof bottom\n\t   * @memberof SimuScroll\n\t   * @return {number} offset\n\t   **/\n\t  getBoundryOutBottom: function() {\n\t    return this.boundry.bottom - this.containerHeight + this.getScrollTop();\n\t  },\n\t  /**\n\t   * get the offset value outsideof right\n\t   * @memberof SimuScroll\n\t   * @return {number} offset\n\t   **/\n\t  getBoundryOutRight: function() {\n\t    return this.boundry.right - this.containerWidth + this.getScrollLeft();\n\t  },\n\t  /**\n\t   * compute scroll transition by zoomType and velocity\n\t   * @memberof SimuScroll\n\t   * @param {string} zoomType zoomType of scrolling\n\t   * @param {number} velocity velocity after panend\n\t   * @example\n\t   * var info = xscroll.computeScroll(\"x\",2);\n\t   * // return {pos:90,easing:\"easing\",status:\"inside\",duration:500}\n\t   * @return {Object}\n\t   **/\n\t  computeScroll: function(type, v) {\n\t    var self = this;\n\t    var userConfig = self.userConfig;\n\t    var boundry = self.boundry;\n\t    var pos = type == \"x\" ? self.getScrollLeft() : self.getScrollTop();\n\t    var boundryStart = type == \"x\" ? boundry.left : boundry.top;\n\t    var boundryEnd = type == \"x\" ? boundry.right : boundry.bottom;\n\t    var innerSize = type == \"x\" ? self.containerWidth : self.containerHeight;\n\t    var maxSpeed = userConfig.maxSpeed || 2;\n\t    var boundryCheck = userConfig.boundryCheck;\n\t    var bounce = userConfig.bounce;\n\t    var transition = {};\n\t    var status = \"inside\";\n\t    if (boundryCheck) {\n\t      if (type == \"x\" && (self.isBoundryOutLeft() || self.isBoundryOutRight())) {\n\t        self.boundryCheckX();\n\t        return;\n\t      } else if (type == \"y\" && (self.isBoundryOutTop() || self.isBoundryOutBottom())) {\n\t        self.boundryCheckY();\n\t        return;\n\t      }\n\t    }\n\t    if (type == \"x\" && self.userConfig.lockX) return;\n\t    if (type == \"y\" && self.userConfig.lockY) return;\n\t    v = v > maxSpeed ? maxSpeed : v < -maxSpeed ? -maxSpeed : v;\n\t    var a = self.SCROLL_ACCELERATION * (v / (Math.abs(v) || 1));\n\t    var a2 = self.BOUNDRY_ACCELERATION;\n\t    var t = isNaN(v / a) ? 0 : v / a;\n\t    var s = Number(pos) + t * v / 2;\n\t    //over top boundry check bounce\n\t    if (s < -boundryStart && boundryCheck) {\n\t      var _s = -boundryStart - pos;\n\t      var _t = (Math.sqrt(-2 * a * _s + v * v) + v) / a;\n\t      var v0 = v - a * _t;\n\t      var _t2 = Math.abs(v0 / a2);\n\t      var s2 = v0 / 2 * _t2;\n\t      t = _t + _t2;\n\t      s = bounce ? -boundryStart + s2 : -boundryStart;\n\t      status = \"outside\";\n\t    } else if (s > innerSize - boundryEnd && boundryCheck) {\n\t      var _s = (boundryEnd - innerSize) + pos;\n\t      var _t = (Math.sqrt(-2 * a * _s + v * v) - v) / a;\n\t      var v0 = v - a * _t;\n\t      var _t2 = Math.abs(v0 / a2);\n\t      var s2 = v0 / 2 * _t2;\n\t      t = _t + _t2;\n\t      s = bounce ? innerSize - boundryEnd + s2 : innerSize - boundryEnd;\n\t      status = \"outside\";\n\t    }\n\t    if (isNaN(s) || isNaN(t)) return;\n\t    transition.pos = s;\n\t    transition.duration = t;\n\t    transition.easing = Math.abs(v) > 2 ? \"circular\" : \"quadratic\";\n\t    transition.status = status;\n\t    var Type = type.toUpperCase();\n\t    self['isScrolling' + Type] = true;\n\t    self['isRealScrolling' + Type] = true;\n\t    return transition;\n\t  },\n\t  /**\n\t   * bounce to the boundry horizontal\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  boundryCheckX: function(duration, easing, callback) {\n\t    var self = this;\n\t    if (!self.userConfig.boundryCheck) return;\n\t    if (typeof arguments[0] == \"function\") {\n\t      callback = arguments[0];\n\t      duration = self.userConfig.BOUNDRY_CHECK_DURATION;\n\t      easing = self.userConfig.BOUNDRY_CHECK_EASING;\n\t    } else {\n\t      duration = duration === 0 ? 0 : self.userConfig.BOUNDRY_CHECK_DURATION,\n\t        easing = easing || self.userConfig.BOUNDRY_CHECK_EASING;\n\t    }\n\t    if (!self.userConfig.bounce || self.userConfig.lockX) return;\n\t    var boundry = self.boundry;\n\t    if (self.isBoundryOutLeft()) {\n\t      self.scrollLeft(-boundry.left, duration, easing, callback);\n\t    } else if (self.isBoundryOutRight()) {\n\t      self.scrollLeft(self.containerWidth - boundry.right, duration, easing, callback);\n\t    }\n\t    return self;\n\t  },\n\t  /**\n\t   * bounce to the boundry vertical\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  boundryCheckY: function(duration, easing, callback) {\n\t    var self = this;\n\t    if (!self.userConfig.boundryCheck) return;\n\t    if (typeof arguments[0] == \"function\") {\n\t      callback = arguments[0];\n\t      duration = self.userConfig.BOUNDRY_CHECK_DURATION;\n\t      easing = self.userConfig.BOUNDRY_CHECK_EASING;\n\t    } else {\n\t      duration = duration === 0 ? 0 : self.userConfig.BOUNDRY_CHECK_DURATION,\n\t        easing = easing || self.userConfig.BOUNDRY_CHECK_EASING;\n\t    }\n\t    if (!self.userConfig.boundryCheck || self.userConfig.lockY) return;\n\t    var boundry = self.boundry;\n\t    if (self.isBoundryOutTop()) {\n\t      self.scrollTop(-boundry.top, duration, easing, callback);\n\t    } else if (self.isBoundryOutBottom()) {\n\t      self.scrollTop(self.containerHeight - boundry.bottom, duration, easing, callback);\n\t    }\n\t    return self;\n\t  },\n\t  /**\n\t   * bounce to the boundry vertical and horizontal\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  boundryCheck: function(duration, easing, callback) {\n\t    this.boundryCheckX(duration, easing, callback);\n\t    this.boundryCheckY(duration, easing, callback);\n\t    return this;\n\t  },\n\t  /**\n\t   * stop scrolling immediatelly\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  stop: function() {\n\t    var self = this;\n\t    self.__timers.x && self.__timers.x.stop();\n\t    self.__timers.y && self.__timers.y.stop();\n\t    if (self.isScrollingX || self.isScrollingY) {\n\t      var scrollTop = self.getScrollTop(),\n\t        scrollLeft = self.getScrollLeft();\n\t      self.trigger(\"scrollend\", {\n\t        scrollTop: scrollTop,\n\t        scrollLeft: scrollLeft\n\t      });\n\t      self.trigger(\"stop\", {\n\t        scrollTop: scrollTop,\n\t        scrollLeft: scrollLeft\n\t      })\n\t      self.isScrollingX = false;\n\t      self.isScrollingY = false;\n\t    }\n\t    return self;\n\t  },\n\t  /**\n\t   * render scroll\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  render: function() {\n\t    var self = this;\n\t    SimuScroll.superclass.render.call(this);\n\t    //fixed for scrollbars\n\t    if (getComputedStyle(self.renderTo).position == \"static\") {\n\t      self.renderTo.style.position = \"relative\";\n\t    }\n\t    self.renderTo.style.overflow = \"hidden\";\n\t    self.initScrollBars();\n\t    self.initController();\n\t    return self;\n\t  },\n\t  /**\n\t   * init scrollbars\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   */\n\t  initScrollBars: function() {\n\t    var self = this;\n\t    if (!self.userConfig.boundryCheck) return;\n\t    var indicatorInsets = self.userConfig.indicatorInsets;\n\t    if (self.userConfig.scrollbarX) {\n\t      self.scrollbarX = self.scrollbarX || new ScrollBar({\n\t        xscroll: self,\n\t        type: \"x\",\n\t        spacing: indicatorInsets.spacing\n\t      });\n\t      self.scrollbarX.render();\n\t      self.scrollbarX._update();\n\t      self.scrollbarX.hide();\n\t    }\n\t    if (self.userConfig.scrollbarY) {\n\t      self.scrollbarY = self.scrollbarY || new ScrollBar({\n\t        xscroll: self,\n\t        type: \"y\",\n\t        spacing: indicatorInsets.spacing\n\t      });\n\t      self.scrollbarY.render();\n\t      self.scrollbarY._update();\n\t      self.scrollbarY.hide();\n\t    }\n\t    return self;\n\t  },\n\t  /**\n\t   * destroy scrollbars\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   */\n\t  destroyScrollBars: function() {\n\t    this.scrollbarX && this.scrollbarX.destroy();\n\t    this.scrollbarY && this.scrollbarY.destroy();\n\t    return this;\n\t  },\n\t  /**\n\t   * init controller for multi-scrollers\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   */\n\t  initController: function() {\n\t    var self = this;\n\t    self.controller = self.controller || new Controller({\n\t      xscroll: self\n\t    });\n\t    return self;\n\t  },\n\t  _unPreventHref: function(e) {\n\t    var target = Util.findParentEl(e.target,'a',this.renderTo);\n\t    if(!target) return;\n\t    if (target.tagName.toLowerCase() == \"a\") {\n\t      var href = target.getAttribute(\"data-xs-href\");\n\t      if (href) {\n\t        target.setAttribute(\"href\", href);\n\t      }\n\t    }\n\t  },\n\t  _preventHref: function(e) {\n\t    var target = Util.findParentEl(e.target,'a',this.renderTo);\n\t    if(!target) return;\n\t    if (target.tagName.toLowerCase() == \"a\") {\n\t      var href = target.getAttribute(\"href\");\n\t      href && target.setAttribute(\"href\", \"javascript:void(0)\");\n\t      href && target.setAttribute(\"data-xs-href\", href);\n\t    }\n\t  },\n\t  _triggerClick: function(e) {\n\t    var target = e.target;\n\t    if (!(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName)) {\n\t      var ev = document.createEvent('MouseEvents');\n\t      ev.initMouseEvent('click', true, true, e.view, 1,\n\t        target.screenX, target.screenY, target.clientX, target.clientY,\n\t        e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,\n\t        0, null);\n\t      target.dispatchEvent(ev);\n\t    }\n\t  }\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t  module.exports = SimuScroll;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t  return SimuScroll;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t\tBase = __webpack_require__(2),\n\t\tTimer = __webpack_require__(9),\n\t\tAnimate = __webpack_require__(3),\n\t\tHammer = __webpack_require__(6),\n\t\tSimuScroll = __webpack_require__(27),\n\t\tOriginScroll = __webpack_require__(23);\n\tvar XScroll = function(cfg) {\n\t\t\tvar _ = cfg && cfg.useOriginScroll ? OriginScroll : SimuScroll;\n\t\t\treturn new _(cfg);\n\t\t}\n\t/**\n\t * Util\n\t * @namespace Util\n\t * @type {Object}\n\t */\n\tXScroll.Util = Util;\n\t/**\n\t * Base\n\t * @namespace Base\n\t * @type {Base}\n\t */\n\tXScroll.Base = Base;\n\t/**\n\t * Timer\n\t * @namespace Timer\n\t * @type {Timer}\n\t */\n\tXScroll.Timer = Timer;\n\t/**\n\t * Animate\n\t * @namespace Animate\n\t * @type {Animate}\n\t */\n\tXScroll.Animate = Animate;\n\t/**\n\t * Hammer\n\t * @namespace Hammer\n\t * @type {Hammer}\n\t */\n\tXScroll.Hammer = Hammer;\n\t/**\n\t * plugins\n\t * @namespace Plugins\n\t * @type {Object}\n\t */\n\tXScroll.Plugins = {};\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = XScroll;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn window.XScroll = XScroll;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_30__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// react-xscroll.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3751897750118c5c0894","import ReactXScroll from 'components/react-xscroll';\nexport default ReactXScroll;\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","define(function(require, exports, module) {\n\"use strict\";\nvar SUBSTITUTE_REG = /\\\\?\\{([^{}]+)\\}/g,\n\tEMPTY = '';\n\nvar RE_TRIM = /^[\\s\\xa0]+|[\\s\\xa0]+$/g,\n\ttrim = String.prototype.trim;\n\nvar _trim = trim ?\n\tfunction(str) {\n\t\treturn str == null ? EMPTY : trim.call(str);\n\t} : function(str) {\n\t\treturn str == null ? EMPTY : (str + '').replace(RE_TRIM, EMPTY);\n\t};\n\nfunction upperCase() {\n\treturn arguments[1].toUpperCase();\n}\n\nfunction Empty() {}\n\nfunction createObject(proto, constructor) {\n\tvar newProto;\n\tif (Object.create) {\n\t\tnewProto = Object.create(proto);\n\t} else {\n\t\tEmpty.prototype = proto;\n\t\tnewProto = new Empty();\n\t}\n\tnewProto.constructor = constructor;\n\treturn newProto;\n}\n\nfunction getNodes(node, rootNode) {\n\tif (!node) return;\n\tif (node.nodeType) return [node];\n\tvar rootNode = rootNode && rootNode.nodeType ? rootNode : document;\n\tif (node && typeof node === \"string\") {\n\t\treturn rootNode.querySelectorAll(node);\n\t}\n\treturn;\n}\n\n// Useful for temporary DOM ids.\nvar idCounter = 0;\n\nvar getOffsetTop = function(el) {\n\tvar offset = el.offsetTop;\n\tif (el.offsetParent != null) offset += getOffsetTop(el.offsetParent);\n\treturn offset;\n};\nvar getOffsetLeft = function(el) {\n\tvar offset = el.offsetLeft;\n\tif (el.offsetParent != null) offset += getOffsetLeft(el.offsetParent);\n\treturn offset;\n};\n\nvar Util = {\n\t// Is a given variable an object?\n\tisObject: function(obj) {\n\t\treturn obj === Object(obj);\n\t},\n\tisArray: Array.isArray || function(obj) {\n\t\treturn toString.call(obj) == '[object Array]';\n\t},\n\t// Is a given array, string, or object empty?\n\t// An \"empty\" object has no enumerable own-properties.\n\tisEmpty: function(obj) {\n\t\tif (obj == null) return true;\n\t\tif (this.isArray(obj) || this.isString(obj)) return obj.length === 0;\n\t\tfor (var key in obj)\n\t\t\tif (this.has(obj, key)) return false;\n\t\treturn true;\n\t},\n\tmix: function(to, from, deep) {\n\t\tfor (var i in from) {\n\t\t\tto[i] = from[i];\n\t\t}\n\t\treturn to;\n\t},\n\textend: function(r, s, px, sx) {\n\t\tif (!s || !r) {\n\t\t\treturn r;\n\t\t}\n\t\tvar sp = s.prototype,\n\t\t\trp;\n\t\t// add prototype chain\n\t\trp = createObject(sp, r);\n\t\tr.prototype = this.mix(rp, r.prototype);\n\t\tr.superclass = createObject(sp, s);\n\t\t// add prototype overrides\n\t\tif (px) {\n\t\t\tthis.mix(rp, px);\n\t\t}\n\t\t// add object overrides\n\t\tif (sx) {\n\t\t\tthis.mix(r, sx);\n\t\t}\n\t\treturn r;\n\t},\n\t/**\n\t * test whether a string start with a specified substring\n\t * @param {String} str the whole string\n\t * @param {String} prefix a specified substring\n\t * @return {Boolean} whether str start with prefix\n\t * @member util\n\t */\n\tstartsWith: function(str, prefix) {\n\t\treturn str.lastIndexOf(prefix, 0) === 0;\n\t},\n\n\t/**\n\t * test whether a string end with a specified substring\n\t * @param {String} str the whole string\n\t * @param {String} suffix a specified substring\n\t * @return {Boolean} whether str end with suffix\n\t * @member util\n\t */\n\tendsWith: function(str, suffix) {\n\t\tvar ind = str.length - suffix.length;\n\t\treturn ind >= 0 && str.indexOf(suffix, ind) === ind;\n\t},\n\t/**\n\t * Removes the whitespace from the beginning and end of a string.\n\t * @method\n\t * @member util\n\t */\n\ttrim: _trim,\n\t/**\n\t * Substitutes keywords in a string using an object/array.\n\t * Removes undef keywords and ignores escaped keywords.\n\t * @param {String} str template string\n\t * @param {Object} o json data\n\t * @member util\n\t * @param {RegExp} [regexp] to match a piece of template string\n\t */\n\tsubstitute: function(str, o, regexp) {\n\t\tif (typeof str !== 'string' || !o) {\n\t\t\treturn str;\n\t\t}\n\n\t\treturn str.replace(regexp || SUBSTITUTE_REG, function(match, name) {\n\t\t\tif (match.charAt(0) === '\\\\') {\n\t\t\t\treturn match.slice(1);\n\t\t\t}\n\t\t\treturn (o[name] === undefined) ? EMPTY : o[name];\n\t\t});\n\t},\n\t/**\n\t * vendors\n\t * @return { String } webkit|moz|ms|o\n\t * @memberOf Util\n\t */\n\tvendor: (function() {\n\t\tvar el = document.createElement('div').style;\n\t\tvar vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],\n\t\t\ttransform,\n\t\t\ti = 0,\n\t\t\tl = vendors.length;\n\t\tfor (; i < l; i++) {\n\t\t\ttransform = vendors[i] + 'ransform';\n\t\t\tif (transform in el) return vendors[i].substr(0, vendors[i].length - 1);\n\t\t}\n\t\treturn false;\n\t})(),\n\t/**\n\t *  add vendor to attribute\n\t *  @memberOf Util\n\t *  @param {String} attrName name of attribute\n\t *  @return { String }\n\t **/\n\tprefixStyle: function(attrName) {\n\t\tif (this.vendor === false) return false;\n\t\tif (this.vendor === '') return attrName;\n\t\treturn this.vendor + attrName.charAt(0).toUpperCase() + attrName.substr(1);\n\t},\n\t/**\n\t * judge if has class\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t * @param  {String}  className\n\t * @return {Boolean}\n\t */\n\thasClass: function(el, className) {\n\t\treturn el && el.className && className && el.className.indexOf(className) != -1;\n\t},\n\t/**\n\t * add className for the element\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t * @param  {String}  className\n\t */\n\taddClass: function(el, className) {\n\t\tif (el && className && !this.hasClass(el, className)) {\n\t\t\tel.className += \" \" + className;\n\t\t}\n\t},\n\t/**\n\t * remove className for the element\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t * @param  {String}  className\n\t */\n\tremoveClass: function(el, className) {\n\t\tif (el && el.className && className) {\n\t\t\tel.className = el.className.replace(className, \"\");\n\t\t}\n\t},\n\t/**\n\t * remove an element\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t */\n\tremove: function(el) {\n\t\tif (!el || !el.parentNode) return;\n\t\tel.parentNode.removeChild(el);\n\t},\n\t/**\n\t * get offset top\n\t * @memberOf Util\n\t * @param  {HTMLElement}   el\n\t * @return {Number} offsetTop\n\t */\n\tgetOffsetTop: getOffsetTop,\n\t/**\n\t * get offset left\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t * @return {Number} offsetLeft\n\t */\n\tgetOffsetLeft: getOffsetLeft,\n\t/**\n\t * get offset left\n\t * @memberOf Util\n\t * @param  {HTMLElement} el\n\t * @param  {String} selector\n\t * @param  {HTMLElement} rootNode\n\t * @return {HTMLElement} parent element\n\t */\n\tfindParentEl: function(el, selector, rootNode) {\n\t\tvar rs = null,\n\t\t\tparent = null;\n\t\tvar type = /^#/.test(selector) ? \"id\" : /^\\./.test(selector) ? \"class\" : \"tag\";\n\t\tvar sel = selector.replace(/\\.|#/g, \"\");\n\t\tif (rootNode && typeof rootNode === \"string\") {\n\t\t\trootNode = document.querySelector(rootNode);\n\t\t}\n\t\trootNode = rootNode || document.body;\n\t\tif (!el || !selector) return;\n\t\tif (type == \"class\" && el.className && el.className.match(sel)) {\n\t\t\treturn el;\n\t\t} else if (type == \"id\" && el.id && _trim(el.id) == sel) {\n\t\t\treturn el;\n\t\t} else if (type == \"tag\" && el.tagName.toLowerCase() == sel) {\n\t\t\treturn el;\n\t\t}\n\t\twhile (!rs) {\n\t\t\tif (parent == rootNode) break;\n\t\t\tparent = el.parentNode;\n\t\t\tif (!parent) break;\n\t\t\tif ((type == \"class\" && parent.className && parent.className.match(sel)) || (type == \"id\" && parent.id && _trim(parent.id) == sel) || (type == \"tag\" && parent.tagName && parent.tagName.toLowerCase() == sel)) {\n\t\t\t\trs = parent\n\t\t\t\treturn rs;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tel = parent;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\t/**\n\t * Generate a unique integer id (unique within the entire client session).\n\t * @param  {String} prefix\n\t * @return {String} guid\n\t */\n\tguid: function(prefix) {\n\t\tvar id = ++idCounter + '';\n\t\treturn prefix ? prefix + id : id;\n\t},\n\t/**\n\t * judge if is an android os\n\t * @return {Boolean} [description]\n\t */\n\tisAndroid: function() {\n\t\treturn /Android /.test(window.navigator.appVersion);\n\t},\n\t/**\n\t * judge if is an android device with low  performance\n\t * @return {Boolean}\n\t */\n\tisBadAndroid: function() {\n\t\treturn /Android /.test(window.navigator.appVersion) && !(/Chrome\\/\\d/.test(window.navigator.appVersion))\n\t},\n\tpx2Num: function(px) {\n\t\treturn Number(px.replace(/px/, ''));\n\t},\n\tgetNodes: getNodes,\n\tgetNode: function(node, rootNode) {\n\t\tvar nodes = getNodes(node, rootNode);\n\t\treturn nodes && nodes[0];\n\t},\n\tstringifyStyle: function(style) {\n\t\tvar styleStr = \"\";\n\t\tfor (var i in style) {\n\t\t\tstyleStr += [i, \":\", style[i], \";\"].join(\"\");\n\t\t}\n\t\treturn styleStr;\n\t}\n}\n\n// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\nvar names = ['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'];\nfor (var i = 0; i < names.length; i++) {\n\tUtil['is' + names[i]] = function(obj) {\n\t\treturn toString.call(obj) == '[object ' + names[i] + ']';\n\t};\n}\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Util;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Util;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/util.js\n// module id = 1\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util');\nvar Events = require('./events');\n/** \n      @constructor \n      @mixes Events\n      */\nvar Base = function() {}\n\nUtil.mix(Base.prototype, Events);\n\nUtil.mix(Base.prototype, {\n\t/**\n\t * @memberof Base\n\t * @param  {object} plugin plug a plugin\n\t */\n\tplug: function(plugin) {\n\t\tvar self = this;\n\t\tif (!plugin || !plugin.pluginId) return;\n\t\tif (!self.__plugins) {\n\t\t\tself.__plugins = [];\n\t\t}\n\t\tvar __plugin = self.getPlugin(plugin.pluginId);\n\t\t__plugin && self.unplug(plugin.pluginId);\n\t\tplugin.pluginInitializer(self);\n\t\tself.__plugins.push(plugin);\n\t\treturn self;\n\t},\n\t/**\n\t * @memberof Base\n\t * @param  {object|string} plugin unplug a plugin by pluginId or plugin instance\n\t */\n\tunplug: function(plugin) {\n\t\tvar self = this;\n\t\tif (!plugin || !self.__plugins) return;\n\t\tvar _plugin = typeof plugin == \"string\" ? self.getPlugin(plugin) : plugin;\n\t\t_plugin.pluginDestructor(self);\n\t\tfor (var i = 0, l = self.__plugins.length;i < l;i++) {\n\t\t\tif (self.__plugins[i] == _plugin) {\n\t\t\t\treturn self.__plugins.splice(i, 1);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @memberof Base\n\t * @param  {object|string} plugin get plugin by pluginId\n\t */\n\tgetPlugin: function(pluginId) {\n\t\tvar self = this;\n\t\tvar plugins = [];\n\t\tif(!self.__plugins) return;\n\t\tfor (var i = 0, l = self.__plugins.length;i < l;i++) {\n\t\t\tif (self.__plugins[i] && self.__plugins[i].pluginId == pluginId) {\n\t\t\t\tplugins.push(self.__plugins[i])\n\t\t\t}\n\t\t}\n\t\treturn plugins.length > 1 ? plugins : plugins[0] || null;\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Base;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Base;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/base.js\n// module id = 2\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util');\nvar Timer = require('./timer');\nvar Easing = require('./easing');\nvar Base = require('./base');\n//transform\nvar vendorTransform = Util.prefixStyle(\"transform\");\n//transition webkitTransition MozTransition OTransition msTtransition\nvar vendorTransition = Util.prefixStyle(\"transition\");\n\nvar vendorTransitionDuration = Util.prefixStyle(\"transitionDuration\");\n\nvar vendorTransformOrigin = Util.prefixStyle(\"transformOrigin\");\n\nvar vendorTransitionEnd = Util.vendor ? Util.prefixStyle(\"transitionEnd\") : \"transitionend\";\n\nvar vendorTransformStr = Util.vendor ? [\"-\", Util.vendor, \"-transform\"].join(\"\") : \"transform\";\n\nvar translateTpl = 'translateX({translateX}px) translateY({translateY}px) translateZ(0)';\n//limit attrs\nvar animAttrs = {\n\t'transform': true,\n\t'opacity': true,\n\t'scrollTop': true,\n\t'scrollLeft': true\n};\n\nfunction myParse(v) {\n\treturn Math.round(parseFloat(v) * 1e5) / 1e5;\n}\n\nfunction defaultDecompose() {\n\treturn {\n\t\ttranslateX: 0,\n\t\ttranslateY: 0,\n\t\trotate: 0,\n\t\tskewX: 0,\n\t\tskewY: 0,\n\t\tscaleX: 1,\n\t\tscaleY: 1\n\t};\n}\n\nfunction toMatrixArray(matrix) {\n\tmatrix = matrix.split(/,/);\n\tmatrix = Array.prototype.map.call(matrix, function(v) {\n\t\treturn myParse(v);\n\t});\n\treturn matrix;\n}\n\nfunction decomposeMatrix(matrix) {\n\tmatrix = toMatrixArray(matrix);\n\tvar scaleX, scaleY, skew,\n\t\tA = matrix[0],\n\t\tB = matrix[1],\n\t\tC = matrix[2],\n\t\tD = matrix[3];\n\n\t// Make sure matrix is not singular\n\tif (A * D - B * C) {\n\t\tscaleX = Math.sqrt(A * A + B * B);\n\t\tskew = (A * C + B * D) / (A * D - C * B);\n\t\tscaleY = (A * D - B * C) / scaleX;\n\t\t// step (6)\n\t\tif (A * D < B * C) {\n\t\t\tskew = -skew;\n\t\t\tscaleX = -scaleX;\n\t\t}\n\t\t// matrix is singular and cannot be interpolated\n\t} else {\n\t\t// In this case the elem shouldn't be rendered, hence scale == 0\n\t\tscaleX = scaleY = skew = 0;\n\t}\n\n\t// The recomposition order is very important\n\t// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971\n\treturn {\n\t\ttranslateX: myParse(matrix[4]),\n\t\ttranslateY: myParse(matrix[5]),\n\t\trotate: myParse(Math.atan2(B, A) * 180 / Math.PI),\n\t\tskewX: myParse(Math.atan(skew) * 180 / Math.PI),\n\t\tskewY: 0,\n\t\tscaleX: myParse(scaleX),\n\t\tscaleY: myParse(scaleY)\n\t};\n}\n\nfunction getTransformInfo(transform) {\n\ttransform = transform.split(')');\n\tvar trim = Util.trim,\n\t\ti = -1,\n\t\tl = transform.length - 1,\n\t\tsplit, prop, val,\n\t\tret = defaultDecompose();\n\n\t// Loop through the transform properties, parse and multiply them\n\twhile (++i < l) {\n\t\tsplit = transform[i].split('(');\n\t\tprop = trim(split[0]);\n\t\tval = split[1];\n\t\tswitch (prop) {\n\t\t\tcase 'translateX':\n\t\t\tcase 'translateY':\n\t\t\tcase 'scaleX':\n\t\t\tcase 'scaleY':\n\t\t\t\tret[prop] = myParse(val);\n\t\t\t\tbreak;\n\t\t\tcase 'translate':\n\t\t\tcase 'translate3d':\n\t\t\t\tval = val.split(',');\n\t\t\t\tret.translateX = myParse(val[0]);\n\t\t\t\tret.translateY = myParse(val[1] || 0);\n\t\t\t\tbreak;\n\t\t\tcase 'scale':\n\t\t\t\tval = val.split(',');\n\t\t\t\tret.scaleX = myParse(val[0]);\n\t\t\t\tret.scaleY = myParse(val[1] || val[0]);\n\t\t\t\tbreak;\n\t\t\tcase 'matrix':\n\t\t\t\treturn decomposeMatrix(val);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/**\n * animate function\n * @constructor\n * @param {HTMLElement} el element to animate\n * @param {Object} config config for animate\n * @param {Object} config.css\n * @param {Number} config.duration\n * @param {String} config.easing\n * @extends {Base}\n */\nfunction Animate(el, cfg) {\n\tif (!el || !cfg || !cfg.css) return;\n\tvar self = this;\n\tself.cfg = cfg;\n\tself.el = el;\n\tvar duration = cfg.duration || 0,\n\t\teasing = cfg.easing || \"ease\",\n\t\tdelay = cfg.delay || 0;\n\t//trigger run\n\tif (cfg.run) {\n\t\t//frame animate\n\t\tself.timer = self.timer || new Timer({\n\t\t\tduration: Math.round(duration),\n\t\t\teasing: easing,\n\t\t});\n\t\tself.timer.on(\"run\", cfg.run);\n\t}\n\tself._bindEvt();\n\treturn self;\n}\n\nfunction computeTransform(prevTransform, destTransform) {\n\tvar transform = getTransformInfo(prevTransform);\n\tvar dest = getTransformInfo(destTransform);\n\tvar trans = {};\n\tfor (var i in dest) {\n\t\ttrans[i] = {\n\t\t\tprevVal: transform[i],\n\t\t\tnewVal: dest[i]\n\t\t}\n\t}\n\treturn trans;\n}\n\n//for scroll only\nfunction setStyle(el, styleName, prevVal, newVal, percent) {\n\tprevVal = isNaN(Number(prevVal)) ? 0 : Number(prevVal);\n\tvar curVal = ((newVal - prevVal) * percent + prevVal);\n\tcss(el, styleName, curVal);\n}\n\nfunction css(el, styleName, val) {\n\tswitch (styleName) {\n\t\tcase \"scrollTop\":\n\t\tcase \"scrollLeft\":\n\t\t\tel[styleName] = val;\n\t\t\tbreak;\n\t\tcase \"transform\":\n\t\t\tel.style[vendorTransform] = val;\n\t\tcase \"opacity\":\n\t\t\tel.style[styleName] = val;\n\t\t\tbreak;\n\n\t}\n}\n\nUtil.extend(Animate, Base, {\n\t/**\n\t * to start the animation\n\t * @memberof Animate\n\t * @return {Animate}\n\t */\n\trun: function() {\n\t\tvar self = this;\n\t\tvar cfg = self.cfg,\n\t\t\tel = self.el,\n\t\t\tduration = cfg.duration || 0,\n\t\t\teasing = cfg.easing || \"ease\",\n\t\t\tdelay = cfg.delay || 0;\n\t\tself.__isTransitionEnd = false;\n\t\tclearTimeout(self.__itv)\n\t\tself.timer && self.timer.run();\n\t\tif (duration <= Timer.MIN_DURATION) {\n\t\t\tfor (var i in cfg.css) {\n\t\t\t\tcss(el, i, cfg.css[i]);\n\t\t\t}\n\t\t\tself.stop()\n\t\t\tself.__handlers.stop.call(self);\n\t\t\treturn;\n\t\t}\n\n\t\tif(Util.isBadAndroid()){\n\t\t\t//use frame animate on bad android device\n\t\t\tcfg.useTransition = false;\n\t\t}\n\n\t\tif (cfg.useTransition) {\n\t\t\t//transition\n\t\t\tel.style[vendorTransition] = Util.substitute('all {duration}ms {easing} {delay}ms', {\n\t\t\t\tduration: Math.round(duration),\n\t\t\t\teasing: Easing.format(easing),\n\t\t\t\tdelay: delay\n\t\t\t});\n\t\t\tfor (var i in cfg.css) {\n\t\t\t\t//set css\n\t\t\t\tcss(el, i, cfg.css[i]);\n\t\t\t}\n\t\t\tself.__itv = setTimeout(function() {\n\t\t\t\tif (!self.__isTransitionEnd) {\n\t\t\t\t\tself.__isTransitionEnd = true;\n\t\t\t\t\tself.trigger(\"transitionend\");\n\t\t\t\t}\n\t\t\t}, Number(duration) + 60);\n\t\t} else {\n\t\t\tself.computeStyle = self.computeStyle || window.getComputedStyle(el);\n\t\t\t//transform\n\t\t\tif (cfg.css.transform && self.timer) {\n\t\t\t\tvar transmap = self.transmap = computeTransform(self.computeStyle[vendorTransform], cfg.css.transform);\n\t\t\t\tself.timer.off(\"run\", self.__handlers.transRun);\n\t\t\t\tself.timer.on(\"run\", self.__handlers.transRun, self);\n\t\t\t\tself.timer.off(\"end\",self.__handlers.transRun);\n\t\t\t\tself.timer.on(\"end\", self.__handlers.transRun, self);\n\t\t\t}\n\t\t}\n\t\treturn self;\n\t},\n\t_transitionEndHandler: function(e) {\n\t\tvar self = this;\n\t\tself.stop();\n\t\tself.__handlers.stop.call(self);\n\t},\n\t__handlers: {\n\t\ttransRun: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar transmap = self.transmap;\n\t\t\tvar el = self.el;\n\t\t\tvar newTrans = {};\n\t\t\tfor (var i in transmap) {\n\t\t\t\tnewTrans[i] = (transmap[i].newVal - transmap[i].prevVal) * e.percent + transmap[i].prevVal\n\t\t\t}\n\t\t\tvar ret = Util.substitute(translateTpl + ' ' +\n\t\t\t\t'scale({scaleX},{scaleY})', newTrans);\n\t\t\tel.style[vendorTransform] = ret;\n\t\t},\n\t\tstop: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar cfg = self.cfg;\n\t\t\tcfg.end && cfg.end({\n\t\t\t\tpercent: 1\n\t\t\t});\n\t\t}\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tvar cfg = self.cfg;\n\t\tvar el = self.el;\n\t\tself.el.addEventListener(vendorTransitionEnd, function(e) {\n\t\t\tself.__isTransitionEnd = true;\n\t\t\tif (e.target !== e.currentTarget) return;\n\t\t\tself.trigger(\"transitionend\", e);\n\t\t})\n\t\tself.on(\"transitionend\", self._transitionEndHandler, self);\n\t\tvar cssRun = function(e) {\n\t\t\tself.computeStyle = self.computeStyle || window.getComputedStyle(el);\n\t\t\tfor (var i in cfg.css) {\n\t\t\t\tif (!/transform/.test(i)) {\n\t\t\t\t\tsetStyle(self.el, i, self.computeStyle[i], cfg.css[i], e.percent);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tself.timer && self.timer.on(\"run\", cssRun);\n\t\tself.timer && self.timer.on(\"stop\", self.__handlers.stop, self);\n\t},\n\t/**\n\t * to stop the animation\n\t * @memberof Animate\n\t * @return {Animate}\n\t */\n\tstop: function() {\n\t\tvar self = this;\n\t\tif (self.cfg.useTransition && self.cfg.duration > Timer.MIN_DURATION) {\n\t\t\tvar computeStyle = window.getComputedStyle(this.el);\n\t\t\tfor (var i in self.cfg.css) {\n\t\t\t\tif (animAttrs[i]) {\n\t\t\t\t\tvar value = /transform/.test(i) ? computeStyle[vendorTransform] : computeStyle[i];\n\t\t\t\t\tcss(self.el, i, Util.substitute(translateTpl + ' ' + 'scale({scaleX},{scaleY})', getTransformInfo(value)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.el.style[vendorTransition] = \"none\";\n\t\t}\n\t\tself.timer && self.timer.stop() && self.timer.reset();\n\t\tself.computeStyle = null;\n\t\treturn self;\n\t},\n\t/**\n\t * to reset the animation to a new state\n\t * @memberof Animate\n\t * @param {object} cfg cfg for new animation\n\t * @return {Animate}\n\t */\n\treset: function(cfg) {\n\t\tvar self = this;\n\t\tself.computeStyle = null;\n\t\tUtil.mix(self.cfg, cfg);\n\t\tthis.timer && self.timer.reset({\n\t\t\tduration: Math.round(self.cfg.duration),\n\t\t\teasing: self.cfg.easing\n\t\t});\n\t\treturn self;\n\t}\n});\n\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Animate;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Animate;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/animate.js\n// module id = 3\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 4\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 5\n// module chunks = 0","define(function(require, exports, module) {\n/*! Hammer.JS - v2.0.4 - 2014-09-28\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2014 Jorik Tangelder;\n * Licensed under the MIT license */\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge]\n * @returns {Object} dest\n */\nfunction extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nfunction merge(dest, src) {\n    return extend(dest, src, true);\n}\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        extend(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument;\n    return (doc.defaultView || doc.parentWindow);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = last.deltaX - input.deltaX;\n        var deltaY = last.deltaY - input.deltaY;\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n    \n    if (abs(x) >= abs(y)) {\n        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n        if (!this.pressed || !this.allow) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        // when we're in a touch event, so  block all upcoming mouse events\n        // most mobile browser also emit mouseevents, right after touchstart\n        if (isTouch) {\n            this.mouse.allow = false;\n        } else if (isMouse && !this.mouse.allow) {\n            return;\n        }\n\n        // reset the allowMouse when we're done\n        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n            this.mouse.allow = true;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        // not needed with native support for the touchAction property\n        if (NATIVE_TOUCH_ACTION) {\n            return;\n        }\n\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // pan-x and pan-y can be combined\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.id = uniqueId();\n\n    this.manager = null;\n    this.options = merge(options || {}, this.defaults);\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        extend(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(withState) {\n            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(true);\n        }\n\n        emit(); // simple 'eventName' events\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(true);\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = extend({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this._super.emit.call(this, input);\n    },\n    reset:function(){\n        \n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        this._super.emit.call(this, input);\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            this.manager.emit(this.options.event + inOut, input);\n        }\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 500, // minimal time of the pointer to be pressed\n        threshold: 5 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.65,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.velocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.velocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.velocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.direction &&\n            input.distance > this.options.threshold &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.direction);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 10, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED ) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create an manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.4';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, { enable: false }],\n        [PinchRecognizer, { enable: false }, ['rotate']],\n        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\n        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    options = options || {};\n\n    this.options = merge(options, Hammer.defaults);\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        extend(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        var recognizers = this.recognizers;\n        recognizer = this.get(recognizer);\n        recognizers.splice(inArray(recognizers, recognizer), 1);\n\n        this.touchAction.update();\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    each(manager.options.cssProps, function(value, name) {\n        element.style[prefixed(element.style, name)] = add ? value : '';\n    });\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nextend(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\nif (typeof module == 'object' && module.exports) {\n    module.exports = Hammer;\n}\n/** ignored by jsdoc **/\nelse {\n    return Hammer;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/hammer.js\n// module id = 6\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util'),\n    Base = require('./base'),\n    Animate = require('./animate'),\n    Boundry = require('./boundry'),\n    Hammer = require('./hammer'),\n    Sticky = require('./components/sticky'),\n    Fixed = require('./components/fixed');\n// boundry checked bounce effect\nvar BOUNDRY_CHECK_DURATION = 500;\nvar BOUNDRY_CHECK_EASING = \"ease\";\nvar BOUNDRY_CHECK_ACCELERATION = 0.1;\n/** \n * @constructor\n * @param {object} cfg config for scroll\n * @param {number} cfg.SCROLL_ACCELERATION  acceleration for scroll, min value make the scrolling smoothly\n * @param {number} cfg.BOUNDRY_CHECK_DURATION duration for boundry bounce\n * @param {number} cfg.BOUNDRY_CHECK_EASING easing for boundry bounce\n * @param {number} cfg.BOUNDRY_CHECK_ACCELERATION acceleration for boundry bounce\n * @param {boolean} cfg.lockX just like overflow-x:hidden\n * @param {boolean} cfg.lockY just like overflow-y:hidden\n * @param {boolean} cfg.scrollbarX config if the scrollbar-x is visible\n * @param {boolean} cfg.scrollbarY config if the scrollbar-y is visible\n * @param {boolean} cfg.useTransition config if use css3 transition or raf for scroll animation\n * @param {boolean} cfg.useOriginScroll config if use simulate or origin scroll\n * @param {boolean} cfg.bounce config if use has the bounce effect when scrolling outside of the boundry\n * @param {boolean} cfg.boundryCheck config if scrolling inside of the boundry\n * @param {boolean} cfg.preventDefault prevent touchstart\n * @param {boolean} cfg.preventTouchMove prevent touchmove\n * @param {string|HTMLElement}  cfg.container config for scroller's container which default value is \".xs-container\"\n * @param {string|HTMLElement}  cfg.content config for scroller's content which default value is \".xs-content\"\n * @param {object}  cfg.indicatorInsets  config scrollbars position {top: number, left: number, bottom: number, right: number}\n * @param {string}  cfg.stickyElements config for sticky-positioned elements\n * @param {string}  cfg.fixedElements config for fixed-positioned elements\n * @param {string}  cfg.touchAction config for touchAction of the scroller\n * @extends XScroll\n * @example\n * var xscroll = new XScroll({\n *    renderTo:\"#scroll\",\n *    lockX:false,\n *    scrollbarX:true\n * });\n * xscroll.render();\n */\nfunction XScroll(cfg) {\n    XScroll.superclass.constructor.call(this);\n    this.userConfig = cfg;\n    this.init();\n}\n\nUtil.extend(XScroll, Base, {\n    /**\n     * version\n     * @memberof XScroll\n     * @type {string}\n     */\n    version: \"3.0.13\",\n    /**\n     * init scroll\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    init: function() {\n        var self = this;\n        var defaultCfg = {\n            preventDefault: true,\n            bounce: true,\n            boundryCheck: true,\n            useTransition: true,\n            gpuAcceleration: true,\n            BOUNDRY_CHECK_EASING: BOUNDRY_CHECK_EASING,\n            BOUNDRY_CHECK_DURATION: BOUNDRY_CHECK_DURATION,\n            BOUNDRY_CHECK_ACCELERATION: BOUNDRY_CHECK_ACCELERATION,\n            useOriginScroll: false,\n            zoomType: \"y\",\n            indicatorInsets: {\n                top: 3,\n                bottom: 3,\n                left: 3,\n                right: 3,\n                width: 3,\n                spacing: 5\n            },\n            container: \".xs-container\",\n            content: \".xs-content\",\n            stickyElements: \".xs-sticky\",\n            fixedElements: \".xs-fixed\",\n            touchAction: \"auto\"\n        };\n        //generate guid\n        self.guid = Util.guid();\n        self.renderTo = Util.getNode(self.userConfig.renderTo);\n        //timer for animtion\n        self.__timers = {};\n        //config attributes on element\n        var elCfg = JSON.parse(self.renderTo.getAttribute('xs-cfg'));\n        var userConfig = self.userConfig = Util.mix(Util.mix(defaultCfg, elCfg), self.userConfig);\n        self.container = Util.getNode(userConfig.container,self.renderTo);\n        self.content = Util.getNode(userConfig.content,self.renderTo);\n        self.boundry = new Boundry();\n        self.boundry.refresh();\n        return self;\n    },\n    /**\n     * destroy scroll\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    destroy: function() {\n        var self = this;\n        self.mc && self.mc.destroy();\n        self.sticky && self.sticky.destroy();\n        self.fixed && self.fixed.destroy();\n    },\n    _initContainer: function() {},\n    /**\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    enableGPUAcceleration: function() {\n        this.userConfig.gpuAcceleration = true;\n        return this;\n    },\n    /**\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    disableGPUAcceleration: function() {\n        this.userConfig.gpuAcceleration = false;\n        return this;\n    },\n    /**\n     * get scroll offset\n     * @memberof XScroll\n     * @return {Object} {scrollTop:scrollTop,scrollLeft:scrollLeft}\n     */\n    getScrollPos: function() {\n        var self = this;\n        return {\n            scrollLeft: self.getScrollLeft(),\n            scrollTop: self.getScrollTop()\n        }\n    },\n    /**\n     * get scroll top value\n     * @memberof XScroll\n     * @return {number} scrollTop\n     */\n    getScrollTop: function() {},\n    /**\n     * get scroll left value\n     * @memberof XScroll\n     * @return {number} scrollLeft\n     */\n    getScrollLeft: function() {},\n    /**\n     * scroll absolute to the destination\n     * @memberof XScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollTo: function(scrollLeft, scrollTop, duration, easing, callback) {\n        var self = this;\n        var scrollLeft = (undefined === scrollLeft || isNaN(scrollLeft)) ? -self.getScrollLeft() : scrollLeft;\n        var scrollTop = (undefined === scrollTop || isNaN(scrollTop)) ? -self.getScrollTop() : scrollTop;\n        self.scrollLeft(scrollLeft, duration, easing, callback);\n        self.scrollTop(scrollTop, duration, easing, callback);\n    },\n    /**\n     * scroll relative to the destination\n     * @memberof XScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollBy: function(scrollLeft, scrollTop, duration, easing, callback) {\n        this.scrollByX(scrollLeft, duration, easing, callback);\n        this.scrollByY(scrollTop, duration, easing, callback);\n    },\n    /**\n     * horizontal scroll relative to the destination\n     * @memberof XScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollLeftBy: function(scrollLeft, duration, easing, callback) {\n        this.scrollLeft(Number(scrollLeft) + Number(this.getScrollLeft()), duration, easing, callback);\n    },\n    /**\n     * vertical scroll relative to the destination\n     * @memberof XScroll\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollTopBy: function(scrollTop, duration, easing, callback) {\n        this.scrollTop(Number(scrollTop) + Number(this.getScrollTop()), duration, easing, callback);\n    },\n    /**\n     * horizontal scroll absolute to the destination\n     * @memberof XScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollLeft: function(scrollLeft, duration, easing, callback) {},\n    /**\n     * vertical scroll absolute to the destination\n     * @memberof XScroll\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollTop: function(scrollTop, duration, easing, callback) {},\n    /**\n     * reset the boundry size\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    resetSize: function() {\n        var self = this;\n        if(!self.container || !self.content) return;\n        var userConfig = self.userConfig;\n        var renderToStyle = getComputedStyle(self.renderTo);\n        var width = self.width = (userConfig.width || self.renderTo.offsetWidth) - Util.px2Num(renderToStyle['padding-left']) - Util.px2Num(renderToStyle['padding-right']);\n        var height = self.height = (userConfig.height || self.renderTo.offsetHeight) - Util.px2Num(renderToStyle['padding-top']) - Util.px2Num(renderToStyle['padding-bottom']);;\n        var containerWidth = userConfig.containerWidth || self.content.offsetWidth;\n        var containerHeight = userConfig.containerHeight || self.content.offsetHeight;\n        self.containerWidth = containerWidth < self.width ? self.width : containerWidth;\n        self.containerHeight = containerHeight < self.height ? self.height : containerHeight;\n        self.boundry.refresh({\n            width: self.width,\n            height: self.height\n        });\n        return self;\n    },\n    /**\n     * render scroll\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    render: function() {\n        var self = this;\n        self.resetSize();\n        //init stickies\n        self.initSticky();\n        //init fixed elements\n        self.initFixed();\n\n        self.trigger(\"afterrender\", {\n            type: \"afterrender\"\n        });\n        self._bindEvt();\n        //update touch-action \n        self.initTouchAction();\n        return self;\n    },\n    /**\n     * init touch action\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    initTouchAction: function() {\n        var self = this;\n        self.mc.set({\n            touchAction: self.userConfig.touchAction\n        });\n        return self;\n    },\n    initFixed: function() {\n        var self = this,\n            userConfig = self.userConfig;\n        self.fixed = self.fixed || new Fixed({\n            fixedElements:userConfig.fixedElements,\n            xscroll:self,\n            fixedRenderTo:userConfig.fixedRenderTo\n        });\n        self.fixed.render();\n        self.resetSize();\n        return self;\n    },\n    initSticky:function(){\n        var self = this,userConfig = self.userConfig;\n        var sticky = self.sticky = self.sticky || new Sticky({\n            xscroll:self,\n            zoomType:userConfig.zoomType,\n            stickyRenderTo:userConfig.stickyRenderTo\n        });\n        sticky.render();\n    },\n    /**\n     * bounce to the boundry vertical and horizontal\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    boundryCheck: function() {\n        return this;\n    },\n    /**\n     * bounce to the boundry horizontal\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    boundryCheckX: function() {\n        return this;\n    },\n    /**\n     * bounce to the boundry vertical\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    boundryCheckY: function() {\n        return this;\n    },\n    _bindEvt: function() {\n        var self = this;\n        if (self.___isEvtBind) return;\n        self.___isEvtBind = true;\n        var mc = self.mc = new Hammer.Manager(self.renderTo);\n        var tap = new Hammer.Tap();\n        var pan = new Hammer.Pan();\n        var pinch = new Hammer.Pinch();\n        mc.add([tap, pan]);\n        //trigger all events \n        self.mc.on(\"panstart pan panend pancancel pinchstart pinchmove pinchend pinchcancel pinchin pinchout\", function(e) {\n            self.trigger(e.type, e);\n        });\n        //trigger touch events\n        var touchEvents = ['touchstart', 'touchmove', 'touchend', 'touchcancel','mousedown'];\n        for (var i = 0, l = touchEvents.length; i < l; i++) {\n            self.renderTo.addEventListener(touchEvents[i], function(e) {\n                self.trigger(e.type, e);\n            });\n        }\n        self.mc.on(\"tap\", function(e) {\n            if (e.tapCount == 1) {\n                e.type = \"tap\";\n                self.trigger(e.type, e);\n            } else if (e.tapCount == 2) {\n                e.type = \"doubletap\";\n                self.trigger(\"doubletap\", e);\n            }\n        });\n        return self;\n    },\n    _resetLockConfig: function() {},\n    stop: function() {}\n});\n\nif (typeof module == 'object' && module.exports) {\n    module.exports = XScroll;\n}\n/** ignored by jsdoc **/\nelse {\n    return XScroll;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/core.js\n// module id = 7\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\n//easing\nvar Easing = {\n\t\"linear\": [0, 0, 1, 1],\n\t\"ease\": [.25, .1, .25, 1],\n\t\"ease-in\":[.42,0,1,1],\n\t\"ease-out\": [0, 0, .58, 1],\n\t\"ease-in-out\": [.42, 0, .58, 1],\n\t\"quadratic\": [0.33, 0.66, 0.66, 1],\n\t\"circular\": [0.1, 0.57, 0.1, 1],\n\t\"bounce\": [.71, 1.35, .47, 1.41],\n\tformat: function(easing) {\n\t\tif (!easing) return;\n\t\tif (typeof easing === \"string\" && this[easing]) {\n\t\t\treturn this[easing] instanceof Array ? [\" cubic-bezier(\", this[easing], \") \"].join(\"\") : this[easing];\n\t\t}\n\t\tif (easing instanceof Array) {\n\t\t\treturn [\" cubic-bezier(\", easing, \") \"].join(\"\");\n\t\t}\n\t\treturn easing;\n\t}\n}\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Easing;\n}\n/** ignored by jsdoc **/\n else {\n\treturn Easing;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/easing.js\n// module id = 8\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util');\nvar Base = require('./base');\nvar Easing = require('./easing');\n\nvar RAF = window.requestAnimationFrame ||\n\twindow.webkitRequestAnimationFrame ||\n\twindow.mozRequestAnimationFrame ||\n\twindow.oRequestAnimationFrame ||\n\twindow.msRequestAnimationFrame ||\n\tfunction(callback) {\n\t\twindow.setTimeout(callback, 1000 / 60);\n\t};\n\nvar vendors = ['webkit', 'moz', 'ms', 'o'];\nvar cancelRAF = window.cancelAnimationFrame;\nfor (var i = 0; i < vendors.length; i++) {\n\tif (window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame']) {\n\t\tcancelRAF = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];\n\t}\n}\ncancelRAF = cancelRAF || window.clearTimeout;\n\nfunction Bezier(x1, y1, x2, y2, epsilon) {\n\tvar curveX = function(t) {\n\t\tvar v = 1 - t;\n\t\treturn 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;\n\t};\n\n\tvar curveY = function(t) {\n\t\tvar v = 1 - t;\n\t\treturn 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;\n\t};\n\n\tvar derivativeCurveX = function(t) {\n\t\tvar v = 1 - t;\n\t\treturn 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (-t * t * t + 2 * v * t) * x2;\n\t};\n\n\treturn function(t) {\n\n\t\tvar x = t,\n\t\t\tt0, t1, t2, x2, d2, i;\n\n\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\tfor (t2 = x, i = 0; i < 8; i++) {\n\t\t\tx2 = curveX(t2) - x;\n\t\t\tif (Math.abs(x2) < epsilon) return curveY(t2);\n\t\t\td2 = derivativeCurveX(t2);\n\t\t\tif (Math.abs(d2) < 1e-6) break;\n\t\t\tt2 = t2 - x2 / d2;\n\t\t}\n\n\t\tt0 = 0, t1 = 1, t2 = x;\n\n\t\tif (t2 < t0) return curveY(t0);\n\t\tif (t2 > t1) return curveY(t1);\n\n\t\t// Fallback to the bisection method for reliability.\n\t\twhile (t0 < t1) {\n\t\t\tx2 = curveX(t2);\n\t\t\tif (Math.abs(x2 - x) < epsilon) return curveY(t2);\n\t\t\tif (x > x2) t0 = t2;\n\t\t\telse t1 = t2;\n\t\t\tt2 = (t1 - t0) * .5 + t0;\n\t\t}\n\n\t\t// Failure\n\t\treturn curveY(t2);\n\n\t};\n\n};\n\n\n\nfunction Timer(cfg) {\n\tvar self = this;\n\tself.cfg = Util.mix({\n\t\teasing: \"linear\"\n\t}, cfg)\n}\n\nTimer.MIN_DURATION = 1;\n\nUtil.extend(Timer, Base, {\n\treset: function(cfg) {\n\t\tvar self = this;\n\t\tUtil.mix(self.cfg, cfg);\n\t\tself.isfinished = false;\n\t\tself.percent = 0;\n\t\tself._stop = null;\n\t},\n\trun: function() {\n\t\tvar self = this;\n\t\tvar duration = self.cfg.duration;\n\t\tif (duration <= Timer.MIN_DURATION) {\n\t\t\tself.isfinished = true;\n\t\t\tself.trigger(\"run\", {\n\t\t\t\tpercent: 1\n\t\t\t});\n\t\t\tself.trigger(\"end\", {\n\t\t\t\tpercent: 1\n\t\t\t});\n\t\t}\n\t\tif (self.isfinished) return;\n\t\tself._hasFinishedPercent = self._stop && self._stop.percent || 0;\n\t\tself._stop = null;\n\t\tself.start = Date.now();\n\t\tself.percent = 0;\n\t\t// epsilon determines the precision of the solved values\n\t\tvar epsilon = (1000 / 60 / duration) / 4;\n\t\tvar b = Easing[self.cfg.easing];\n\t\tself.easingFn = Bezier(b[0], b[1], b[2], b[3], epsilon);\n\t\tself._run();\n\t},\n\t_run: function() {\n\t\tvar self = this;\n\t\tcancelRAF(self._raf);\n\t\tself._raf = RAF(function() {\n\t\t\tself.now = Date.now();\n\t\t\tself.duration = self.now - self.start >= self.cfg.duration ? self.cfg.duration : self.now - self.start;\n\t\t\tself.progress = self.easingFn(self.duration / self.cfg.duration);\n\t\t\tself.percent = self.duration / self.cfg.duration + self._hasFinishedPercent;\n\t\t\tif (self.percent >= 1 || self._stop) {\n\t\t\t\tself.percent = self._stop && self._stop.percent ? self._stop.percent : 1;\n\t\t\t\tself.duration = self._stop && self._stop.duration ? self._stop.duration : self.duration;\n\t\t\t\tvar param = {\n\t\t\t\t\tpercent: self.percent\n\t\t\t\t};\n\t\t\t\tself.trigger(\"stop\", param);\n\t\t\t\tif (self.percent >= 1) {\n\t\t\t\t\tself.isfinished = true;\n\t\t\t\t\tself.trigger(\"end\", {\n\t\t\t\t\t\tpercent: 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself.trigger(\"run\", {\n\t\t\t\tpercent: self.progress,\n\t\t\t\toriginPercent:self.percent\n\t\t\t});\n\t\t\tself._run();\n\t\t})\n\t},\n\tstop: function() {\n\t\tvar self = this;\n\t\tself._stop = {\n\t\t\tpercent: self.percent,\n\t\t\tnow: self.now\n\t\t};\n\t\tcancelRAF(self._raf)\n\t}\n});\n\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Timer;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Timer;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/timer.js\n// module id = 9\n// module chunks = 0","import './style.scss';\nimport './style.plug.pulldown.scss';\nimport './style.plug.pullup.scss';\n\nimport XScroll from 'xscroll/build/cmd/xscroll';\nimport XScrollPullUp from 'xscroll/build/cmd/plugins/pullup';\nimport XScrollPullDown from 'xscroll/build/cmd/plugins/pulldown';\nimport XScrollInfinite from 'xscroll/build/cmd/plugins/infinite';\nimport classNames from 'classnames';\n\nlet uid = 0;\n\nclass ReactXScroll extends React.Component{\n  static propTypes = {\n    cssClass:React.PropTypes.string,\n    xscrollOptions:React.PropTypes.object,\n    pulldownOptions:React.PropTypes.object,\n    pullupOptions:React.PropTypes.object,\n    infiniteOptions:React.PropTypes.object,\n    onRefresh:React.PropTypes.func,\n    onInfinite:React.PropTypes.func,\n  };\n\n  static defaultProps = {\n    xscrollOptions:{},\n    pulldownOptions:null,\n    pullupOptions:null,\n    infiniteOptions:null,\n    onRefresh:null,\n    onInfinite:null,\n  };\n\n  constructor(props){\n  \tsuper(props);\n    this._renderId= 'rn-xscroll-'+uid++;\n    this.state = {\n      cssClass:props.cssClass\n    }\n  }\n\n  createIscroll(){\n    let options = Object.assign({\n      renderTo:`#${this._renderId}`\n    },this.props.xscrollOptions);\n    return new XScroll(options);\n  }\n\n  createPullUpPlugin(){\n    if(this.props.pullupOptions){\n      var self=this;\n      var pullup = new XScrollPullUp(this.props.pullupOptions);\n      pullup.on('loading',function(){\n        self.props.onInfinite(self);\n      });\n      this._xscroll.plug(pullup);\n      return pullup;\n    }\n  }\n\n  createPullDownPlugin(){\n    if(this.props.pulldownOptions){\n      var self=this;\n      var pulldown = new XScrollPullDown(this.props.pulldownOptions);\n      pulldown.on('loading',function(e){\n        self.props.onRefresh(self);\n      });\n      this._xscroll.plug(pulldown);\n      return pulldown;\n    }\n  }\n\n  createInfinitePlugin(){\n    if(this.props.infiniteOptions){\n      var infinite = new XScrollInfinite(this.props.infiniteOptions);\n      this._xscroll.plug(infinite);\n      return infinite;\n    }\n  }\n\n  componentDidMount(){\n    var self = this;\n    var xscroll = this._xscroll = this.createIscroll();\n    xscroll.render();\n  }\n\n  attachPlugins(){\n    this._infinite = this.createInfinitePlugin();\n    this._pullup = this.createPullUpPlugin();\n    this._pulldown = this.createPullDownPlugin();\n    //initial once:?\n    this.props.onInfinite && this.props.onInfinite(this);\n  }\n\n  invoke(inName){\n    var args = [].slice.call(arguments, 1);\n    return this._xscroll[inName].apply(this._xscroll, args);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    this.setState(nextProps);\n  }\n\n  render(){\n    return (\n      <div id={this._renderId}\n        className={classNames('react-xscroll',this.state.cssClass)}>\n        <div className=\"xs-container\">\n          <div className=\"xs-content\">\n            {this.props.children}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\n\nexport default ReactXScroll;\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/react-xscroll.js","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".xs-plugin-pulldown-container{text-align:center;width:100%;line-height:50px}.xs-plugin-pulldown-up .up{display:inline}.xs-plugin-pulldown-down .up,.xs-plugin-pulldown-up .down{display:none}.xs-plugin-pulldown-down .down{display:inline}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/autoprefixer-loader!./~/sass-loader!./src/components/style.plug.pulldown.scss\n// module id = 11\n// module chunks = 0","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".xs-plugin-pullup-container{line-height:40px;text-align:center}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/autoprefixer-loader!./~/sass-loader!./src/components/style.plug.pullup.scss\n// module id = 12\n// module chunks = 0","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".react-xscroll{width:100%;position:absolute}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/autoprefixer-loader!./~/sass-loader!./src/components/style.scss\n// module id = 13\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/style.plug.pulldown.scss\n// module id = 14\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/style.plug.pullup.scss\n// module id = 15\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/style.scss\n// module id = 16\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\n var Util = require('./util');\n\n function Boundry(cfg) {\n     this.cfg = Util.mix({\n         width: 0,\n         height: 0\n     }, cfg)\n     this.init();\n }\n Util.mix(Boundry.prototype, {\n     init: function() {\n         var self = this;\n         self._xtop = 0;\n         self._xright = 0;\n         self._xleft = 0;\n         self._xbottom = 0;\n         self.refresh({\n             width: self.cfg.width,\n             height: self.cfg.height\n         });\n     },\n     reset: function() {\n         this.resetTop();\n         this.resetLeft();\n         this.resetBottom();\n         this.resetRight();\n         return this;\n     },\n     resetTop: function() {\n         this._xtop = 0;\n         this.refresh();\n         return this;\n     },\n     resetLeft: function() {\n         this._xleft = 0;\n         this.refresh();\n         return this;\n     },\n     resetBottom: function() {\n         this._xbottom = 0;\n         this.refresh();\n         return this;\n     },\n     resetRight: function() {\n         this._xright = 0;\n         this.refresh();\n         return this;\n     },\n     expandTop: function(top) {\n         this._xtop = top;\n         this.refresh();\n         return this;\n     },\n     expandLeft: function(left) {\n         this._xleft = left;\n         this.refresh();\n         return this;\n     },\n     expandRight: function(right) {\n         this._xright = right;\n         this.refresh();\n         return this;\n     },\n     expandBottom: function(bottom) {\n         this._xbottom = bottom;\n         this.refresh();\n         return this;\n     },\n     refresh: function(cfg) {\n         Util.mix(this.cfg, cfg);\n         this.top = this._xtop;\n         this.left = this._xleft;\n         this.bottom = (cfg && cfg.height || this.cfg.height || 0) - this._xbottom;\n         this.right = (cfg && cfg.width || this.cfg.width || 0) - this._xright;\n         this.width = this.right - this.left > 0 ? this.right - this.left : 0;\n         this.height = this.bottom - this.top > 0 ? this.bottom - this.top : 0;\n         return this;\n     }\n });\n\n\n if (typeof module == 'object' && module.exports) {\n     module.exports = Boundry;\n }\n /** ignored by jsdoc **/\n else{\n    return Boundry;\n }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/boundry.js\n// module id = 17\n// module chunks = 0","define(function(require, exports, module) {\n/*\n\twrapped scroll controller\n*/\n\"use strict\";\nvar Util = require('../util'),\n\tBase = require('../base');\n\nvar Controller = function(cfg) {\n\tController.superclass.constructor.call(this, cfg);\n\tthis.userConfig = Util.mix({}, cfg);\n\tthis.init();\n}\n\nUtil.extend(Controller, Base, {\n\tinit: function() {\n\t\tvar self = this;\n\t\tself.xscroll = self.userConfig.xscroll;\n\t},\n\tadd: function(scroll, cfg) {\n\t\tvar self = this;\n\t\tcfg = Util.extend({\n\t\t\tcaptureBounce: false,\n\t\t\tstopPropagation: true\n\t\t}, cfg)\n\t\tif (!self.__scrolls) {\n\t\t\tself.__scrolls = {};\n\t\t}\n\t\tif (scroll.guid && !self.__scrolls[scroll.guid]) {\n\t\t\tscroll.parentscroll = self.xscroll;\n\t\t\tself._bind(scroll);\n\t\t\treturn self.__scrolls[scroll.guid] = scroll;\n\t\t}\n\t\treturn;\n\t},\n\tremove: function(scroll) {\n\t\tvar self = this;\n\t\tif (!scroll || !scroll.guid) return;\n\t\tvar subscroll = self.__scrolls[scroll.guid];\n\t\tif (subscroll) {\n\t\t\tsubscroll.parentscroll = null;\n\t\t\tself._unbind(scroll);\n\t\t\tsubscroll = null;\n\t\t}\n\t},\n\tget: function(guid) {\n\t\tif (guid) {\n\t\t\treturn this.__scrolls[guid];\n\t\t}\n\t\treturn this.__scrolls;\n\t},\n\n\t_unbind: function(sub) {\n\n\t},\n\n\t_bind: function(sub) {\n\t\tvar self = this,\n\t\t\txscroll = self.xscroll;\n\t\txscroll.renderTo.addEventListener(\"touchstart\", function() {\n\t\t\txscroll._resetLockConfig();\n\t\t});\n\t\tsub.renderTo.addEventListener(\"touchstart\", function() {\n\t\t\tsub._resetLockConfig();\n\t\t});\n\t\txscroll.on(\"panend\", xscroll._resetLockConfig);\n\t\tsub.on(\"panend\", sub._resetLockConfig);\n\t\tsub.on(\"panstart\", function(e) {\n\t\t\t//vertical scroll enabled\n\t\t\tif (!sub.userConfig.lockY && !xscroll.userConfig.lockY) {\n\t\t\t\t//outside of boundry\n\t\t\t\tif (sub.isBoundryOut()) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (e.direction == 16 && sub.getBoundryOutTop() >= 0) {\n\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t} else if (e.direction == 8 && sub.getBoundryOutTop() >= 0 && sub.getBoundryOutBottom() < 0) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t}\n\t\t\t\tif (e.direction == 8 && sub.getBoundryOutBottom() >= 0) {\n\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t} else if (e.direction == 16 && sub.getBoundryOutBottom() >= 0 && sub.getBoundryOutTop() < 0) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t}\n\t\t\t\tif (sub.getBoundryOutTop() < 0 && sub.getBoundryOutBottom() < 0) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//horizontal scroll enabled\n\t\t\tif (!sub.userConfig.lockX && !xscroll.userConfig.lockX) {\n\t\t\t\tif (sub.isBoundryOut()) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (e.direction == 4 && sub.getBoundryOutLeft() >= 0) {\n\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t} else if (e.direction == 2 && sub.getBoundryOutLeft() >= 0 && sub.getBoundryOutRight() < 0) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t}\n\t\t\t\tif (e.direction == 2 && sub.getBoundryOutRight() >= 0) {\n\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t} else if (e.direction == 4 && sub.getBoundryOutRight() >= 0 && sub.getBoundryOutLeft() < 0) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t}\n\t\t\t\tif (sub.getBoundryOutLeft() < 0 && sub.getBoundryOutRight() < 0) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!sub.userConfig.lockX && xscroll.userConfig.lockX) {\n\t\t\t\t//pan x\n\t\t\t\tif (e.direction == 2 || e.direction == 4) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t} else {\n\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!sub.userConfig.lockY && xscroll.userConfig.lockY) {\n\t\t\t\t//pan y\n\t\t\t\tif (e.direction == 8 || e.direction == 16) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t} else {\n\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Controller;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Controller;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/components/controller.js\n// module id = 18\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Base = require('../base');\nvar transform = Util.prefixStyle(\"transform\");\n\nvar Fixed = function(cfg) {\n  Fixed.superclass.constructor.call(this, cfg);\n  this.userConfig = Util.mix({\n    fixedRenderTo: undefined,\n    fixedElements: \".xs-fixed\",\n    prefix: \"xs-fixed-container\",\n    zoomType: \"y\"\n  }, cfg);\n  this.init();\n}\n\nUtil.extend(Fixed, Base, {\n  fixedElements: [],\n  init: function() {\n    var self = this,\n      userConfig = self.userConfig,\n      xscroll = self.xscroll = userConfig.xscroll,\n      xscrollConfig = self.xscrollConfig = xscroll.userConfig;\n    self.isY = !!(userConfig.zoomType == \"y\");\n    self._ = self.isY ? {\n      top: \"top\",\n      height: \"height\",\n      width: \"width\",\n      offsetTop:\"offsetTop\"\n    } : {\n      top: \"left\",\n      height: \"width\",\n      width: \"height\",\n      offsetTop:\"offsetLeft\"\n    };\n    self.fixedRenderTo = Util.getNode(userConfig.fixedRenderTo);\n    return self;\n  },\n  render: function() {\n    var self = this;\n    var xscroll = self.xscroll;\n    self.infinite = xscroll.getPlugin(\"infinite\");\n    if (!self.fixedRenderTo) {\n      self.fixedRenderTo = document.createElement('div');\n      xscroll.renderTo.appendChild(self.fixedRenderTo);\n    }\n    Util.addClass(self.fixedRenderTo, self.userConfig.prefix);\n    var originalFixedElements = self.originalFixedElements = self.getFixedElements();\n    for (var i = 0, l = originalFixedElements.length; i < l; i++) {\n      self.renderFixedElement(originalFixedElements[i], i,self.fixedRenderTo);\n    }\n    return self;\n  },\n  getFixedElements: function() {\n    var self = this;\n    var infinite = self.infinite;\n    var userConfig = self.userConfig;\n    if (infinite) {\n      var els = [];\n      for (var i in infinite.__serializedData) {\n        var data = infinite.__serializedData[i];\n        if (data && data.style && data.style.position == \"fixed\") {\n          els.push(data);\n        }\n      }\n      return els;\n    } else {\n      return Util.getNodes(userConfig.fixedElements, self.xscroll.content);\n    }\n  },\n  renderFixedElement: function(el, fixedIndex,fixedRenderTo) {\n    var self = this;\n    var isRender = true;\n    var _ = self._;\n    var xscroll = self.xscroll;\n    var userConfig = self.userConfig;\n    var xscrollConfig = self.xscrollConfig;\n    var useOriginScroll = xscrollConfig.useOriginScroll;\n    var infinite = self.infinite;\n    var fixedElement = self.fixedElements[fixedIndex];\n    if (!self.fixedElements[fixedIndex]) {\n      isRender = false;\n      if (useOriginScroll && !infinite) {\n        //use original position:fixed stylesheet\n        el.style.position = \"fixed\";\n        el.style.display = \"block\";\n      } else {\n        //deep clone fixed nodes and hide original nodes\n        fixedElement = document.createElement(\"div\");\n        if (infinite) {\n          fixedElement.setAttribute(\"style\", Util.stringifyStyle(Util.mix(el.style, {\n            display: \"block\",\n            width: \"100%\"\n          })));\n          fixedElement.style[_.top] = (el.style[_.top] >= 0 ? el.style[_.top] : el._top) + \"px\";\n          if (el.style[_.height]) {\n            fixedElement.style[_.height] = el.style[_.height] + \"px\";\n          }\n          infinite.userConfig.renderHook.call(self, fixedElement, el);\n        } else {\n          fixedElement.style.display = \"block\";\n          fixedElement.style.position = \"absolute\";\n          fixedElement.style[_.width] = \"100%\";\n          fixedElement.innerHTML = el.innerHTML;\n          fixedElement.className = el.className;\n          fixedElement.setAttribute(\"style\", el.getAttribute(\"style\"));\n          fixedElement.style[_.top] = el[_.offsetTop] + \"px\";\n          el.style.display = \"none\";\n        }\n        fixedRenderTo.appendChild(fixedElement);\n        self.fixedElements.push(fixedElement);\n      }\n    }\n    xscroll.trigger(\"fixedchange\", {\n      fixedIndex: fixedIndex,\n      fixedElement: useOriginScroll ? el : fixedElement,\n      originalFixedElement: el,\n      isRender: isRender\n    });\n  },\n  destroy: function() {\n    var self = this;\n    self.fixedElements = undefined;\n  }\n});\n\nif (typeof module == 'object' && module.exports) {\n  module.exports = Fixed;\n}\n/** ignored by jsdoc **/\nelse {\n  return Fixed;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/components/fixed.js\n// module id = 19\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Animate = require('../animate');\nvar MAX_BOUNCE_DISTANCE = 40;\nvar MIN_BAR_SCROLLED_SIZE = 10;\nvar MIN_BAR_SIZE = 50;\nvar transform = Util.prefixStyle(\"transform\");\nvar transformStr = Util.vendor ? [\"-\", Util.vendor, \"-transform\"].join(\"\") : \"transform\";\nvar transition = Util.prefixStyle(\"transition\");\nvar borderRadius = Util.prefixStyle(\"borderRadius\");\nvar transitionDuration = Util.prefixStyle(\"transitionDuration\");\n\nvar ScrollBar = function(cfg) {\n\tthis.userConfig = Util.mix({\n\t\tMIN_BAR_SCROLLED_SIZE:MIN_BAR_SCROLLED_SIZE,\n\t\tMIN_BAR_SIZE:MIN_BAR_SIZE,\n\t\tMAX_BOUNCE_DISTANCE:MAX_BOUNCE_DISTANCE,\n\t\tspacing:5\n\t}, cfg);\n\tthis.init(cfg.xscroll);\n}\n\nUtil.mix(ScrollBar.prototype, {\n\tinit: function(xscroll) {\n\t\tvar self = this;\n\t\tself.xscroll = xscroll;\n\t\tself.type = self.userConfig.type;\n\t\tself.isY = self.type == \"y\" ? true : false;\n\t\tself.scrollTopOrLeft = self.isY ? \"scrollTop\" : \"scrollLeft\";\n\t},\n\tdestroy: function() {\n\t\tvar self = this;\n\t\tUtil.remove(self.scrollbar);\n\t\tself.xscroll.off(\"scroll\", self._scrollHandler, self);\n\t\tself.xscroll.off(\"scrollend\", self._scrollEndHandler, self);\n\t},\n\trender: function() {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar boundry = xscroll.boundry;\n\t\tvar indicatorInsets = self.xscroll.userConfig.indicatorInsets;\n\t\tvar translateZ = xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\tvar transform = translateZ ? transformStr + \":\" + translateZ + \";\" : \"\";\n\t\tvar commonCss = \"opacity:0;position:absolute;z-index:999;overflow:hidden;-webkit-border-radius:3px;-moz-border-radius:3px;-o-border-radius:3px;\" + transform;\n\t\tindicatorInsets._xright =  indicatorInsets.right + indicatorInsets.spacing;\n\t\tindicatorInsets._xbottom =  indicatorInsets.bottom + indicatorInsets.spacing;\n\t\tvar css = self.isY ?\n\t\t\tUtil.substitute(\"width:{width}px;bottom:{_xbottom}px;top:{top}px;right:{right}px;\", indicatorInsets) + commonCss :\n\t\t\tUtil.substitute(\"height:{width}px;left:{left}px;right:{_xright}px;bottom:{bottom}px;\",indicatorInsets) + commonCss;\n\t\t\n\n\t\tif(!self.scrollbar){\n\t\t\tself.scrollbar = document.createElement(\"div\");\t\n\t\t\tself.indicate = document.createElement(\"div\");\n\t\t\txscroll.renderTo.appendChild(self.scrollbar);\n\t\t\tself.scrollbar.appendChild(self.indicate);\n\t\t}\n\t\tself.scrollbar.style.cssText = css;\n\t\tvar size = self.isY ? \"width:100%;\" : \"height:100%;\";\n\t\tself.indicate.style.cssText = size + \"position:absolute;background:rgba(0,0,0,0.3);-webkit-border-radius:3px;-moz-border-radius:3px;-o-border-radius:3px;\"\n\t\tself._update();\n\t\tself.hide(0);\n\t\tself._bindEvt();\n\t},\n\t_update: function(pos, duration, easing, callback) {\n\t\tvar self = this;\n\t\tvar pos = undefined === pos ? (self.isY ? self.xscroll.getScrollTop() : self.xscroll.getScrollLeft()) : pos;\n\t\tvar barInfo = self.computeScrollBar(pos);\n\t\tvar size = self.isY ? \"height\" : \"width\";\n\t\tself.indicate.style[size] = Math.round(barInfo.size) + \"px\";\n\t\tif (duration && easing) {\n\t\t\tself.scrollTo(barInfo.pos, duration, easing, callback);\n\t\t} else {\n\t\t\tself.moveTo(barInfo.pos);\n\t\t}\n\t},\n\t//compute the position and size of the scrollbar\n\tcomputeScrollBar: function(pos) {\n\t\tvar self = this;\n\t\tvar type = self.isY ? \"y\" : \"x\";\n\t\tvar spacing = self.userConfig.spacing;\n\t\tvar xscroll = self.xscroll;\n\t\tvar boundry = xscroll.boundry;\n\t\tvar userConfig = self.userConfig;\n\t\tvar pos = self.isY ? Math.round(pos) + boundry._xtop : Math.round(pos) + boundry._xleft;\n\t\tvar MIN_BAR_SCROLLED_SIZE = userConfig.MIN_BAR_SCROLLED_SIZE;\n\t\tvar MIN_BAR_SIZE = userConfig.MIN_BAR_SIZE;\n\t\tvar MAX_BOUNCE_DISTANCE = userConfig.MAX_BOUNCE_DISTANCE;\n\t\tself.containerSize = self.isY ? xscroll.containerHeight + boundry._xtop + boundry._xbottom : self.xscroll.containerWidth + boundry._xright + boundry._xleft;\n\t\tself.size = self.isY ? boundry.cfg.height : boundry.cfg.width;\n\t\tself.indicateSize = self.isY ? boundry.cfg.height - spacing * 2 : boundry.cfg.width - spacing * 2;\n\t\tvar indicateSize = self.indicateSize;\n\t\tvar containerSize = self.containerSize;\n\t\tvar barPos = indicateSize * pos / containerSize;\n\t\tvar barSize = Math.round(indicateSize * self.size / containerSize);\n\t\tvar overTop = self.isY ? xscroll.getBoundryOutTop() : xscroll.getBoundryOutLeft();\n\t\tvar overBottom = self.isY ? xscroll.getBoundryOutBottom() : xscroll.getBoundryOutRight();\n\t\tvar barShiftSize = MIN_BAR_SIZE - barSize > 0 ? MIN_BAR_SIZE - barSize : 0;\n\t\tbarSize = barSize < MIN_BAR_SIZE ? MIN_BAR_SIZE : barSize;\n\t\tbarPos = (indicateSize - barShiftSize) * pos / containerSize;\n\t\tif (overTop >= 0) {\n\t\t\tvar pct = overTop / MAX_BOUNCE_DISTANCE;\n\t\t\tpct = pct > 1 ? 1 : pct;\n\t\t\tbarPos = - pct * (barSize -  MIN_BAR_SCROLLED_SIZE)\n\t\t}\n\t\tif (overBottom >= 0) {\n\t\t\tvar pct = overBottom / MAX_BOUNCE_DISTANCE;\n\t\t\tpct = pct > 1 ? 1 : pct;\n\t\t\tbarPos = pct * (barSize - MIN_BAR_SCROLLED_SIZE) + indicateSize - barSize; \n\t\t}\n\t\tself.barPos = Math.round(barPos);\n\t\treturn {\n\t\t\tsize: Math.round(barSize),\n\t\t\tpos: self.barPos\n\t\t};\n\t},\n\tscrollTo: function(pos, duration, easing, callback) {\n\t\tvar self = this;\n\t\tself.show();\n\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\tvar config = {\n\t\t\tcss: {\n\t\t\t\ttransform: self.isY ? \"translateY(\" + pos + \"px)\" + translateZ : \"translateX(\" + pos + \"px)\" + translateZ\n\t\t\t},\n\t\t\tduration: duration,\n\t\t\teasing: easing,\n\t\t\tuseTransition: self.xscroll.userConfig.useTransition,\n\t\t\tend: callback\n\t\t};\n\t\tself.__timer = self.__timer || new Animate(self.indicate, config);\n\t\t//run\n\t\tself.__timer.stop();\n\t\tself.__timer.reset(config);\n\t\tself.__timer.run();\n\t},\n\tmoveTo: function(pos) {\n\t\tvar self = this;\n\t\tself.show();\n\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\tself.isY ? self.indicate.style[transform] = \"translateY(\" + pos + \"px) \" + translateZ : self.indicate.style[transform] = \"translateX(\" + pos + \"px) \" + translateZ\n\t\tself.indicate.style[transition] = \"\";\n\t},\n\t_scrollHandler: function(e) {\n\t\tvar self = this;\n\t\tself._update(e[self.scrollTopOrLeft]);\n\t\treturn self;\n\t},\n\tisBoundryOut: function() {\n\t\tvar self = this;\n\t\treturn !self.isY ? (self.xscroll.isBoundryOutLeft() || self.xscroll.isBoundryOutRight()) : (self.xscroll.isBoundryOutTop() || self.xscroll.isBoundryOutBottom());\n\t},\n\t_scrollEndHandler: function(e) {\n\t\tvar self = this;\n\t\tif (!self.isBoundryOut()) {\n\t\t\tself._update(e[self.scrollTopOrLeft]);\n\t\t\tself.hide();\n\t\t}\n\t\treturn self;\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tif (self.__isEvtBind) return;\n\t\tself.__isEvtBind = true;\n\t\tself.xscroll.on(\"scroll\", self._scrollHandler, self);\n\t\tself.xscroll.on(\"scrollend\", self._scrollEndHandler, self);\n\t},\n\treset: function() {\n\t\tvar self = this;\n\t\tself.pos = 0;\n\t\tself._update();\n\t},\n\thide: function(duration, easing, delay) {\n\t\tvar self = this;\n\t\tvar duration = duration >= 0 ? duration : 300;\n\t\tvar easing = easing || \"ease-out\";\n\t\tvar delay = delay >= 0 ? delay : 100;\n\t\tself.scrollbar.style.opacity = 0;\n\t\tself.scrollbar.style[transition] = [\"opacity \", duration, \"ms \", \" ease-out \", delay, \"ms\"].join(\"\");\n\t},\n\tshow: function() {\n\t\tvar self = this;\n\t\tself.scrollbar.style.opacity = 1;\n\t\tself.scrollbar.style[transition] = \"\";\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = ScrollBar;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn ScrollBar;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/components/scrollbar.js\n// module id = 20\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Base = require('../base');\n//transform\nvar transform = Util.prefixStyle(\"transform\");\n// default render function for position:sticky elements\nvar defaultStickyRenderFunc = function(e) {\n  var stickyElement = e.stickyElement;\n  var curStickyElement = e.curStickyElement;\n  var xscroll = e.xscroll;\n  var _ = e._;\n  var infinite = xscroll.getPlugin(\"infinite\");\n  if (infinite) {\n    infinite.userConfig.renderHook.call(self, stickyElement, curStickyElement);\n    stickyElement.setAttribute(\"xs-guid\", curStickyElement.guid);\n    Util.addClass(stickyElement, curStickyElement.className);\n    for (var attrName in curStickyElement.style) {\n      if (attrName != \"display\" && attrName != \"position\") {\n        //copy styles\n        stickyElement.style[attrName] = attrName == _.height ? curStickyElement.style[attrName] + 'px' : curStickyElement.style[attrName];\n      }\n    }\n  } else {\n    var style = curStickyElement.getAttribute(\"style\");\n    stickyElement.innerHTML = curStickyElement.innerHTML;\n    stickyElement.className = curStickyElement.className;\n    style && stickyElement.setAttribute(\"style\", style);\n  }\n}\n\nvar Sticky = function(cfg) {\n  Sticky.superclass.constructor.call(this, cfg);\n  this.userConfig = Util.mix({\n    stickyRenderTo: undefined,\n    forceSticky: true,\n    prefix: \"xs-sticky-container\",\n    stickyRenderFunc: defaultStickyRenderFunc,\n    zoomType: \"y\"\n  }, cfg);\n  this.init();\n}\n\nUtil.extend(Sticky, Base, {\n  init: function() {\n    var self = this,\n      userConfig = self.userConfig,\n      xscroll = self.xscroll = userConfig.xscroll;\n    var isY = self.isY = !!(userConfig.zoomType == \"y\");\n    self._ = {\n      top: self.isY ? \"top\" : \"left\",\n      left: self.isY ? \"left\" : \"bottom\",\n      right: self.isY ? \"right\" : \"top\",\n      height: self.isY ? \"height\" : \"width\",\n      width: self.isY ? \"width\" : \"height\"\n    };\n    self.stickyRenderTo = Util.getNode(userConfig.stickyRenderTo);\n    self._handlers = [];\n    return self;\n  },\n  getStickiesPos: function() {\n    var self = this;\n    var xscroll = self.xscroll;\n    var isInfinite = self.isInfinite;\n    var isY = self.isY;\n    var _ = self._;\n    var stickiesPos = [];\n    var getPos = function(sticky) {\n      var pos = {};\n      if (isInfinite) {\n        pos[_.top] = isY ? sticky._top : sticky._left;\n        pos[_.height] = isY ? sticky._height : sticky._width;\n      } else {\n        pos[_.top] = self.isY ? Util.getOffsetTop(sticky) : Util.getOffsetLeft(sticky);\n        pos[_.height] = self.isY ? sticky.offsetHeight : sticky.offsetWidth;\n      }\n      return pos;\n    }\n    for (var i = 0; i < self.stickiesNum; i++) {\n      var pos = getPos(self.stickyElements[i]);\n      self._handlers[i] = self._handlers[i] || self.createStickyEl();\n      pos.el = self._handlers[i];\n      pos.isRender = false;\n      stickiesPos.push(pos);\n    }\n    return stickiesPos\n  },\n  getStickyElements: function() {\n    var self = this;\n    var xscroll = self.xscroll;\n    var userConfig = self.userConfig;\n    var isInfinite = self.isInfinite;\n    var infinite = xscroll.getPlugin(\"infinite\");\n    if (infinite) {\n      var stickyElements = [],\n        serializedData = infinite.__serializedData;\n      for (var i in serializedData) {\n        var rowData = serializedData[i];\n        if (rowData && rowData.style && \"sticky\" == rowData.style.position) {\n          stickyElements.push(rowData);\n        }\n      }\n      return stickyElements;\n    } else {\n      return Util.getNodes(xscroll.userConfig.stickyElements, xscroll.content);\n    }\n  },\n  render: function(force) {\n    var self = this;\n    var userConfig = self.userConfig;\n    var xscroll = self.xscroll;\n    self.isInfinite = !!xscroll.getPlugin(\"infinite\");\n    var _ = self._;\n    self.stickyElements = self.getStickyElements();\n    self.stickiesNum = self.stickyElements && self.stickyElements.length;\n    if (!self.stickiesNum) return;\n    if (!self.stickyRenderTo) {\n      self.stickyRenderTo = document.createElement('div');\n      xscroll.renderTo.appendChild(self.stickyRenderTo);\n    }\n    self.stickiesPos = self.getStickiesPos();\n    var stickyRenderTo = self.stickyRenderTo;\n    stickyRenderTo.style[_.top] = 0;\n    stickyRenderTo.style[_.left] = 0;\n    stickyRenderTo.style[_.right] = 0;\n    stickyRenderTo.style.position = xscroll.userConfig.useOriginScroll ? \"fixed\" : \"absolute\";\n    Util.addClass(self.stickyRenderTo, userConfig.prefix);\n    self.stickyHandler(force);\n    self._bindEvt();\n  },\n  createStickyEl: function() {\n    var self = this;\n    var el = document.createElement('div');\n    el.style.display = \"none\";\n    Util.addClass(el, \"xs-sticky-handler\");\n    self.stickyRenderTo.appendChild(el);\n    return el;\n  },\n  _bindEvt: function() {\n    var self = this,\n      xscroll = self.xscroll;\n    xscroll.on(\"scroll\", self.stickyHandler, self);\n  },\n  stickyHandler: function(force) {\n    var self = this;\n    var xscroll = self.xscroll;\n    var userConfig = self.userConfig;\n    var scrollTop = self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft();\n    var stickiesPos = self.stickiesPos;\n    var _ = self._;\n    var indexes = [];\n    for (var i = 0, l = stickiesPos.length; i < l; i++) {\n      var top = stickiesPos[i][_.top];\n      if (scrollTop > top) {\n        indexes.push(i);\n      }\n    }\n    if (!indexes.length) {\n      if (self.stickyElement) {\n        self.stickyElement.style.display = \"none\";\n      }\n      self.curStickyIndex = undefined;\n      return;\n    }\n\n    var curStickyIndex = Math.max.apply(null, indexes);\n    if (self.curStickyIndex != curStickyIndex || force) {\n      var prevStickyIndex = self.curStickyIndex;\n      self.curStickyIndex = curStickyIndex;\n      self.curStickyElement = self.stickyElements[curStickyIndex];\n      self.curStickyPos = stickiesPos[curStickyIndex];\n      self.stickyElement = self.curStickyPos.el;\n      for (var i = 0, l = stickiesPos.length; i < l; i++) {\n        stickiesPos[i].el.style.display = \"none\";\n      }\n      var eventsObj = {\n        stickyElement: self.stickyElement,\n        curStickyIndex: self.curStickyIndex,\n        prevStickyIndex: prevStickyIndex,\n        curStickyPos: self.curStickyPos,\n        isRender: self.curStickyPos.isRender\n      };\n      xscroll.trigger(\"beforestickychange\", eventsObj);\n      self._stickyRenderFunc(self);\n      xscroll.trigger(\"stickychange\", eventsObj);\n    }\n\n    var trans = 0;\n    if (self.stickiesPos[self.curStickyIndex + 1]) {\n      var cur = self.stickiesPos[self.curStickyIndex];\n      var next = self.stickiesPos[self.curStickyIndex + 1];\n      if (scrollTop + cur[_.height] > next[_.top] && scrollTop + cur[_.height] < next[_.top] + cur[_.height]) {\n        trans = cur[_.height] + scrollTop - next[_.top];\n      } else {\n        trans = 0;\n      }\n    }\n    self.stickyElement.style[transform] = self.isY ? \"translateY(-\" + (trans) + \"px) translateZ(0)\" : \"translateX(-\" + (trans) + \"px) translateZ(0)\";\n  },\n  _stickyRenderFunc: function(e) {\n    var self = this;\n    var _ = self._;\n    var stickyRenderFunc = self.userConfig.stickyRenderFunc;\n    var el = self.curStickyPos.el;\n    if (!self.curStickyPos.isRender) {\n      el.style[_.left] = 0;\n      el.style[_.right] = 0;\n      stickyRenderFunc && stickyRenderFunc.call(self, e);\n    }\n    el.style.display = \"block\";\n    self.curStickyPos.isRender = true;\n  },\n  destroy: function() {\n    var self = this;\n    self.stickyElements = undefined;\n    self.stickiesNum = undefined;\n    self.stickiesPos = undefined;\n    Util.remove(self.stickyElement);\n    self.stickyElement = undefined;\n  }\n});\n\nif (typeof module == 'object' && module.exports) {\n  module.exports = Sticky;\n}\n/** ignored by jsdoc **/\nelse {\n  return Sticky;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/components/sticky.js\n// module id = 21\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util');\n// Returns a function that will be executed at most one time, no matter how\n// often you call it. Useful for lazy initialization.\nvar _once = function(func) {\n  var ran = false,\n    memo;\n  return function() {\n    if (ran) return memo;\n    ran = true;\n    memo = func.apply(this, arguments);\n    func = null;\n    return memo;\n  };\n};\n\n\n/**\n * @discription events\n * @mixin\n */\nvar Events = {\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  on: function(name, callback, context) {\n    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n    this._events || (this._events = {});\n    var events = this._events[name] || (this._events[name] = []);\n    events.push({\n      callback: callback,\n      context: context,\n      ctx: context || this\n    });\n    return this;\n  },\n\n\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, it will be removed.\n  once: function(name, callback, context) {\n    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n    var self = this;\n    var once = _once(function() {\n      self.off(name, once);\n      callback.apply(this, arguments);\n    });\n    once._callback = callback;\n    return this.on(name, once, context);\n  },\n\n  // Remove one or many callbacks. If `context` is null, removes all\n  // callbacks with that function. If `callback` is null, removes all\n  // callbacks for the event. If `name` is null, removes all bound\n  // callbacks for all events.\n  off: function(name, callback, context) {\n    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n\n    // Remove all callbacks for all events.\n    if (!name && !callback && !context) {\n      this._events = void 0;\n      return this;\n    }\n\n    var names = name ? [name] : Object.keys(this._events);\n    for (var i = 0, length = names.length; i < length; i++) {\n      name = names[i];\n\n      // Bail out if there are no events stored.\n      var events = this._events[name];\n      if (!events) continue;\n\n      // Remove all callbacks for this event.\n      if (!callback && !context) {\n        delete this._events[name];\n        continue;\n      }\n\n      // Find any remaining events.\n      var remaining = [];\n      for (var j = 0, k = events.length; j < k; j++) {\n        var event = events[j];\n        if (\n          callback && callback !== event.callback &&\n          callback !== event.callback._callback ||\n          context && context !== event.context\n        ) {\n          remaining.push(event);\n        }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length) {\n        this._events[name] = remaining;\n      } else {\n        delete this._events[name];\n      }\n    }\n\n    return this;\n  },\n\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  trigger: function(name) {\n    if (!this._events) return this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (!eventsApi(this, 'trigger', name, args)) return this;\n    var events = this._events[name];\n    var allEvents = this._events.all;\n    if (events) triggerEvents(events, args);\n    if (allEvents) triggerEvents(allEvents, arguments);\n    return this;\n  },\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  listenTo: function(obj, name, callback) {\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var id = obj._listenId || (obj._listenId = Util.guid('l'));\n    listeningTo[id] = obj;\n    if (!callback && typeof name === 'object') callback = this;\n    obj.on(name, callback, this);\n    return this;\n  },\n\n  listenToOnce: function(obj, name, callback) {\n    if (typeof name === 'object') {\n      for (var event in name) this.listenToOnce(obj, event, name[event]);\n      return this;\n    }\n    var cb = _once(function() {\n      this.stopListening(obj, name, cb);\n      callback.apply(this, arguments);\n    });\n    cb._callback = callback;\n    return this.listenTo(obj, name, cb);\n  },\n\n  // Tell this object to stop listening to either specific events ... or\n  // to every object it's currently listening to.\n  stopListening: function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n    var remove = !name && !callback;\n    if (!callback && typeof name === 'object') callback = this;\n    if (obj)(listeningTo = {})[obj._listenId] = obj;\n    for (var id in listeningTo) {\n      obj = listeningTo[id];\n      obj.off(name, callback, this);\n      if (remove || Util.isEmpty(obj._events)) delete this._listeningTo[id];\n    }\n    return this;\n  }\n\n};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n// Implement fancy features of the Events API such as multiple event\n// names `\"change blur\"` and jQuery-style event maps `{change: action}`\n// in terms of the existing API.\nvar eventsApi = function(obj, action, name, rest) {\n  if (!name) return true;\n\n  // Handle event maps.\n  if (typeof name === 'object') {\n    for (var key in name) {\n      obj[action].apply(obj, [key, name[key]].concat(rest));\n    }\n    return false;\n  }\n\n  // Handle space separated event names.\n  if (eventSplitter.test(name)) {\n    var names = name.split(eventSplitter);\n    for (var i = 0, length = names.length; i < length; i++) {\n      obj[action].apply(obj, [names[i]].concat(rest));\n    }\n    return false;\n  }\n\n  return true;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\nvar triggerEvents = function(events, args) {\n  var ev, i = -1,\n    l = events.length,\n    a1 = args[0],\n    a2 = args[1],\n    a3 = args[2];\n  switch (args.length) {\n    case 0:\n      while (++i < l)(ev = events[i]).callback.call(ev.ctx);\n      return;\n    case 1:\n      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1);\n      return;\n    case 2:\n      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);\n      return;\n    case 3:\n      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n      return;\n    default:\n      while (++i < l)(ev = events[i]).callback.apply(ev.ctx, args);\n      return;\n  }\n};\n\n// Aliases for backwards compatibility.\nEvents.bind = Events.on;\nEvents.unbind = Events.off;\n\nif (typeof module == 'object' && module.exports) {\n  module.exports = Events;\n}\n/** ignored by jsdoc **/\nelse {\n  return Events;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/events.js\n// module id = 22\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util'),\n    Base = require('./base'),\n    Core = require('./core'),\n    Animate = require('./animate');\n\nvar transformOrigin = Util.prefixStyle(\"transformOrigin\");\n/** \n * @constructor\n * @param {object} cfg config for scroll\n * @extends XScroll\n * @example\n * var xscroll = new OriginScroll({\n *    renderTo:\"#scroll\"\n * });\n * xscroll.render();\n */\nfunction OriginScroll(cfg) {\n    OriginScroll.superclass.constructor.call(this, cfg);\n}\n\nUtil.extend(OriginScroll, Core, {\n    init: function() {\n        var self = this;\n        OriginScroll.superclass.init.call(this);\n        self.resetSize();\n    },\n    /**\n     * get scroll top value\n     * @memberof OriginScroll\n     * @return {number} scrollTop\n     */\n    getScrollTop: function() {\n        return this.renderTo.scrollTop;\n    },\n    /**\n     * get scroll left value\n     * @memberof OriginScroll\n     * @return {number} scrollLeft\n     */\n    getScrollLeft: function() {\n        return this.renderTo.scrollLeft;\n    },\n    /**\n     * vertical scroll absolute to the destination\n     * @memberof SimuScroll\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollTop: function(y, duration, easing, callback) {\n        var self = this;\n        var y = Math.round(y);\n        if (self.userConfig.lockY) return;\n        var duration = duration || 0;\n        var easing = easing || \"quadratic\";\n        var config = {\n            css: {\n                scrollTop: y\n            },\n            duration: duration,\n            easing: easing,\n            run: function(e) {\n                //trigger scroll event\n                self.trigger(\"scroll\", {\n                    scrollTop: self.getScrollTop(),\n                    scrollLeft: self.getScrollLeft()\n                });\n            },\n            useTransition: false, //scrollTop \n            end: callback\n        };\n        self.__timers.y = self.__timers.y || new Animate(self.renderTo, config);\n        //run\n        self.__timers.y.stop();\n        self.__timers.y.reset(config);\n        self.__timers.y.run();\n    },\n    /**\n     * horizontal scroll absolute to the destination\n     * @memberof SimuScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollLeft: function(x, duration, easing, callback) {\n        var self = this;\n        var x = Math.round(x);\n        if (self.userConfig.lockX) return;\n        var duration = duration || 0;\n        var easing = easing || \"quadratic\";\n        var config = {\n            css: {\n                scrollLeft: x\n            },\n            duration: duration,\n            easing: easing,\n            run: function(e) {\n                //trigger scroll event\n                self.trigger(\"scroll\", {\n                    scrollTop: self.getScrollTop(),\n                    scrollLeft: self.getScrollLeft()\n                });\n            },\n            useTransition: false, //scrollTop \n            end: callback\n        };\n        self.__timers.x = self.__timers.x || new Animate(self.renderTo, config);\n        //run\n        self.__timers.x.stop();\n        self.__timers.x.reset(config);\n        self.__timers.x.run();\n    },\n    _bindEvt: function() {\n        OriginScroll.superclass._bindEvt.call(this);\n        var self = this;\n        if (self.__isEvtBind) return;\n        self.__isEvtBind = true;\n        self.renderTo.addEventListener(\"scroll\", function(e) {\n            self.trigger(\"scroll\", {\n                type: \"scroll\",\n                scrollTop: self.getScrollTop(),\n                scrollLeft: self.getScrollLeft()\n            })\n        }, false)\n    }\n});\n\nif (typeof module == 'object' && module.exports) {\n    module.exports = OriginScroll;\n}\n/** ignored by jsdoc **/\nelse {\n    return OriginScroll;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/origin-scroll.js\n// module id = 23\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util'),\n\tBase = require('../base');\n\nvar transform = Util.prefixStyle(\"transform\");\nvar transition = Util.prefixStyle(\"transition\");\n\n/**\n * An infinity dom-recycled list plugin for xscroll.\n * @constructor\n * @param {object} cfg\n * @param {string} cfg.transition recomposition cell with a transition\n * @param {string} cfg.infiniteElements dom-selector for reused elements\n * @param {function} cfg.renderHook render function for cell by per col or per row duration scrolling\n * @extends {Base}\n */\nvar Infinite = function(cfg) {\n\tInfinite.superclass.constructor.call(this, cfg);\n\tthis.userConfig = Util.mix({\n\t\ttransition: 'all 0.5s ease'\n\t}, cfg);\n}\n\nUtil.extend(Infinite, Base, {\n\t/**\n\t * a pluginId\n\t * @memberOf Infinite\n\t * @type {string}\n\t */\n\tpluginId: \"infinite\",\n\t/**\n\t * store the visible elements inside of view.\n\t * @memberOf Infinite\n\t * @type {object}\n\t */\n\tvisibleElements: {},\n\t/**\n\t * store all elements data.\n\t * @memberOf Infinite\n\t * @type {object}\n\t */\n\tsections: {},\n\t/**\n\t * plugin initializer\n\t * @memberOf Infinite\n\t * @override Base\n\t * @return {Infinite}\n\t */\n\tpluginInitializer: function(xscroll) {\n\t\tvar self = this;\n\t\tself.xscroll = xscroll;\n\t\tself.isY = !!(xscroll.userConfig.zoomType == \"y\");\n\t\tself._ = {\n\t\t\t_top:self.isY ? \"_top\" : \"_left\",\n\t\t\t_height:self.isY ? \"_height\" : \"_width\",\n\t\t\ttop:self.isY ? \"top\" : \"left\",\n\t\t\theight:self.isY ? \"height\" : \"width\",\n\t\t\twidth:self.isY ? \"width\" : \"height\",\n\t\t\ty:self.isY ? \"y\" : \"x\",\n\t\t\ttranslate:self.isY ? \"translateY\" : \"translateX\",\n\t\t\tcontainerHeight:self.isY ? \"containerHeight\" : \"containerWidth\",\n\t\t\tscrollTop:self.isY ? \"scrollTop\" : \"scrollLeft\",\n\t\t}\n\t\tself._initInfinite();\n\t\txscroll.on(\"afterrender\", function() {\n\t\t\tself.render();\n\t\t\tself._bindEvt();\n\t\t});\n\t\treturn self;\n\t},\n\t/**\n\t * detroy the plugin\n\t * @memberOf Infinite\n\t * @override Base\n\t * @return {Infinite}\n\t */\n\tpluginDestructor: function() {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\tself.infiniteElements[i].style[_.top] = \"auto\";\n\t\t\tself.infiniteElements[i].style[transform] = \"none\";\n\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t}\n\t\tself.xscroll && self.xscroll.off(\"scroll\", self._updateByScroll, self);\n\t\tself.xscroll && self.xscroll.off(\"tap panstart pan panend\", self._cellEventsHandler, self);\n\t\treturn self;\n\t},\n\t_initInfinite: function() {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar _ = self._;\n\t\tself.sections = {};\n\t\tself.infiniteElements = xscroll.renderTo.querySelectorAll(self.userConfig.infiniteElements);\n\t\tself.infiniteLength = self.infiniteElements.length;\n\t\tself.infiniteElementsCache = (function() {\n\t\t\tvar tmp = []\n\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\ttmp.push({});\n\t\t\t\tself.infiniteElements[i].style.position = \"absolute\";\n\t\t\t\tself.infiniteElements[i].style[_.top] = 0;\n\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t\tself.infiniteElements[i].style.display = \"block\";\n\t\t\t\tUtil.addClass(self.infiniteElements[i], \"_xs_infinite_elements_\");\n\t\t\t}\n\t\t\treturn tmp;\n\t\t})();\n\t\tself.elementsPos = {};\n\t\treturn self;\n\t},\n\t_renderUnRecycledEl: function() {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tvar translateZ = self.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\tfor (var i in self.__serializedData) {\n\t\t\tvar unrecycledEl = self.__serializedData[i];\n\t\t\tif (self.__serializedData[i]['recycled'] === false) {\n\t\t\t\tvar el = unrecycledEl.id && document.getElementById(unrecycledEl.id.replace(\"#\", \"\")) || document.createElement(\"div\");\n\t\t\t\tvar randomId = Util.guid(\"xs-row-\");\n\t\t\t\tel.id = unrecycledEl.id || randomId;\n\t\t\t\tunrecycledEl.id = el.id;\n\t\t\t\tself.xscroll.content.appendChild(el);\n\t\t\t\tfor (var attrName in unrecycledEl.style) {\n\t\t\t\t\tif (attrName != _.height && attrName != \"display\" && attrName != \"position\") {\n\t\t\t\t\t\tel.style[attrName] = unrecycledEl.style[attrName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tel.style[_.top] = 0;\n\t\t\t\tel.style.position = \"absolute\";\n\t\t\t\tel.style.display = \"block\";\n\t\t\t\tel.style[_.height] = unrecycledEl[_._height] + \"px\";\n\t\t\t\tel.style[transform] = _.translate + \"(\" + unrecycledEl[_._top] + \"px) \" + translateZ;\n\t\t\t\tUtil.addClass(el, unrecycledEl.className);\n\t\t\t\tself.userConfig.renderHook.call(self, el, unrecycledEl);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * render or update the scroll contents\n\t * @memberOf Infinite\n\t * @return {Infinite}\n\t */\n\trender: function() {\n\t\tvar self = this;\n\t\tvar _  = self._;\n\t\tvar xscroll = self.xscroll;\n\t\tvar offset = self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft();\n\t\tself.visibleElements = self.getVisibleElements(offset);\n\t\tself.__serializedData = self._computeDomPositions();\n\t\txscroll.sticky && xscroll.sticky.render(true); //force render\n\t\txscroll.fixed && xscroll.fixed.render();\n\t\tvar size = xscroll[_.height];\n\t\tvar containerSize = self._containerSize;\n\t\tif (containerSize < size) {\n\t\t\tcontainerSize = size;\n\t\t}\n\t\txscroll[_.containerHeight] = containerSize;\n\t\txscroll.container.style[_.height] = containerSize + \"px\";\n\t\txscroll.content.style[_.height] = containerSize + \"px\";\n\t\tself._renderUnRecycledEl();\n\t\tself._updateByScroll();\n\t\tself._updateByRender(offset);\n\t\tself.xscroll.boundryCheck();\n\t\treturn self;\n\t},\n\t_getChangedRows: function(newElementsPos) {\n\t\tvar self = this;\n\t\tvar changedRows = {};\n\t\tfor (var i in self.elementsPos) {\n\t\t\tif (!newElementsPos.hasOwnProperty(i)) {\n\t\t\t\tchangedRows[i] = \"delete\";\n\t\t\t}\n\t\t}\n\t\tfor (var i in newElementsPos) {\n\t\t\tif (newElementsPos[i].recycled && !self.elementsPos.hasOwnProperty(i)) {\n\t\t\t\tchangedRows[i] = \"add\";\n\t\t\t}\n\t\t}\n\t\tself.elementsPos = newElementsPos;\n\t\treturn changedRows;\n\t},\n\t_updateByScroll: function(e) {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar _ = self._;\n\t\tvar _pos = e && e[_.scrollTop];\n\t\tvar pos = _pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : _pos;\n\t\tvar elementsPos = self.getVisibleElements(pos);\n\t\tvar changedRows = self.changedRows = self._getChangedRows(elementsPos);\n\t\ttry{\n\t\t\tfor (var i in changedRows) {\n\t\t\t\tif (changedRows[i] == \"delete\") {\n\t\t\t\t\tself._pushEl(i);\n\t\t\t\t}\n\t\t\t\tif (changedRows[i] == \"add\") {\n\t\t\t\t\tvar elObj = self._popEl(elementsPos[i][self.guid]);\n\t\t\t\t\tvar index = elObj.index;\n\t\t\t\t\tvar el = elObj.el;\n\t\t\t\t\tif (el) {\n\t\t\t\t\t\tself.infiniteElementsCache[index].guid = elementsPos[i].guid;\n\t\t\t\t\t\tself.__serializedData[elementsPos[i].guid].__infiniteIndex = index;\n\t\t\t\t\t\tself._renderData(el, elementsPos[i]);\n\t\t\t\t\t\tself._renderStyle(el, elementsPos[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(e){\n\t\t\tconsole.warn('Not enough infiniteElements setted!');\n\t\t}\n\t\treturn self;\n\t},\n\t_updateByRender: function(pos) {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tvar xscroll = self.xscroll;\n\t\tvar pos = pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : pos;\n\t\tvar prevElementsPos = self.visibleElements;\n\t\tvar newElementsPos = self.getVisibleElements(pos);\n\t\tvar prevEl, newEl;\n\t\t//repaint\n\t\tfor (var i in newElementsPos) {\n\t\t\tnewEl = newElementsPos[i];\n\t\t\tfor (var j in prevElementsPos) {\n\t\t\t\tprevEl = prevElementsPos[j];\n\t\t\t\tif (prevEl.guid === newEl.guid) {\n\t\t\t\t\tif (newEl.style != prevEl.style || newEl[_._top] != prevEl[_._top] || newEl[_._height] != prevEl[_._height]) {\n\t\t\t\t\t\tself._renderStyle(self.infiniteElements[newEl.__infiniteIndex], newEl, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (JSON.stringify(newEl.data) != JSON.stringify(prevEl.data)) {\n\t\t\t\t\t\tself._renderData(self.infiniteElements[newEl.__infiniteIndex], newEl);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// paint\n\t\t\t\t\tif (self.__serializedData[newEl.guid].recycled && self.__serializedData[newEl.guid].__infiniteIndex === undefined) {\n\t\t\t\t\t\tvar elObj = self._popEl();\n\t\t\t\t\t\tself.__serializedData[newEl.guid].__infiniteIndex = elObj.index;\n\t\t\t\t\t\tself._renderData(elObj.el, newEl);\n\t\t\t\t\t\tself._renderStyle(elObj.el, newEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tself.visibleElements = newElementsPos;\n\t},\n\t/**\n\t * get all element posInfo such as top,height,template,html\n\t * @return {Array}\n\t **/\n\t_computeDomPositions: function() {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tvar pos = 0,\n\t\t\tsize = 0,\n\t\t\tsections = self.sections,\n\t\t\tsection;\n\t\tvar data = [];\n\t\tvar serializedData = {};\n\t\tfor (var i in sections) {\n\t\t\tfor (var j = 0, len = sections[i].length; j < len; j++) {\n\t\t\t\tsection = sections[i][j];\n\t\t\t\tsection.sectionId = i;\n\t\t\t\tsection.index = j;\n\t\t\t\tdata.push(section);\n\t\t\t}\n\t\t}\n\n\t\t//f = v/itemSize*1000 < 60 => v = 0.06 * itemSize\n\t\tself.userConfig.maxSpeed = 0.06 * 50;\n\t\tfor (var i = 0, l = data.length; i < l; i++) {\n\t\t\tvar item = data[i];\n\t\t\tsize = item.style && item.style[_.height] >= 0 && item.style.position != \"fixed\" ? item.style[_.height] : 0;\n\t\t\titem.guid = item.guid || Util.guid();\n\t\t\titem[_._top] = pos;\n\t\t\titem[_._height] = size;\n\t\t\titem.recycled = item.recycled === false ? false : true;\n\t\t\tpos += size;\n\t\t\tserializedData[item.guid] = item;\n\t\t}\n\t\tself._containerSize = pos;\n\t\treturn serializedData;\n\t},\n\t/**\n\t * get all elements inside of the view.\n\t * @memberOf Infinite\n\t * @param {number} pos scrollLeft or scrollTop\n\t * @return {object} visibleElements\n\t */\n\tgetVisibleElements: function(pos) {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar _ = self._;\n\t\tvar pos = pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : pos;\n\t\tvar threshold = self.userConfig.threshold >= 0 ? self.userConfig.threshold : xscroll[_.height] / 3;\n\t\tvar tmp = {},\n\t\t\titem;\n\t\tvar data = self.__serializedData;\n\t\tfor (var i in data) {\n\t\t\titem = data[i];\n\t\t\tif (item[_._top] >= pos - threshold && item[_._top] <= pos + xscroll[_.height] + threshold) {\n\t\t\t\ttmp[item.guid] = item;\n\t\t\t}\n\t\t}\n\t\treturn JSON.parse(JSON.stringify(tmp));\n\t},\n\t_popEl: function() {\n\t\tvar self = this;\n\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\tif (!self.infiniteElementsCache[i]._visible) {\n\t\t\t\tself.infiniteElementsCache[i]._visible = true;\n\t\t\t\treturn {\n\t\t\t\t\tindex: i,\n\t\t\t\t\tel: self.infiniteElements[i]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t_pushEl: function(guid) {\n\t\tvar self = this;\n\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\tif (self.infiniteElementsCache[i].guid == guid) {\n\t\t\t\tself.infiniteElementsCache[i]._visible = false;\n\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t\tself.infiniteElementsCache[i].guid = null;\n\t\t\t}\n\t\t}\n\t},\n\t_renderData: function(el, elementObj) {\n\t\tvar self = this;\n\t\tif (!el || !elementObj || elementObj.style.position == \"fixed\") return;\n\t\tself.userConfig.renderHook.call(self, el, elementObj);\n\t},\n\t_renderStyle: function(el, elementObj, useTransition) {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tif (!el) return;\n\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t//update style\n\t\tfor (var attrName in elementObj.style) {\n\t\t\tif (attrName != _.height && attrName != \"display\" && attrName != \"position\") {\n\t\t\t\tel.style[attrName] = elementObj.style[attrName];\n\t\t\t}\n\t\t}\n\t\tel.setAttribute(\"xs-index\", elementObj.index);\n\t\tel.setAttribute(\"xs-sectionid\", elementObj.sectionId);\n\t\tel.setAttribute(\"xs-guid\", elementObj.guid);\n\t\tel.style.visibility = \"visible\";\n\t\tel.style[_.height] = elementObj[_._height] + \"px\";\n\t\tel.style[transform] = _.translate + \"(\" + elementObj[_._top] + \"px) \" + translateZ;\n\t\tel.style[transition] = useTransition ? self.userConfig.transition : \"none\";\n\t},\n\tgetCell: function(e) {\n\t\tvar self = this,\n\t\t\tcell;\n\t\tvar el = Util.findParentEl(e.target, \"._xs_infinite_elements_\", self.xscroll.renderTo);\n\t\tif(!el){\n\t\t\tel = Util.findParentEl(e.target, \".xs-sticky-handler\", self.xscroll.renderTo);\n\t\t}\n\t\tvar guid = el && el.getAttribute(\"xs-guid\");\n\t\tif (undefined === guid) return;\n\t\treturn {\n\t\t\tdata:self.__serializedData[guid],\n\t\t\tel:el\n\t\t};\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tif (self._isEvtBinded) return;\n\t\tself._isEvtBinded = true;\n\t\tself.xscroll.renderTo.addEventListener(\"webkitTransitionEnd\", function(e) {\n\t\t\tif (e.target.className.match(/xs-row/)) {\n\t\t\t\te.target.style.webkitTransition = \"\";\n\t\t\t}\n\t\t});\n\t\tself.xscroll.on(\"scroll\", self._updateByScroll, self);\n\t\tself.xscroll.on(\"tap panstart pan panend\", self._cellEventsHandler, self);\n\t\treturn self;\n\t},\n\t_cellEventsHandler: function(e) {\n\t\tvar self = this;\n\t\tvar cell = self.getCell(e);\n\t\te.cell = cell.data;\n\t\te.cellEl = cell.el;\n\t\te.cell && self[e.type].call(self, e);\n\t},\n\t/**\n\t * tap event\n\t * @memberOf Infinite\n\t * @param {object} e events data include cell object\n\t * @event\n\t */\n\ttap: function(e) {\n\t\tthis.trigger(\"tap\", e);\n\t\treturn this;\n\t},\n\t/**\n\t * panstart event\n\t * @memberOf Infinite\n\t * @param {object} e events data include cell object\n\t * @event\n\t */\n\tpanstart: function(e) {\n\t\tthis.trigger(\"panstart\", e);\n\t\treturn this;\n\t},\n\t/**\n\t * pan event\n\t * @memberOf Infinite\n\t * @param {object} e events data include cell object\n\t * @event\n\t */\n\tpan: function(e) {\n\t\tthis.trigger(\"pan\", e);\n\t\treturn this;\n\t},\n\t/**\n\t * panend event\n\t * @memberOf Infinite\n\t * @param {object} e events data include cell object\n\t * @event\n\t */\n\tpanend: function(e) {\n\t\tthis.trigger(\"panend\", e);\n\t\treturn this;\n\t},\n\t/**\n\t * insert data before a position\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId of the target cell\n\t * @param {number} index index of the target cell\n\t * @param {object} data data to insert\n\t * @return {Infinite}\n\t */\n\tinsertBefore: function(sectionId, index, data) {\n\t\tvar self = this;\n\t\tif (sectionId === undefined || index === undefined || data === undefined) return self;\n\t\tif (!self.sections[sectionId]) {\n\t\t\tself.sections[sectionId] = [];\n\t\t}\n\t\tself.sections[sectionId].splice(index, 0, data);\n\t\treturn self;\n\t},\n\t/**\n\t * insert data after a position\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId of the target cell\n\t * @param {number} index index of the target cell\n\t * @param {object} data data to insert\n\t * @return {Infinite}\n\t */\n\tinsertAfter: function(sectionId, index, data) {\n\t\tvar self = this;\n\t\tif (sectionId === undefined || index === undefined || data === undefined) return self;\n\t\tif (!self.sections[sectionId]) {\n\t\t\tself.sections[sectionId] = [];\n\t\t}\n\t\tself.sections[sectionId].splice(Number(index) + 1, 0, data);\n\t\treturn self;\n\t},\n\t/**\n\t * append data after a section\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId for the append cell\n\t * @param {object} data data to append\n\t * @return {Infinite}\n\t */\n\tappend: function(sectionId, data) {\n\t\tvar self = this;\n\t\tif (!self.sections[sectionId]) {\n\t\t\tself.sections[sectionId] = [];\n\t\t}\n\t\tself.sections[sectionId] = self.sections[sectionId].concat(data);\n\t\treturn self;\n\t},\n\t/**\n\t * remove some data by sectionId,from,number\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId for the append cell\n\t * @param {number} from removed index from\n\t * @param {number} number removed data number\n\t * @return {Infinite}\n\t */\n\tremove: function(sectionId, from, number) {\n\t\tvar self = this;\n\t\tvar number = number || 1;\n\t\tif (undefined === sectionId || !self.sections[sectionId]) return self;\n\t\t//remove a section\n\t\tif (undefined === from) {\n\t\t\tself.sections[sectionId] = null;\n\t\t\treturn self;\n\t\t}\n\t\t//remove some data in section\n\t\tif (self.sections[sectionId] && self.sections[sectionId][from]) {\n\t\t\tself.sections[sectionId].splice(from, number);\n\t\t\treturn self;\n\t\t}\n\t\treturn self;\n\t},\n\t/**\n\t * replace some data by sectionId and index\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId to replace\n\t * @param {number} index removed index from\n\t * @param {object} data new data to replace\n\t * @return {Infinite}\n\t */\n\treplace: function(sectionId, index, data) {\n\t\tvar self = this;\n\t\tif (undefined === sectionId || !self.sections[sectionId]) return self;\n\t\tself.sections[sectionId][index] = data;\n\t\treturn self;\n\t},\n\t/**\n\t * get data by sectionId and index\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId\n\t * @param {number} index index in the section\n\t * @return {object} data data\n\t */\n\tget: function(sectionId, index) {\n\t\tif (undefined === sectionId) return;\n\t\tif (undefined === index) return this.sections[sectionId];\n\t\treturn this.sections[sectionId][index];\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Infinite;\n}\n/** ignored by jsdoc **/\nelse if (window.XScroll && window.XScroll.Plugins) {\n\treturn XScroll.Plugins.Infinite = Infinite;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/plugins/infinite.js\n// module id = 24\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Base = require('../base');\nvar clsPrefix;\nvar containerCls;\nvar content = \"Pull Down To Refresh\";\nvar loadingContent = \"Loading...\";\n/**\n * A pulldown to refresh plugin for xscroll.\n * @constructor\n * @param {object} cfg\n * @param {number} cfg.height\n * @param {string} cfg.content default html for pulldown\n * @param {string} cfg.downContent html for pulldown when scrollTop is smaller than cfg.height\n * @param {string} cfg.upContent html for pulldown when scrollTop is larger than cfg.height\n * @param {string} cfg.loadingContent html for pulldown when released\n * @param {string} cfg.clsPrefix  class prefix which default value is \"xs-plugin-pulldown-\"\n * @extends {Base}\n */\nvar PullDown = function(cfg) {\n\tPullDown.superclass.constructor.call(this, cfg);\n\tthis.userConfig = Util.mix({\n\t\tcontent: content,\n\t\theight: 60,\n\t\tautoRefresh: true,\n\t\tdownContent: \"Pull Down To Refresh\",\n\t\tupContent: \"Release To Refresh\",\n\t\tloadingContent: loadingContent,\n\t\tclsPrefix: \"xs-plugin-pulldown-\"\n\t}, cfg);\n}\nUtil.extend(PullDown, Base, {\n\t/**\n\t * a pluginId\n\t * @memberOf PullDown\n\t * @type {string}\n\t */\n\tpluginId: \"pulldown\",\n\t/**\n\t * plugin initializer\n\t * @memberOf PullDown\n\t * @override Base\n\t * @return {PullDown}\n\t */\n\tpluginInitializer: function(xscroll) {\n\t\tvar self = this;\n\t\tself.xscroll = xscroll.render();\n\t\tclsPrefix = self.userConfig.clsPrefix;\n\t\tself.render();\n\t\treturn self;\n\t},\n\t/**\n\t * detroy the plugin\n\t * @memberOf PullDown\n\t * @override Base\n\t * @return {PullDown}\n\t */\n\tpluginDestructor: function() {\n\t\tvar self = this;\n\t\tUtil.remove(self.pulldown);\n\t\tself.xscroll.off(\"panstart\", self._panStartHandler, self);\n\t\tself.xscroll.off(\"pan\", self._panHandler, self);\n\t\tself.xscroll.off(\"panend\", self._panEndHandler, self);\n\t\tself.__isRender = false;\n\t\tself._evtBinded = false;\n\t},\n\t/**\n\t * render pulldown plugin\n\t * @memberOf PullDown\n\t * @return {PullDown}\n\t */\n\trender: function() {\n\t\tvar self = this;\n\t\tif (self.__isRender) return;\n\t\tself.__isRender = true;\n\t\tvar containerCls = clsPrefix + \"container\";\n\t\tvar height = self.userConfig.height || 60;\n\t\tvar pulldown = self.pulldown = document.createElement(\"div\");\n\t\tpulldown.className = containerCls;\n\t\tpulldown.style.position = \"absolute\";\n\t\tpulldown.style.width = \"100%\";\n\t\tpulldown.style.height = height + \"px\";\n\t\tpulldown.style.lineHeight = height + \"px\";\n\t\tpulldown.style.top = -height + \"px\";\n\t\tpulldown.style.textAlign = \"center\";\n\t\tself.xscroll.container.appendChild(pulldown);\n\t\tself.status = 'up';\n\t\tUtil.addClass(pulldown, clsPrefix + self.status);\n\t\tpulldown.innerHTML = self.userConfig[self.status + \"Content\"] || self.userConfig.content;\n\t\tself._bindEvt();\n\t\treturn self;\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tif (self._evtBinded) return;\n\t\tself._evtBinded = true;\n\t\tvar pulldown = self.pulldown;\n\t\tvar xscroll = self.xscroll;\n\t\txscroll.on(\"pan\", self._panHandler, self);\n\t\txscroll.on(\"panstart\", self._panStartHandler, self);\n\t\txscroll.on(\"panend\", self._panEndHandler, self);\n\t},\n\t_changeStatus: function(status) {\n\t\tvar prevVal = this.status;\n\t\tthis.status = status;\n\t\tUtil.removeClass(this.pulldown, clsPrefix + prevVal)\n\t\tUtil.addClass(this.pulldown, clsPrefix + status);\n\t\tif (this.userConfig[status + \"Content\"]) {\n\t\t\tthis.pulldown.innerHTML = this.userConfig[status + \"Content\"];\n\t\t}\n\t\tif (prevVal != status) {\n\t\t\tthis.trigger(\"statuschange\", {\n\t\t\t\tprevVal: prevVal,\n\t\t\t\tnewVal: status\n\t\t\t});\n\t\t\tif (status == \"loading\") {\n\t\t\t\tthis.trigger(\"loading\");\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * reset the pulldown plugin\n\t * @memberOf PullDown\n\t * @param {function} callback\n\t * @return {PullDown}\n\t */\n\treset: function(callback) {\n\t\tthis.xscroll.boundry.resetTop()\n\t\tthis.xscroll.boundryCheckY(callback);\n\t\tthis._expanded = false;\n\t\treturn this;\n\t},\n\t_panStartHandler: function(e) {\n\t\tclearTimeout(this.loadingItv);\n\t},\n\t_panHandler: function(e) {\n\t\tvar self = this;\n\t\tvar scrollTop = self.xscroll.getScrollTop();\n\t\tif (scrollTop > 0) return;\n\t\tself._changeStatus(Math.abs(scrollTop) < self.userConfig.height ? \"down\" : \"up\");\n\t},\n\t_panEndHandler: function(e) {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar height = self.userConfig.height || 60;\n\t\tvar scrollTop = xscroll.getScrollTop();\n\t\tif (scrollTop < -height) {\n\t\t\t//prevent default bounce\n\t\t\te.preventDefault();\n\t\t\txscroll.boundry.resetTop();\n\t\t\txscroll.boundry.expandTop(height);\n\t\t\txscroll.boundryCheckY(function() {\n\t\t\t\tself._changeStatus(\"loading\");\n\t\t\t});\n\t\t\tif (self.userConfig.autoRefresh) {\n\t\t\t\tclearTimeout(self.loadingItv);\n\t\t\t\tself.loadingItv = setTimeout(function() {\n\t\t\t\t\txscroll.boundry.resetTop();\n\t\t\t\t\txscroll.boundryCheckY(function() {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t})\n\t\t\t\t}, 800);\n\t\t\t}\n\t\t}\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = PullDown;\n}\n/** ignored by jsdoc **/\nelse if (window.XScroll && window.XScroll.Plugins) {\n\treturn XScroll.Plugins.PullDown = PullDown;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/plugins/pulldown.js\n// module id = 25\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Base = require('../base');\nvar clsPrefix;\nvar containerCls;\nvar loadingContent = \"Loading...\";\nvar upContent = \"Pull Up To Refresh\";\nvar downContent = \"Release To Refresh\";\nvar PULL_UP_HEIGHT = 60;\nvar HEIGHT = 40;\n/**\n * A pullup to load plugin for xscroll.\n * @constructor\n * @param {object} cfg\n * @param {number} cfg.height\n * @param {string} cfg.downContent\n * @param {string} cfg.upContent\n * @param {string} cfg.loadingContent\n * @param {string} cfg.clsPrefix  class prefix which default value is \"xs-plugin-pullup-\"\n * @param {number} cfg.bufferHeight preload data before scrolling to the bottom of the boundry\n * @extends {Base}\n */\nvar PullUp = function(cfg) {\n\tPullUp.superclass.constructor.call(this);\n\tthis.userConfig = Util.mix({\n\t\tupContent: upContent,\n\t\tdownContent: downContent,\n\t\tpullUpHeight: PULL_UP_HEIGHT,\n\t\theight: HEIGHT,\n\t\tloadingContent: loadingContent,\n\t\tbufferHeight: 0,\n\t\tclsPrefix: \"xs-plugin-pullup-\"\n\t}, cfg);\n}\nUtil.extend(PullUp, Base, {\n\t/**\n\t * a pluginId\n\t * @memberOf PullUp\n\t * @type {string}\n\t */\n\tpluginId: \"pullup\",\n\t/**\n\t * plugin initializer\n\t * @memberOf PullUp\n\t * @override Base\n\t * @return {PullUp}\n\t */\n\tpluginInitializer: function(xscroll) {\n\t\tvar self = this;\n\t\tself.xscroll = xscroll.render();\n\t\tclsPrefix = self.userConfig.clsPrefix;\n\t\tself.render();\n\t\treturn self;\n\t},\n\t/**\n\t * detroy the plugin\n\t * @memberOf PullUp\n\t * @override Base\n\t * @return {PullUp}\n\t */\n\tpluginDestructor: function() {\n\t\tvar self = this;\n\t\tUtil.remove(self.pullup);\t\t\n\t\tself.xscroll.off(\"scrollend\", self._scrollEndHandler, self);\n\t\tself.xscroll.off(\"scroll\", self._scrollHandler, self);\n\t\tself.xscroll.off(\"pan\", self._panHandler, self);\n\t\tself.xscroll.boundry.resetBottom();\n\t\tself.__isRender = false;\n\t\tself._evtBinded = false;\n\t},\n\t/**\n\t * render pullup plugin\n\t * @memberOf PullUp\n\t * @return {PullUp}\n\t */\n\trender: function() {\n\t\tvar self = this;\n\t\tif (self.__isRender) return;\n\t\tself.__isRender = true;\n\t\tvar containerCls = clsPrefix + \"container\";\n\t\tvar height = self.userConfig.height;\n\t\tvar pullup = self.pullup = document.createElement(\"div\");\n\t\tpullup.className = containerCls;\n\t\tpullup.style.position = \"absolute\";\n\t\tpullup.style.width = \"100%\";\n\t\tpullup.style.height = height + \"px\";\n\t\tpullup.style.bottom = -height + \"px\";\n\t\tself.xscroll.container.appendChild(pullup);\n\t\tself.xscroll.boundry.expandBottom(self.userConfig.height);\n\t\tself.status = 'up';\n\t\tUtil.addClass(pullup, clsPrefix + self.status);\n\t\tpullup.innerHTML = self.userConfig[self.status + \"Content\"] || self.userConfig.content;\n\t\tself._bindEvt();\n\t\treturn self;\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tif (self._evtBinded) return;\n\t\tself._evtBinded = true;\n\t\tvar pullup = self.pullup;\n\t\tvar xscroll = self.xscroll;\n\t\txscroll.on(\"pan\", self._panHandler, self);\n\t\t//load width a buffer\n\t\tif (self.userConfig.bufferHeight > 0) {\n\t\t\txscroll.on(\"scroll\", self._scrollHandler, self);\n\t\t}\n\t\t//bounce bottom\n\t\txscroll.on(\"scrollend\", self._scrollEndHandler, self);\n\t\treturn self;\n\t},\n\t_scrollEndHandler: function(e) {\n\t\tvar self = this,\n\t\t\txscroll = self.xscroll,\n\t\t\tscrollTop = xscroll.getScrollTop();\n\t\tif (scrollTop == xscroll.containerHeight - xscroll.height + self.userConfig.height) {\n\t\t\tself._changeStatus(\"loading\");\n\t\t}\n\t\treturn self;\n\t},\n\t_scrollHandler: function(e) {\n\t\tvar self = this,\n\t\t\txscroll = self.xscroll;\n\t\tif (!self.isLoading && Math.abs(e.scrollTop) + xscroll.height + self.userConfig.height + self.userConfig.bufferHeight >= xscroll.containerHeight + xscroll.boundry._xtop + xscroll.boundry._xbottom) {\n\t\t\tself._changeStatus(\"loading\");\n\t\t}\n\t\treturn self;\n\t},\n\t_panHandler: function(e) {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar offsetTop = -xscroll.getScrollTop();\n\t\tif (offsetTop < xscroll.height - xscroll.containerHeight - self.userConfig.pullUpHeight) {\n\t\t\tself._changeStatus(\"down\")\n\t\t} else {\n\t\t\tself._changeStatus(\"up\");\n\t\t}\n\t\treturn self;\n\t},\n\t_changeStatus: function(status) {\n\t\tif (status != \"loading\" && this.isLoading) return;\n\t\tvar prevVal = this.status;\n\t\tthis.status = status;\n\t\tUtil.removeClass(this.pullup, clsPrefix + prevVal)\n\t\tUtil.addClass(this.pullup, clsPrefix + status);\n\t\tthis.pullup.innerHTML = this.userConfig[status + \"Content\"];\n\t\tif (prevVal != status) {\n\t\t\tthis.trigger(\"statuschange\", {\n\t\t\t\tprevVal: prevVal,\n\t\t\t\tnewVal: status\n\t\t\t});\n\t\t\tif (status == \"loading\") {\n\t\t\t\tthis.isLoading = true;\n\t\t\t\tthis.trigger(\"loading\");\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * notify pullup plugin to complete state after a remote data request\n\t * @memberOf PullUp\n\t * @return {PullUp}\n\t */\n\tcomplete: function() {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tself.isLoading = false;\n\t\tself._changeStatus(\"up\");\n\t\treturn self;\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = PullUp;\n}\n/** ignored by jsdoc **/\nelse if (window.XScroll && window.XScroll.Plugins) {\n\treturn XScroll.Plugins.PullUp = PullUp;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/plugins/pullup.js\n// module id = 26\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util'),\n  Base = require('./base'),\n  Core = require('./core'),\n  Animate = require('./animate'),\n  Hammer = require('./hammer'),\n  ScrollBar = require('./components/scrollbar'),\n  Controller = require('./components/controller');\n//reduced boundry pan distance\nvar PAN_RATE = 1 - 0.618;\n//constant for scrolling acceleration\nvar SCROLL_ACCELERATION = 0.0005;\n//constant for outside of boundry acceleration\nvar BOUNDRY_ACCELERATION = 0.03;\n//transform-origin\nvar transformOrigin = Util.prefixStyle(\"transformOrigin\");\n//transform\nvar transform = Util.prefixStyle(\"transform\");\n/** \n * @constructor\n * @param {object} cfg config for scroll\n * @param {number} cfg.SCROLL_ACCELERATION  acceleration for scroll, min value make the scrolling smoothly\n * @param {number} cfg.BOUNDRY_CHECK_DURATION duration for boundry bounce\n * @param {number} cfg.BOUNDRY_CHECK_EASING easing for boundry bounce\n * @param {number} cfg.BOUNDRY_CHECK_ACCELERATION acceleration for boundry bounce\n * @param {boolean} cfg.lockX just like overflow-x:hidden\n * @param {boolean} cfg.lockY just like overflow-y:hidden\n * @param {boolean} cfg.scrollbarX config if the scrollbar-x is visible\n * @param {boolean} cfg.scrollbarY config if the scrollbar-y is visible\n * @param {boolean} cfg.useTransition config if use css3 transition or raf for scroll animation\n * @param {boolean} cfg.bounce config if use has the bounce effect when scrolling outside of the boundry\n * @param {boolean} cfg.boundryCheck config if scrolling inside of the boundry\n * @param {boolean} cfg.preventDefault prevent touchstart\n * @param {boolean} cfg.preventTouchMove prevent touchmove\n * @param {string|HTMLElement}  cfg.container config for scroller's container which default value is \".xs-container\"\n * @param {string|HTMLElement}  cfg.content config for scroller's content which default value is \".xs-content\"\n * @param {object}  cfg.indicatorInsets  config scrollbars position {top: number, left: number, bottom: number, right: number}\n * @param {string}  cfg.stickyElements config for sticky-positioned elements\n * @param {string}  cfg.fixedElements config for fixed-positioned elements\n * @param {string}  cfg.touchAction config for touchAction of the scroller\n * @extends XScroll\n * @example\n * var xscroll = new SimuScroll({\n *    renderTo:\"#scroll\",\n *    lockX:false,\n *    scrollbarX:true\n * });\n * xscroll.render();\n */\nfunction SimuScroll(cfg) {\n  SimuScroll.superclass.constructor.call(this, cfg);\n}\n\nUtil.extend(SimuScroll, Core, {\n  /** \n   * @memberof SimuScroll\n   * @override\n   */\n  init: function() {\n    var self = this;\n    var defaultCfg = {\n      preventDefault: true,\n      preventTouchMove: true\n    };\n    SimuScroll.superclass.init.call(this);\n    self.userConfig = Util.mix(defaultCfg, self.userConfig);\n    self.SCROLL_ACCELERATION = self.userConfig.SCROLL_ACCELERATION || SCROLL_ACCELERATION;\n    self.BOUNDRY_ACCELERATION = self.userConfig.BOUNDRY_ACCELERATION || BOUNDRY_ACCELERATION;\n    self._initContainer();\n    self.resetSize();\n    //set overflow behaviors\n    self._setOverflowBehavior();\n    self.defaltConfig = {\n      lockY: self.userConfig.lockY,\n      lockX: self.userConfig.lockX\n    }\n    return self;\n  },\n  destroy: function() {\n    var self = this;\n    SimuScroll.superclass.destroy.call(this);\n    self.renderTo.style.overflow = \"\";\n    self.renderTo.style.touchAction = \"\";\n    self.container.style.transform = \"\";\n    self.container.style.transformOrigin = \"\";\n    self.content.style.transform = \"\";\n    self.content.style.transformOrigin = \"\";\n    self.off(\"touchstart mousedown\", self._ontouchstart);\n    self.off(\"touchmove\", self._ontouchmove);\n    self.destroyScrollBars();\n  },\n  /**\n   * set overflow behavior\n   * @return {boolean} [description]\n   */\n  _setOverflowBehavior: function() {\n    var self = this;\n    var renderTo = self.renderTo;\n    var computeStyle = getComputedStyle(renderTo);\n    self.userConfig.lockX = undefined === self.userConfig.lockX ? ((computeStyle['overflow-x'] == \"hidden\" || self.width == self.containerWidth) ? true : false) : self.userConfig.lockX;\n    self.userConfig.lockY = undefined === self.userConfig.lockY ? ((computeStyle['overflow-y'] == \"hidden\" || self.height == self.containerHeight) ? true : false) : self.userConfig.lockY;\n    self.userConfig.scrollbarX = undefined === self.userConfig.scrollbarX ? (self.userConfig.lockX ? false : true) : self.userConfig.scrollbarX;\n    self.userConfig.scrollbarY = undefined === self.userConfig.scrollbarY ? (self.userConfig.lockY ? false : true) : self.userConfig.scrollbarY;\n    return self;\n  },\n  /**\n   * reset lockX or lockY config to the default value\n   */\n  _resetLockConfig: function() {\n    var self = this;\n    self.userConfig.lockX = self.defaltConfig.lockX;\n    self.userConfig.lockY = self.defaltConfig.lockY;\n    return self;\n  },\n  /**\n   * init container\n   * @override\n   * @return {SimuScroll}\n   */\n  _initContainer: function() {\n    var self = this;\n    SimuScroll.superclass._initContainer.call(self);\n    if (self.__isContainerInited || !self.container || !self.content) return;\n    self.container.style[transformOrigin] = \"0 0\";\n    self.content.style[transformOrigin] = \"0 0\";\n    self.translate(0, 0);\n    self.__isContainerInited = true;\n    return self;\n  },\n  /**\n   * get scroll top value\n   * @memberof SimuScroll\n   * @return {number} scrollTop\n   */\n  getScrollTop: function() {\n    var transY = window.getComputedStyle(this.container)[transform].match(/[-\\d\\.*\\d*]+/g);\n    return transY ? Math.round(transY[5]) === 0 ? 0 : -Math.round(transY[5]) : 0;\n  },\n  /**\n   * get scroll left value\n   * @memberof SimuScroll\n   * @return {number} scrollLeft\n   */\n  getScrollLeft: function() {\n    var transX = window.getComputedStyle(this.content)[transform].match(/[-\\d\\.*\\d*]+/g);\n    return transX ? Math.round(transX[4]) === 0 ? 0 : -Math.round(transX[4]) : 0;\n  },\n  /**\n   * horizontal scroll absolute to the destination\n   * @memberof SimuScroll\n   * @param scrollLeft {number} scrollLeft\n   * @param duration {number} duration for animte\n   * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n   **/\n  scrollLeft: function(x, duration, easing, callback) {\n    if (this.userConfig.lockX) return;\n    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n    this.x = (undefined === x || isNaN(x) || 0 === x) ? 0 : -Math.round(x);\n    this._animate(\"x\", \"translateX(\" + this.x + \"px) scale(\" + this.scale + \")\" + translateZ, duration, easing, callback);\n    return this;\n  },\n  /**\n   * vertical scroll absolute to the destination\n   * @memberof SimuScroll\n   * @param scrollTop {number} scrollTop\n   * @param duration {number} duration for animte\n   * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n   **/\n  scrollTop: function(y, duration, easing, callback) {\n    if (this.userConfig.lockY) return;\n    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n    this.y = (undefined === y || isNaN(y) || 0 === y) ? 0 : -Math.round(y);\n    this._animate(\"y\", \"translateY(\" + this.y + \"px) \" + translateZ, duration, easing, callback);\n    return this;\n  },\n  /**\n   * translate the scroller to a new destination includes x , y , scale\n   * @memberof SimuScroll\n   * @param x {number} x\n   * @param y {number} y\n   * @param scale {number} scale\n   **/\n  translate: function(x, y, scale) {\n    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n    this.x = x || this.x || 0;\n    this.y = y || this.y || 0;\n    this.scale = scale || this.scale || 1;\n    this.content.style[transform] = \"translate(\" + this.x + \"px,0px) scale(\" + this.scale + \") \" + translateZ;\n    this.container.style[transform] = \"translate(0px,\" + this.y + \"px) \" + translateZ;\n    return this;\n  },\n  _animate: function(type, transform, duration, easing, callback) {\n    var self = this;\n    var duration = duration || 0;\n    var easing = easing || \"quadratic\";\n    var el = type == \"y\" ? self.container : self.content;\n    var config = {\n      css: {\n        transform: transform\n      },\n      duration: duration,\n      easing: easing,\n      run: function(e) {\n        /**\n         * @event {@link SimuScroll#\"scroll\"}\n         */\n        self.trigger(\"scroll\", {\n          scrollTop: self.getScrollTop(),\n          scrollLeft: self.getScrollLeft(),\n          type: \"scroll\"\n        });\n      },\n      useTransition: self.userConfig.useTransition,\n      end: function(e) {\n        callback && callback();\n        if ((self[\"_bounce\" + type] === 0 || self[\"_bounce\" + type] === undefined) && easing != \"linear\") {\n          self['isScrolling' + type.toUpperCase()] = false;\n          self['isRealScrolling' + type.toUpperCase()] = false;\n          self.trigger(\"scrollend\", {\n            type: \"scrollend\",\n            scrollTop: self.getScrollTop(),\n            scrollLeft: self.getScrollLeft(),\n            zoomType: type,\n            duration: duration,\n            easing: easing\n          });\n        }\n      }\n    };\n    var timer = self.__timers[type] = self.__timers[type] || new Animate(el, config);\n    timer.stop();\n    timer.reset(config);\n    timer.run();\n    self.trigger(\"scrollanimate\", {\n      type: \"scrollanimate\",\n      scrollTop: -self.y,\n      scrollLeft: -self.x,\n      duration: duration,\n      easing: easing,\n      zoomType: type\n    })\n    return this;\n  },\n  _ontap: function(e) {\n    var self = this;\n    self.boundryCheck();\n    self._unPreventHref(e);\n    if (!self.isRealScrollingX && !self.isRealScrollingY) {\n      self._triggerClick(e);\n    }\n    self._preventHref(e);\n    self.isRealScrollingY = false;\n    self.isRealScrollingY = false;\n  },\n  _bindEvt: function() {\n    SimuScroll.superclass._bindEvt.call(this);\n    var self = this;\n    if (self.__isEvtBind) return;\n    self.__isEvtBind = true;\n    var pinch = new Hammer.Pinch();\n    self.mc.add(pinch);\n    self.on(\"touchstart mousedown\", self._ontouchstart, self);\n    self.on(\"touchmove\", self._ontouchmove, self);\n    self.on(\"tap\", self._ontap, self);\n    self.on(\"panstart\", self._onpanstart, self);\n    self.on(\"pan\", self._onpan, self);\n    self.on(\"panend\", self._onpanend, self);\n    //window resize\n    window.addEventListener(\"resize\", function(e) {\n      setTimeout(function() {\n        self.resetSize();\n        self.boundryCheck(0);\n        self.render();\n      }, 100);\n    }, self);\n\n    return this;\n  },\n  _ontouchstart: function(e) {\n    var self = this;\n    if (!(/(SELECT|INPUT|TEXTAREA)/i).test(e.target.tagName) && self.userConfig.preventDefault) {\n      e.preventDefault();\n    }\n    self.stop();\n  },\n  _ontouchmove: function(e) {\n    this.userConfig.preventTouchMove && e.preventDefault();\n  },\n  _onpanstart: function(e) {\n    this.userConfig.preventTouchMove && e.preventDefault();\n    var self = this;\n    var scrollLeft = self.getScrollLeft();\n    var scrollTop = self.getScrollTop();\n    self.stop();\n    self.translate(-scrollLeft, -scrollTop);\n    var threshold = self.mc.get(\"pan\").options.threshold;\n    self.thresholdY = e.direction == \"8\" ? threshold : e.direction == \"16\" ? -threshold : 0;\n    self.thresholdX = e.direction == \"2\" ? threshold : e.direction == \"4\" ? -threshold : 0;\n    return self;\n  },\n  _onpan: function(e) {\n    this.userConfig.preventTouchMove && e.preventDefault();\n    var self = this;\n    var boundry = self.boundry;\n    var userConfig = self.userConfig;\n    var boundryCheck = userConfig.boundryCheck;\n    var bounce = userConfig.bounce;\n    var scrollTop = self.__topstart || (self.__topstart = -self.getScrollTop());\n    var scrollLeft = self.__leftstart || (self.__leftstart = -self.getScrollLeft());\n    var y = userConfig.lockY ? Number(scrollTop) : Number(scrollTop) + (e.deltaY + self.thresholdY);\n    var x = userConfig.lockX ? Number(scrollLeft) : Number(scrollLeft) + (e.deltaX + self.thresholdX);\n    var containerWidth = self.containerWidth;\n    var containerHeight = self.containerHeight;\n    if (boundryCheck) {\n      //over top\n      y = y > boundry.top ? bounce ? (y - boundry.top) * PAN_RATE + boundry.top : boundry.top : y;\n      //over bottom\n      y = y < boundry.bottom - containerHeight ? bounce ? y + (boundry.bottom - containerHeight - y) * PAN_RATE : boundry.bottom - containerHeight : y;\n      //over left\n      x = x > boundry.left ? bounce ? (x - boundry.left) * PAN_RATE + boundry.left : boundry.left : x;\n      //over right\n      x = x < boundry.right - containerWidth ? bounce ? x + (boundry.right - containerWidth - x) * PAN_RATE : boundry.right - containerWidth : x;\n    }\n    //move to x,y\n    self.translate(x, y);\n    //pan trigger the opposite direction\n    self.directionX = e.type == 'panleft' ? 'right' : e.type == 'panright' ? 'left' : '';\n    self.directionY = e.type == 'panup' ? 'down' : e.type == 'pandown' ? 'up' : '';\n    self.trigger(\"scroll\", {\n      scrollTop: -y,\n      scrollLeft: -x,\n      triggerType: \"pan\",\n      type: \"scroll\"\n    });\n    return self;\n  },\n  _onpanend: function(e) {\n    var self = this;\n    var userConfig = self.userConfig;\n    var transX = self.computeScroll(\"x\", e.velocityX);\n    var transY = self.computeScroll(\"y\", e.velocityY);\n    var scrollLeft = transX ? transX.pos : 0;\n    var scrollTop = transY ? transY.pos : 0;\n    var duration;\n    if (transX && transY && transX.status == \"inside\" && transY.status == \"inside\" && transX.duration && transY.duration) {\n      //ensure the same duration\n      duration = Math.max(transX.duration, transY.duration);\n    }\n    transX && self.scrollLeft(scrollLeft, duration || transX.duration, transX.easing, function(e) {\n      self.boundryCheckX();\n    });\n    transY && self.scrollTop(scrollTop, duration || transY.duration, transY.easing, function(e) {\n      self.boundryCheckY();\n    });\n    //judge the direction\n    self.directionX = e.velocityX < 0 ? \"left\" : \"right\";\n    self.directionY = e.velocityY < 0 ? \"up\" : \"down\";\n    //clear start\n    self.__topstart = null;\n    self.__leftstart = null;\n    return self;\n  },\n  /**\n   * judge the scroller is out of boundry horizontally and vertically\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOut: function() {\n    return this.isBoundryOutLeft() || this.isBoundryOutRight() || this.isBoundryOutTop() || this.isBoundryOutBottom();\n  },\n  /**\n   * judge if the scroller is outsideof left\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOutLeft: function() {\n    return this.getBoundryOutLeft() > 0 ? true : false;\n  },\n  /**\n   * judge if the scroller is outsideof right\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOutRight: function() {\n    return this.getBoundryOutRight() > 0 ? true : false;\n  },\n  /**\n   * judge if the scroller is outsideof top\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOutTop: function() {\n    return this.getBoundryOutTop() > 0 ? true : false;\n  },\n  /**\n   * judge if the scroller is outsideof bottom\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOutBottom: function() {\n    return this.getBoundryOutBottom() > 0 ? true : false;\n  },\n  /**\n   * get the offset value outsideof top\n   * @memberof SimuScroll\n   * @return {number} offset\n   **/\n  getBoundryOutTop: function() {\n    return -this.boundry.top - this.getScrollTop();\n  },\n  /**\n   * get the offset value outsideof left\n   * @memberof SimuScroll\n   * @return {number} offset\n   **/\n  getBoundryOutLeft: function() {\n    return -this.boundry.left - this.getScrollLeft();\n  },\n  /**\n   * get the offset value outsideof bottom\n   * @memberof SimuScroll\n   * @return {number} offset\n   **/\n  getBoundryOutBottom: function() {\n    return this.boundry.bottom - this.containerHeight + this.getScrollTop();\n  },\n  /**\n   * get the offset value outsideof right\n   * @memberof SimuScroll\n   * @return {number} offset\n   **/\n  getBoundryOutRight: function() {\n    return this.boundry.right - this.containerWidth + this.getScrollLeft();\n  },\n  /**\n   * compute scroll transition by zoomType and velocity\n   * @memberof SimuScroll\n   * @param {string} zoomType zoomType of scrolling\n   * @param {number} velocity velocity after panend\n   * @example\n   * var info = xscroll.computeScroll(\"x\",2);\n   * // return {pos:90,easing:\"easing\",status:\"inside\",duration:500}\n   * @return {Object}\n   **/\n  computeScroll: function(type, v) {\n    var self = this;\n    var userConfig = self.userConfig;\n    var boundry = self.boundry;\n    var pos = type == \"x\" ? self.getScrollLeft() : self.getScrollTop();\n    var boundryStart = type == \"x\" ? boundry.left : boundry.top;\n    var boundryEnd = type == \"x\" ? boundry.right : boundry.bottom;\n    var innerSize = type == \"x\" ? self.containerWidth : self.containerHeight;\n    var maxSpeed = userConfig.maxSpeed || 2;\n    var boundryCheck = userConfig.boundryCheck;\n    var bounce = userConfig.bounce;\n    var transition = {};\n    var status = \"inside\";\n    if (boundryCheck) {\n      if (type == \"x\" && (self.isBoundryOutLeft() || self.isBoundryOutRight())) {\n        self.boundryCheckX();\n        return;\n      } else if (type == \"y\" && (self.isBoundryOutTop() || self.isBoundryOutBottom())) {\n        self.boundryCheckY();\n        return;\n      }\n    }\n    if (type == \"x\" && self.userConfig.lockX) return;\n    if (type == \"y\" && self.userConfig.lockY) return;\n    v = v > maxSpeed ? maxSpeed : v < -maxSpeed ? -maxSpeed : v;\n    var a = self.SCROLL_ACCELERATION * (v / (Math.abs(v) || 1));\n    var a2 = self.BOUNDRY_ACCELERATION;\n    var t = isNaN(v / a) ? 0 : v / a;\n    var s = Number(pos) + t * v / 2;\n    //over top boundry check bounce\n    if (s < -boundryStart && boundryCheck) {\n      var _s = -boundryStart - pos;\n      var _t = (Math.sqrt(-2 * a * _s + v * v) + v) / a;\n      var v0 = v - a * _t;\n      var _t2 = Math.abs(v0 / a2);\n      var s2 = v0 / 2 * _t2;\n      t = _t + _t2;\n      s = bounce ? -boundryStart + s2 : -boundryStart;\n      status = \"outside\";\n    } else if (s > innerSize - boundryEnd && boundryCheck) {\n      var _s = (boundryEnd - innerSize) + pos;\n      var _t = (Math.sqrt(-2 * a * _s + v * v) - v) / a;\n      var v0 = v - a * _t;\n      var _t2 = Math.abs(v0 / a2);\n      var s2 = v0 / 2 * _t2;\n      t = _t + _t2;\n      s = bounce ? innerSize - boundryEnd + s2 : innerSize - boundryEnd;\n      status = \"outside\";\n    }\n    if (isNaN(s) || isNaN(t)) return;\n    transition.pos = s;\n    transition.duration = t;\n    transition.easing = Math.abs(v) > 2 ? \"circular\" : \"quadratic\";\n    transition.status = status;\n    var Type = type.toUpperCase();\n    self['isScrolling' + Type] = true;\n    self['isRealScrolling' + Type] = true;\n    return transition;\n  },\n  /**\n   * bounce to the boundry horizontal\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  boundryCheckX: function(duration, easing, callback) {\n    var self = this;\n    if (!self.userConfig.boundryCheck) return;\n    if (typeof arguments[0] == \"function\") {\n      callback = arguments[0];\n      duration = self.userConfig.BOUNDRY_CHECK_DURATION;\n      easing = self.userConfig.BOUNDRY_CHECK_EASING;\n    } else {\n      duration = duration === 0 ? 0 : self.userConfig.BOUNDRY_CHECK_DURATION,\n        easing = easing || self.userConfig.BOUNDRY_CHECK_EASING;\n    }\n    if (!self.userConfig.bounce || self.userConfig.lockX) return;\n    var boundry = self.boundry;\n    if (self.isBoundryOutLeft()) {\n      self.scrollLeft(-boundry.left, duration, easing, callback);\n    } else if (self.isBoundryOutRight()) {\n      self.scrollLeft(self.containerWidth - boundry.right, duration, easing, callback);\n    }\n    return self;\n  },\n  /**\n   * bounce to the boundry vertical\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  boundryCheckY: function(duration, easing, callback) {\n    var self = this;\n    if (!self.userConfig.boundryCheck) return;\n    if (typeof arguments[0] == \"function\") {\n      callback = arguments[0];\n      duration = self.userConfig.BOUNDRY_CHECK_DURATION;\n      easing = self.userConfig.BOUNDRY_CHECK_EASING;\n    } else {\n      duration = duration === 0 ? 0 : self.userConfig.BOUNDRY_CHECK_DURATION,\n        easing = easing || self.userConfig.BOUNDRY_CHECK_EASING;\n    }\n    if (!self.userConfig.boundryCheck || self.userConfig.lockY) return;\n    var boundry = self.boundry;\n    if (self.isBoundryOutTop()) {\n      self.scrollTop(-boundry.top, duration, easing, callback);\n    } else if (self.isBoundryOutBottom()) {\n      self.scrollTop(self.containerHeight - boundry.bottom, duration, easing, callback);\n    }\n    return self;\n  },\n  /**\n   * bounce to the boundry vertical and horizontal\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  boundryCheck: function(duration, easing, callback) {\n    this.boundryCheckX(duration, easing, callback);\n    this.boundryCheckY(duration, easing, callback);\n    return this;\n  },\n  /**\n   * stop scrolling immediatelly\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  stop: function() {\n    var self = this;\n    self.__timers.x && self.__timers.x.stop();\n    self.__timers.y && self.__timers.y.stop();\n    if (self.isScrollingX || self.isScrollingY) {\n      var scrollTop = self.getScrollTop(),\n        scrollLeft = self.getScrollLeft();\n      self.trigger(\"scrollend\", {\n        scrollTop: scrollTop,\n        scrollLeft: scrollLeft\n      });\n      self.trigger(\"stop\", {\n        scrollTop: scrollTop,\n        scrollLeft: scrollLeft\n      })\n      self.isScrollingX = false;\n      self.isScrollingY = false;\n    }\n    return self;\n  },\n  /**\n   * render scroll\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  render: function() {\n    var self = this;\n    SimuScroll.superclass.render.call(this);\n    //fixed for scrollbars\n    if (getComputedStyle(self.renderTo).position == \"static\") {\n      self.renderTo.style.position = \"relative\";\n    }\n    self.renderTo.style.overflow = \"hidden\";\n    self.initScrollBars();\n    self.initController();\n    return self;\n  },\n  /**\n   * init scrollbars\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   */\n  initScrollBars: function() {\n    var self = this;\n    if (!self.userConfig.boundryCheck) return;\n    var indicatorInsets = self.userConfig.indicatorInsets;\n    if (self.userConfig.scrollbarX) {\n      self.scrollbarX = self.scrollbarX || new ScrollBar({\n        xscroll: self,\n        type: \"x\",\n        spacing: indicatorInsets.spacing\n      });\n      self.scrollbarX.render();\n      self.scrollbarX._update();\n      self.scrollbarX.hide();\n    }\n    if (self.userConfig.scrollbarY) {\n      self.scrollbarY = self.scrollbarY || new ScrollBar({\n        xscroll: self,\n        type: \"y\",\n        spacing: indicatorInsets.spacing\n      });\n      self.scrollbarY.render();\n      self.scrollbarY._update();\n      self.scrollbarY.hide();\n    }\n    return self;\n  },\n  /**\n   * destroy scrollbars\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   */\n  destroyScrollBars: function() {\n    this.scrollbarX && this.scrollbarX.destroy();\n    this.scrollbarY && this.scrollbarY.destroy();\n    return this;\n  },\n  /**\n   * init controller for multi-scrollers\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   */\n  initController: function() {\n    var self = this;\n    self.controller = self.controller || new Controller({\n      xscroll: self\n    });\n    return self;\n  },\n  _unPreventHref: function(e) {\n    var target = Util.findParentEl(e.target,'a',this.renderTo);\n    if(!target) return;\n    if (target.tagName.toLowerCase() == \"a\") {\n      var href = target.getAttribute(\"data-xs-href\");\n      if (href) {\n        target.setAttribute(\"href\", href);\n      }\n    }\n  },\n  _preventHref: function(e) {\n    var target = Util.findParentEl(e.target,'a',this.renderTo);\n    if(!target) return;\n    if (target.tagName.toLowerCase() == \"a\") {\n      var href = target.getAttribute(\"href\");\n      href && target.setAttribute(\"href\", \"javascript:void(0)\");\n      href && target.setAttribute(\"data-xs-href\", href);\n    }\n  },\n  _triggerClick: function(e) {\n    var target = e.target;\n    if (!(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName)) {\n      var ev = document.createEvent('MouseEvents');\n      ev.initMouseEvent('click', true, true, e.view, 1,\n        target.screenX, target.screenY, target.clientX, target.clientY,\n        e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,\n        0, null);\n      target.dispatchEvent(ev);\n    }\n  }\n});\n\nif (typeof module == 'object' && module.exports) {\n  module.exports = SimuScroll;\n}\n/** ignored by jsdoc **/\nelse {\n  return SimuScroll;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/simulate-scroll.js\n// module id = 27\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util'),\n\tBase = require('./base'),\n\tTimer = require('./timer'),\n\tAnimate = require('./animate'),\n\tHammer = require('./hammer'),\n\tSimuScroll = require('./simulate-scroll'),\n\tOriginScroll = require('./origin-scroll');\nvar XScroll = function(cfg) {\n\t\tvar _ = cfg && cfg.useOriginScroll ? OriginScroll : SimuScroll;\n\t\treturn new _(cfg);\n\t}\n/**\n * Util\n * @namespace Util\n * @type {Object}\n */\nXScroll.Util = Util;\n/**\n * Base\n * @namespace Base\n * @type {Base}\n */\nXScroll.Base = Base;\n/**\n * Timer\n * @namespace Timer\n * @type {Timer}\n */\nXScroll.Timer = Timer;\n/**\n * Animate\n * @namespace Animate\n * @type {Animate}\n */\nXScroll.Animate = Animate;\n/**\n * Hammer\n * @namespace Hammer\n * @type {Hammer}\n */\nXScroll.Hammer = Hammer;\n/**\n * plugins\n * @namespace Plugins\n * @type {Object}\n */\nXScroll.Plugins = {};\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = XScroll;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn window.XScroll = XScroll;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/xscroll.js\n// module id = 28\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_29__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"classnames\"\n// module id = 29\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_30__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 30\n// module chunks = 0"],"sourceRoot":""}
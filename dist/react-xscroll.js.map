{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-xscroll.js","webpack:///webpack/bootstrap 08ca850a72b0fde7077e","webpack:///./src/main.js","webpack:///./~/xscroll/build/cmd/util.js","webpack:///./~/xscroll/build/cmd/base.js","webpack:///./~/xscroll/build/cmd/animate.js","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/style-loader/addStyles.js","webpack:///./~/xscroll/build/cmd/hammer.js","webpack:///./src/components/react-xscroll.js","webpack:///./~/xscroll/build/cmd/core.js","webpack:///./~/xscroll/build/cmd/easing.js","webpack:///./~/xscroll/build/cmd/timer.js","webpack:///./src/components/react-xscroll-ctrl.js","webpack:///./src/components/style.plug.pulldown.scss","webpack:///./src/components/style.plug.pullup.scss","webpack:///./src/components/style.scss","webpack:///./~/n-zepto/n-zepto.js","webpack:///./src/components/style.plug.pulldown.scss?663a","webpack:///./src/components/style.plug.pullup.scss?c773","webpack:///./src/components/style.scss?3726","webpack:///./~/xscroll/build/cmd/boundry.js","webpack:///./~/xscroll/build/cmd/components/controller.js","webpack:///./~/xscroll/build/cmd/components/fixed.js","webpack:///./~/xscroll/build/cmd/components/scrollbar.js","webpack:///./~/xscroll/build/cmd/components/sticky.js","webpack:///./~/xscroll/build/cmd/events.js","webpack:///./~/xscroll/build/cmd/origin-scroll.js","webpack:///./~/xscroll/build/cmd/plugins/infinite.js","webpack:///./~/xscroll/build/cmd/plugins/pulldown.js","webpack:///./~/xscroll/build/cmd/plugins/pullup.js","webpack:///./~/xscroll/build/cmd/simulate-scroll.js","webpack:///./~/xscroll/build/cmd/xscroll.js","webpack:///external \"classnames\"","webpack:///external \"react\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_31__","__WEBPACK_EXTERNAL_MODULE_32__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_reactXscroll","_reactXscroll2","_reactXscrollCtrl","_reactXscrollCtrl2","ReactXScroll","ReactXScrollCtrl","__WEBPACK_AMD_DEFINE_RESULT__","Empty","createObject","proto","constructor","newProto","Object","create","prototype","getNodes","node","rootNode","nodeType","document","querySelectorAll","SUBSTITUTE_REG","EMPTY","RE_TRIM","trim","String","_trim","str","replace","idCounter","getOffsetTop","el","offset","offsetTop","offsetParent","getOffsetLeft","offsetLeft","Util","isObject","isArray","Array","toString","isEmpty","isString","length","key","has","mix","to","from","deep","i","extend","r","s","px","sx","rp","sp","superclass","startsWith","prefix","lastIndexOf","endsWith","suffix","ind","indexOf","substitute","o","regexp","match","name","charAt","slice","undefined","vendor","transform","createElement","style","vendors","l","substr","prefixStyle","attrName","toUpperCase","hasClass","className","addClass","removeClass","remove","parentNode","removeChild","findParentEl","selector","rs","parent","type","test","sel","querySelector","body","tagName","toLowerCase","guid","isAndroid","window","navigator","appVersion","isBadAndroid","px2Num","Number","getNode","nodes","stringifyStyle","styleStr","join","names","Events","Base","plug","plugin","self","pluginId","__plugins","__plugin","getPlugin","unplug","pluginInitializer","push","_plugin","pluginDestructor","splice","plugins","myParse","v","Math","round","parseFloat","defaultDecompose","translateX","translateY","rotate","skewX","skewY","scaleX","scaleY","toMatrixArray","matrix","split","map","decomposeMatrix","skew","A","B","C","D","sqrt","atan2","PI","atan","getTransformInfo","prop","val","ret","Animate","cfg","css","duration","easing","delay","run","timer","Timer","on","_bindEvt","computeTransform","prevTransform","destTransform","dest","trans","prevVal","newVal","setStyle","styleName","percent","isNaN","curVal","vendorTransform","Easing","vendorTransition","vendorTransitionEnd","translateTpl","animAttrs","opacity","scrollTop","scrollLeft","__isTransitionEnd","clearTimeout","__itv","MIN_DURATION","stop","__handlers","useTransition","format","setTimeout","trigger","computeStyle","getComputedStyle","transmap","off","transRun","_transitionEndHandler","e","newTrans","end","addEventListener","target","currentTarget","cssRun","value","reset","list","result","item","mediaQuery","alreadyImportedModules","addStylesToDom","styles","options","domStyle","stylesInDom","refs","j","parts","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","Error","removeStyleElement","idx","createStyleElement","createLinkElement","linkElement","rel","update","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","index","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","encodeURIComponent","JSON","stringify","blob","oldSrc","memoize","fn","memo","apply","arguments","isOldIE","userAgent","getElementsByTagName","newList","mayRemove","textStore","replacement","filter","Boolean","setTimeoutContext","timeout","context","bindFn","invokeArrayArg","arg","each","iterator","forEach","hasOwnProperty","src","merge","keys","inherit","child","base","properties","childP","baseP","_super","boolOrFn","args","TYPE_FUNCTION","ifUndefined","val1","val2","addEventListeners","types","handler","splitStr","removeEventListeners","removeEventListener","hasParent","inStr","find","inArray","findByKey","toArray","uniqueArray","sort","results","values","a","b","prefixed","property","camelProp","VENDOR_PREFIXES","uniqueId","_uniqueId","getWindowForElement","element","doc","ownerDocument","defaultView","parentWindow","Input","manager","callback","inputTarget","domHandler","ev","enable","init","createInputInstance","Type","inputClass","SUPPORT_POINTER_EVENTS","PointerEventInput","SUPPORT_ONLY_TOUCH","TouchInput","SUPPORT_TOUCH","TouchMouseInput","MouseInput","inputHandler","eventType","input","pointersLen","pointers","changedPointersLen","changedPointers","isFirst","INPUT_START","isFinal","INPUT_END","INPUT_CANCEL","session","computeInputData","emit","recognize","prevInput","pointersLength","firstInput","simpleCloneInputData","firstMultiple","offsetCenter","center","getCenter","timeStamp","now","deltaTime","angle","getAngle","distance","getDistance","computeDeltaXY","offsetDirection","getDirection","deltaX","deltaY","scale","getScale","rotation","getRotation","computeIntervalInputData","srcEvent","offsetDelta","prevDelta","x","y","velocity","velocityX","velocityY","direction","last","lastInterval","COMPUTE_INTERVAL","getVelocity","abs","clientX","clientY","DIRECTION_NONE","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","p1","p2","props","PROPS_XY","start","PROPS_CLIENT_XY","evEl","MOUSE_ELEMENT_EVENTS","evWin","MOUSE_WINDOW_EVENTS","allow","pressed","POINTER_ELEMENT_EVENTS","POINTER_WINDOW_EVENTS","store","pointerEvents","SingleTouchInput","evTarget","SINGLE_TOUCH_TARGET_EVENTS","SINGLE_TOUCH_WINDOW_EVENTS","started","normalizeSingleTouches","all","touches","changed","changedTouches","concat","TOUCH_TARGET_EVENTS","targetIds","getTouches","allTouches","INPUT_MOVE","identifier","targetTouches","changedTargetTouches","touch","mouse","TouchAction","set","cleanTouchActions","actions","TOUCH_ACTION_NONE","hasPanX","TOUCH_ACTION_PAN_X","hasPanY","TOUCH_ACTION_PAN_Y","TOUCH_ACTION_MANIPULATION","TOUCH_ACTION_AUTO","Recognizer","defaults","state","STATE_POSSIBLE","simultaneous","requireFail","stateStr","STATE_CANCELLED","STATE_ENDED","STATE_CHANGED","STATE_BEGAN","directionStr","getRecognizerByNameIfManager","otherRecognizer","recognizer","get","AttrRecognizer","PanRecognizer","pX","pY","PinchRecognizer","PressRecognizer","_timer","_input","RotateRecognizer","SwipeRecognizer","TapRecognizer","pTime","pCenter","count","Hammer","recognizers","preset","Manager","handlers","touchAction","toggleCssProps","add","recognizeWith","requireFailure","cssProps","triggerDomEvent","event","data","gestureEvent","createEvent","initEvent","gesture","dispatchEvent","TEST_ELEMENT","Date","MOBILE_REGEX","INPUT_TYPE_TOUCH","INPUT_TYPE_PEN","INPUT_TYPE_MOUSE","INPUT_TYPE_KINECT","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_ALL","destroy","MOUSE_INPUT_MAP","mousedown","mousemove","mouseup","button","which","pointerType","POINTER_INPUT_MAP","pointerdown","pointermove","pointerup","pointercancel","pointerout","IE10_POINTER_TYPE_ENUM","2","3","4","5","MSPointerEvent","removePointer","eventTypeNormalized","isTouch","storeIndex","pointerId","SINGLE_TOUCH_INPUT_MAP","touchstart","touchmove","touchend","touchcancel","TOUCH_INPUT_MAP","inputEvent","inputData","isMouse","PREFIXED_TOUCH_ACTION","NATIVE_TOUCH_ACTION","TOUCH_ACTION_COMPUTE","compute","getTouchAction","preventDefaults","prevented","preventDefault","hasNone","preventSrc","STATE_RECOGNIZED","STATE_FAILED","dropRecognizeWith","dropRequireFailure","hasRequireFailures","canRecognizeWith","withState","tryEmit","canEmit","inputDataClone","process","attrTest","optionPointers","isRecognized","isValid","threshold","directionTest","hasMoved","inOut","time","validPointers","validMovement","validTime","taps","interval","posThreshold","validTouchTime","failTimeout","validInterval","validMultiTap","tapCount","VERSION","domEvents","userSelect","touchSelect","touchCallout","contentZooming","userDrag","tapHighlightColor","STOP","FORCED_STOP","force","stopped","curRecognizer","existing","events","Tap","Pan","Swipe","Pinch","Rotate","Press","React","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","_createClass","defineProperties","descriptor","protoProps","staticProps","_xscroll","_xscroll2","_pullup","_pullup2","_pulldown","_pulldown2","_infinite","_infinite2","_classnames","_classnames2","_nZepto","instanceMap","_React$Component","inProps","_this","getPrototypeOf","delegateHandle","inOptions","inScrollInstance","pullup","pulldown","infinite","inHandle","xscroll","createIscroll","xscrollOptions","createInfinitePlugin","infiniteOptions","createPullUpPlugin","pullupOptions","createPullDownPlugin","pulldownOptions","onInfinite","onRefresh","render","inName","data-delegate-handle","cssClass","children","Component","propTypes","PropTypes","string","object","func","defaultProps","XScroll","userConfig","Boundry","Sticky","Fixed","BOUNDRY_CHECK_DURATION","BOUNDRY_CHECK_EASING","BOUNDRY_CHECK_ACCELERATION","version","defaultCfg","bounce","boundryCheck","gpuAcceleration","useOriginScroll","zoomType","indicatorInsets","top","bottom","left","right","width","spacing","container","content","stickyElements","fixedElements","renderTo","__timers","elCfg","parse","getAttribute","boundry","refresh","mc","sticky","fixed","_initContainer","enableGPUAcceleration","disableGPUAcceleration","getScrollPos","getScrollLeft","getScrollTop","scrollTo","scrollBy","scrollByX","scrollByY","scrollLeftBy","scrollTopBy","resetSize","renderToStyle","containerWidth","offsetWidth","height","offsetHeight","containerHeight","initSticky","initFixed","initTouchAction","fixedRenderTo","stickyRenderTo","boundryCheckX","boundryCheckY","___isEvtBind","tap","pan","touchEvents","_resetLockConfig","linear","ease","ease-in","ease-out","ease-in-out","quadratic","circular","Bezier","x1","y1","x2","y2","epsilon","curveX","t","curveY","derivativeCurveX","t0","t1","t2","d2","RAF","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","cancelRAF","cancelAnimationFrame","isfinished","_stop","_hasFinishedPercent","easingFn","_run","_raf","progress","param","originPercent","getInstance","global","Zepto","class2type","isFunction","isWindow","isDocument","DOCUMENT_NODE","isPlainObject","likeArray","$","compact","array","flatten","dasherize","classRE","classCache","RegExp","maybeAddPx","cssNumber","defaultDisplay","nodeName","display","elementDisplay","getPropertyValue","Z","dom","len","source","filtered","funcArg","payload","removeAttribute","klass","svg","baseVal","deserializeValue","parseJSON","traverseNode","fun","classList","camelize","uniq","emptyArray","column-count","columns","font-weight","line-height","z-index","zoom","fragmentRE","singleTagRE","tagExpanderRE","rootNodeRE","capitalRE","methodAttributes","adjacencyOperators","table","tableRow","containers","tr","tbody","thead","tfoot","td","th","*","readyRE","simpleSelectorRE","zepto","tempParent","propMap","tabindex","readonly","for","class","maxlength","cellspacing","cellpadding","rowspan","colspan","usemap","frameborder","contenteditable","matches","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","temp","qsa","chr","fragment","html","$1","innerHTML","attr","isZ","ready","shift","found","maybeID","maybeClass","nameOnly","isSimple","getElementById","getElementsByClassName","contains","documentElement","isEmptyObject","isNumeric","num","isFinite","elem","camelCase","uuid","support","expr","noop","elements","grep","reduce","readyState","size","every","not","is","excludes","eq","first","$this","some","closest","collection","_","parents","ancestors","pluck","contents","contentDocument","siblings","empty","show","replaceWith","newContent","before","wrap","structure","clone","wrapAll","cloneNode","append","wrapInner","unwrap","hide","toggle","setting","prev","next","originHtml","text","newText","textContent","removeAttr","attribute","removeProp","multiple","selected","coordinates","coords","parentOffset","getBoundingClientRect","pageXOffset","pageYOffset","computedStyle","removeProperty","cls","newName","toggleClass","when","hasScrollTop","scrollX","hasScrollLeft","scrollY","position","detach","dimension","dimensionProperty","operator","operatorIndex","inside","argType","arr","copyByClone","parentInDocument","zid","_zid","findHandlers","ns","matcher","matcherFor","eventCapture","captureSetting","del","focusinSupported","focus","realEvent","hover","delegator","capture","related","relatedTarget","proxy","compatible","isImmediatePropagationStopped","_args","stopPropagation","isDefaultPrevented","eventMethods","predicate","sourceMethod","returnTrue","returnFalse","defaultPrevented","returnValue","getPreventDefault","createProxy","originalEvent","ignoreProperties","specialEvents","blur","mouseenter","mouseleave","click","proxyFn","unshift","unbind","one","stopImmediatePropagation","delegate","undelegate","live","die","autoRemove","evt","liveFired","Event","triggerHandler","bubbles","triggerAndReturn","eventName","triggerGlobal","settings","ajaxStart","active","ajaxStop","ajaxBeforeSend","xhr","beforeSend","ajaxSuccess","deferred","status","success","resolveWith","ajaxComplete","ajaxError","error","rejectWith","complete","ajaxDataFilter","dataFilter","mimeToDataType","mime","htmlType","jsonType","scriptTypeRE","xmlTypeRE","appendQuery","url","query","serializeData","processData","traditional","dataType","parseArguments","serialize","params","scope","hash","jsonpID","rscript","blankRE","originAnchor","location","ajaxJSONP","ajax","responseData","abortTimeout","_callbackName","jsonpCallback","callbackName","script","originalCallback","abort","errorType","promise","ajaxSettings","XMLHttpRequest","accepts","json","xml","crossDomain","cache","urlAnchor","hashIndex","Deferred","protocol","host","hasPlaceholder","jsonp","headers","setHeader","nativeSetHeader","setRequestHeader","mimeType","overrideMimeType","contentType","onreadystatechange","getResponseHeader","responseType","response","responseText","eval","responseXML","statusText","async","open","username","password","xhrFields","send","post","getJSON","load","escape","serializeArray","field","disabled","checked","elm","submit","nativeGetComputedStyle","pseudoElement","locals","_xtop","_xright","_xleft","_xbottom","resetTop","resetLeft","resetBottom","resetRight","expandTop","expandLeft","expandRight","expandBottom","Controller","scroll","captureBounce","__scrolls","parentscroll","_bind","subscroll","_unbind","sub","lockY","isBoundryOut","getBoundryOutTop","getBoundryOutBottom","lockX","getBoundryOutLeft","getBoundryOutRight","xscrollConfig","isY","originalFixedElements","getFixedElements","renderFixedElement","els","__serializedData","fixedIndex","isRender","fixedElement","_top","renderHook","originalFixedElement","MAX_BOUNCE_DISTANCE","MIN_BAR_SCROLLED_SIZE","MIN_BAR_SIZE","transformStr","transition","ScrollBar","scrollTopOrLeft","scrollbar","_scrollHandler","_scrollEndHandler","translateZ","commonCss","indicate","_update","pos","barInfo","computeScrollBar","moveTo","containerSize","indicateSize","barPos","barSize","overTop","overBottom","barShiftSize","pct","config","__timer","isBoundryOutTop","isBoundryOutBottom","isBoundryOutLeft","isBoundryOutRight","__isEvtBind","defaultStickyRenderFunc","stickyElement","curStickyElement","forceSticky","stickyRenderFunc","_handlers","getStickiesPos","isInfinite","stickiesPos","getPos","_left","_height","_width","stickiesNum","createStickyEl","getStickyElements","serializedData","rowData","stickyHandler","indexes","curStickyIndex","max","prevStickyIndex","curStickyPos","eventsObj","_stickyRenderFunc","cur","_once","ran","eventsApi","_events","ctx","once","_callback","remaining","k","allEvents","triggerEvents","listenTo","listeningTo","_listeningTo","_listenId","listenToOnce","cb","stopListening","eventSplitter","action","rest","a1","a2","a3","OriginScroll","Core","Infinite","visibleElements","sections","translate","_initInfinite","infiniteLength","infiniteElements","visibility","_updateByScroll","_cellEventsHandler","infiniteElementsCache","tmp","elementsPos","_renderUnRecycledEl","unrecycledEl","randomId","getVisibleElements","_computeDomPositions","_containerSize","_updateByRender","_getChangedRows","newElementsPos","changedRows","recycled","_pos","_pushEl","elObj","_popEl","__infiniteIndex","_renderData","_renderStyle","console","warn","prevEl","newEl","prevElementsPos","section","sectionId","maxSpeed","_visible","elementObj","getCell","_isEvtBinded","webkitTransition","cell","cellEl","panstart","panend","insertAfter","number","Plugins","clsPrefix","loadingContent","PullDown","autoRefresh","downContent","upContent","_panStartHandler","_panHandler","_panEndHandler","__isRender","_evtBinded","containerCls","lineHeight","textAlign","_changeStatus","_expanded","loadingItv","reload","PULL_UP_HEIGHT","HEIGHT","PullUp","pullUpHeight","bufferHeight","isLoading","SimuScroll","PAN_RATE","SCROLL_ACCELERATION","BOUNDRY_ACCELERATION","transformOrigin","preventTouchMove","_setOverflowBehavior","defaltConfig","overflow","_ontouchstart","_ontouchmove","destroyScrollBars","scrollbarX","scrollbarY","__isContainerInited","transY","transX","_animate","_ontap","_unPreventHref","isRealScrollingX","isRealScrollingY","_triggerClick","_preventHref","pinch","_onpanstart","_onpan","_onpanend","thresholdY","thresholdX","__topstart","__leftstart","directionX","directionY","triggerType","computeScroll","boundryStart","boundryEnd","innerSize","_s","_t","v0","_t2","s2","isScrollingX","isScrollingY","initScrollBars","initController","controller","initMouseEvent","view","screenX","screenY","ctrlKey","altKey","shiftKey","metaKey"],"mappings":"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","file":"react-xscroll.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"classnames\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"classnames\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactXscroll\"] = factory(require(\"classnames\"), require(\"react\"));\n\telse\n\t\troot[\"ReactXscroll\"] = factory(root[\"classnames\"], root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_31__, __WEBPACK_EXTERNAL_MODULE_32__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"classnames\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"classnames\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactXscroll\"] = factory(require(\"classnames\"), require(\"react\"));\n\telse\n\t\troot[\"ReactXscroll\"] = factory(root[\"classnames\"], root[\"react\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_31__, __WEBPACK_EXTERNAL_MODULE_32__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _reactXscroll = __webpack_require__(7);\n\t\n\tvar _reactXscroll2 = _interopRequireDefault(_reactXscroll);\n\t\n\tvar _reactXscrollCtrl = __webpack_require__(11);\n\t\n\tvar _reactXscrollCtrl2 = _interopRequireDefault(_reactXscrollCtrl);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tmodule.exports = {\n\t  ReactXScroll: _reactXscroll2.default,\n\t  ReactXScrollCtrl: _reactXscrollCtrl2.default\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar SUBSTITUTE_REG = /\\\\?\\{([^{}]+)\\}/g,\n\t\tEMPTY = '';\n\t\n\tvar RE_TRIM = /^[\\s\\xa0]+|[\\s\\xa0]+$/g,\n\t\ttrim = String.prototype.trim;\n\t\n\tvar _trim = trim ?\n\t\tfunction(str) {\n\t\t\treturn str == null ? EMPTY : trim.call(str);\n\t\t} : function(str) {\n\t\t\treturn str == null ? EMPTY : (str + '').replace(RE_TRIM, EMPTY);\n\t\t};\n\t\n\tfunction upperCase() {\n\t\treturn arguments[1].toUpperCase();\n\t}\n\t\n\tfunction Empty() {}\n\t\n\tfunction createObject(proto, constructor) {\n\t\tvar newProto;\n\t\tif (Object.create) {\n\t\t\tnewProto = Object.create(proto);\n\t\t} else {\n\t\t\tEmpty.prototype = proto;\n\t\t\tnewProto = new Empty();\n\t\t}\n\t\tnewProto.constructor = constructor;\n\t\treturn newProto;\n\t}\n\t\n\tfunction getNodes(node, rootNode) {\n\t\tif (!node) return;\n\t\tif (node.nodeType) return [node];\n\t\tvar rootNode = rootNode && rootNode.nodeType ? rootNode : document;\n\t\tif (node && typeof node === \"string\") {\n\t\t\treturn rootNode.querySelectorAll(node);\n\t\t}\n\t\treturn;\n\t}\n\t\n\t// Useful for temporary DOM ids.\n\tvar idCounter = 0;\n\t\n\tvar getOffsetTop = function(el) {\n\t\tvar offset = el.offsetTop;\n\t\tif (el.offsetParent != null) offset += getOffsetTop(el.offsetParent);\n\t\treturn offset;\n\t};\n\tvar getOffsetLeft = function(el) {\n\t\tvar offset = el.offsetLeft;\n\t\tif (el.offsetParent != null) offset += getOffsetLeft(el.offsetParent);\n\t\treturn offset;\n\t};\n\t\n\tvar Util = {\n\t\t// Is a given variable an object?\n\t\tisObject: function(obj) {\n\t\t\treturn obj === Object(obj);\n\t\t},\n\t\tisArray: Array.isArray || function(obj) {\n\t\t\treturn toString.call(obj) == '[object Array]';\n\t\t},\n\t\t// Is a given array, string, or object empty?\n\t\t// An \"empty\" object has no enumerable own-properties.\n\t\tisEmpty: function(obj) {\n\t\t\tif (obj == null) return true;\n\t\t\tif (this.isArray(obj) || this.isString(obj)) return obj.length === 0;\n\t\t\tfor (var key in obj)\n\t\t\t\tif (this.has(obj, key)) return false;\n\t\t\treturn true;\n\t\t},\n\t\tmix: function(to, from, deep) {\n\t\t\tfor (var i in from) {\n\t\t\t\tto[i] = from[i];\n\t\t\t}\n\t\t\treturn to;\n\t\t},\n\t\textend: function(r, s, px, sx) {\n\t\t\tif (!s || !r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t\tvar sp = s.prototype,\n\t\t\t\trp;\n\t\t\t// add prototype chain\n\t\t\trp = createObject(sp, r);\n\t\t\tr.prototype = this.mix(rp, r.prototype);\n\t\t\tr.superclass = createObject(sp, s);\n\t\t\t// add prototype overrides\n\t\t\tif (px) {\n\t\t\t\tthis.mix(rp, px);\n\t\t\t}\n\t\t\t// add object overrides\n\t\t\tif (sx) {\n\t\t\t\tthis.mix(r, sx);\n\t\t\t}\n\t\t\treturn r;\n\t\t},\n\t\t/**\n\t\t * test whether a string start with a specified substring\n\t\t * @param {String} str the whole string\n\t\t * @param {String} prefix a specified substring\n\t\t * @return {Boolean} whether str start with prefix\n\t\t * @member util\n\t\t */\n\t\tstartsWith: function(str, prefix) {\n\t\t\treturn str.lastIndexOf(prefix, 0) === 0;\n\t\t},\n\t\n\t\t/**\n\t\t * test whether a string end with a specified substring\n\t\t * @param {String} str the whole string\n\t\t * @param {String} suffix a specified substring\n\t\t * @return {Boolean} whether str end with suffix\n\t\t * @member util\n\t\t */\n\t\tendsWith: function(str, suffix) {\n\t\t\tvar ind = str.length - suffix.length;\n\t\t\treturn ind >= 0 && str.indexOf(suffix, ind) === ind;\n\t\t},\n\t\t/**\n\t\t * Removes the whitespace from the beginning and end of a string.\n\t\t * @method\n\t\t * @member util\n\t\t */\n\t\ttrim: _trim,\n\t\t/**\n\t\t * Substitutes keywords in a string using an object/array.\n\t\t * Removes undef keywords and ignores escaped keywords.\n\t\t * @param {String} str template string\n\t\t * @param {Object} o json data\n\t\t * @member util\n\t\t * @param {RegExp} [regexp] to match a piece of template string\n\t\t */\n\t\tsubstitute: function(str, o, regexp) {\n\t\t\tif (typeof str !== 'string' || !o) {\n\t\t\t\treturn str;\n\t\t\t}\n\t\n\t\t\treturn str.replace(regexp || SUBSTITUTE_REG, function(match, name) {\n\t\t\t\tif (match.charAt(0) === '\\\\') {\n\t\t\t\t\treturn match.slice(1);\n\t\t\t\t}\n\t\t\t\treturn (o[name] === undefined) ? EMPTY : o[name];\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * vendors\n\t\t * @return { String } webkit|moz|ms|o\n\t\t * @memberOf Util\n\t\t */\n\t\tvendor: (function() {\n\t\t\tvar el = document.createElement('div').style;\n\t\t\tvar vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],\n\t\t\t\ttransform,\n\t\t\t\ti = 0,\n\t\t\t\tl = vendors.length;\n\t\t\tfor (; i < l; i++) {\n\t\t\t\ttransform = vendors[i] + 'ransform';\n\t\t\t\tif (transform in el) return vendors[i].substr(0, vendors[i].length - 1);\n\t\t\t}\n\t\t\treturn false;\n\t\t})(),\n\t\t/**\n\t\t *  add vendor to attribute\n\t\t *  @memberOf Util\n\t\t *  @param {String} attrName name of attribute\n\t\t *  @return { String }\n\t\t **/\n\t\tprefixStyle: function(attrName) {\n\t\t\tif (this.vendor === false) return false;\n\t\t\tif (this.vendor === '') return attrName;\n\t\t\treturn this.vendor + attrName.charAt(0).toUpperCase() + attrName.substr(1);\n\t\t},\n\t\t/**\n\t\t * judge if has class\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t * @param  {String}  className\n\t\t * @return {Boolean}\n\t\t */\n\t\thasClass: function(el, className) {\n\t\t\treturn el && el.className && className && el.className.indexOf(className) != -1;\n\t\t},\n\t\t/**\n\t\t * add className for the element\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t * @param  {String}  className\n\t\t */\n\t\taddClass: function(el, className) {\n\t\t\tif (el && className && !this.hasClass(el, className)) {\n\t\t\t\tel.className += \" \" + className;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * remove className for the element\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t * @param  {String}  className\n\t\t */\n\t\tremoveClass: function(el, className) {\n\t\t\tif (el && el.className && className) {\n\t\t\t\tel.className = el.className.replace(className, \"\");\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * remove an element\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t */\n\t\tremove: function(el) {\n\t\t\tif (!el || !el.parentNode) return;\n\t\t\tel.parentNode.removeChild(el);\n\t\t},\n\t\t/**\n\t\t * get offset top\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}   el\n\t\t * @return {Number} offsetTop\n\t\t */\n\t\tgetOffsetTop: getOffsetTop,\n\t\t/**\n\t\t * get offset left\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement}  el\n\t\t * @return {Number} offsetLeft\n\t\t */\n\t\tgetOffsetLeft: getOffsetLeft,\n\t\t/**\n\t\t * get offset left\n\t\t * @memberOf Util\n\t\t * @param  {HTMLElement} el\n\t\t * @param  {String} selector\n\t\t * @param  {HTMLElement} rootNode\n\t\t * @return {HTMLElement} parent element\n\t\t */\n\t\tfindParentEl: function(el, selector, rootNode) {\n\t\t\tvar rs = null,\n\t\t\t\tparent = null;\n\t\t\tvar type = /^#/.test(selector) ? \"id\" : /^\\./.test(selector) ? \"class\" : \"tag\";\n\t\t\tvar sel = selector.replace(/\\.|#/g, \"\");\n\t\t\tif (rootNode && typeof rootNode === \"string\") {\n\t\t\t\trootNode = document.querySelector(rootNode);\n\t\t\t}\n\t\t\trootNode = rootNode || document.body;\n\t\t\tif (!el || !selector) return;\n\t\t\tif (type == \"class\" && el.className && el.className.match(sel)) {\n\t\t\t\treturn el;\n\t\t\t} else if (type == \"id\" && el.id && _trim(el.id) == sel) {\n\t\t\t\treturn el;\n\t\t\t} else if (type == \"tag\" && el.tagName.toLowerCase() == sel) {\n\t\t\t\treturn el;\n\t\t\t}\n\t\t\twhile (!rs) {\n\t\t\t\tif (parent == rootNode) break;\n\t\t\t\tparent = el.parentNode;\n\t\t\t\tif (!parent) break;\n\t\t\t\tif ((type == \"class\" && parent.className && parent.className.match(sel)) || (type == \"id\" && parent.id && _trim(parent.id) == sel) || (type == \"tag\" && parent.tagName && parent.tagName.toLowerCase() == sel)) {\n\t\t\t\t\trs = parent\n\t\t\t\t\treturn rs;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tel = parent;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\t/**\n\t\t * Generate a unique integer id (unique within the entire client session).\n\t\t * @param  {String} prefix\n\t\t * @return {String} guid\n\t\t */\n\t\tguid: function(prefix) {\n\t\t\tvar id = ++idCounter + '';\n\t\t\treturn prefix ? prefix + id : id;\n\t\t},\n\t\t/**\n\t\t * judge if is an android os\n\t\t * @return {Boolean} [description]\n\t\t */\n\t\tisAndroid: function() {\n\t\t\treturn /Android /.test(window.navigator.appVersion);\n\t\t},\n\t\t/**\n\t\t * judge if is an android device with low  performance\n\t\t * @return {Boolean}\n\t\t */\n\t\tisBadAndroid: function() {\n\t\t\treturn /Android /.test(window.navigator.appVersion) && !(/Chrome\\/\\d/.test(window.navigator.appVersion))\n\t\t},\n\t\tpx2Num: function(px) {\n\t\t\treturn Number(px.replace(/px/, ''));\n\t\t},\n\t\tgetNodes: getNodes,\n\t\tgetNode: function(node, rootNode) {\n\t\t\tvar nodes = getNodes(node, rootNode);\n\t\t\treturn nodes && nodes[0];\n\t\t},\n\t\tstringifyStyle: function(style) {\n\t\t\tvar styleStr = \"\";\n\t\t\tfor (var i in style) {\n\t\t\t\tstyleStr += [i, \":\", style[i], \";\"].join(\"\");\n\t\t\t}\n\t\t\treturn styleStr;\n\t\t}\n\t}\n\t\n\t// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n\tvar names = ['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'];\n\tfor (var i = 0; i < names.length; i++) {\n\t\tUtil['is' + names[i]] = function(obj) {\n\t\t\treturn toString.call(obj) == '[object ' + names[i] + ']';\n\t\t};\n\t}\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Util;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Util;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Events = __webpack_require__(24);\n\t/** \n\t      @constructor \n\t      @mixes Events\n\t      */\n\tvar Base = function() {}\n\t\n\tUtil.mix(Base.prototype, Events);\n\t\n\tUtil.mix(Base.prototype, {\n\t\t/**\n\t\t * @memberof Base\n\t\t * @param  {object} plugin plug a plugin\n\t\t */\n\t\tplug: function(plugin) {\n\t\t\tvar self = this;\n\t\t\tif (!plugin || !plugin.pluginId) return;\n\t\t\tif (!self.__plugins) {\n\t\t\t\tself.__plugins = [];\n\t\t\t}\n\t\t\tvar __plugin = self.getPlugin(plugin.pluginId);\n\t\t\t__plugin && self.unplug(plugin.pluginId);\n\t\t\tplugin.pluginInitializer(self);\n\t\t\tself.__plugins.push(plugin);\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * @memberof Base\n\t\t * @param  {object|string} plugin unplug a plugin by pluginId or plugin instance\n\t\t */\n\t\tunplug: function(plugin) {\n\t\t\tvar self = this;\n\t\t\tif (!plugin || !self.__plugins) return;\n\t\t\tvar _plugin = typeof plugin == \"string\" ? self.getPlugin(plugin) : plugin;\n\t\t\t_plugin.pluginDestructor(self);\n\t\t\tfor (var i = 0, l = self.__plugins.length;i < l;i++) {\n\t\t\t\tif (self.__plugins[i] == _plugin) {\n\t\t\t\t\treturn self.__plugins.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * @memberof Base\n\t\t * @param  {object|string} plugin get plugin by pluginId\n\t\t */\n\t\tgetPlugin: function(pluginId) {\n\t\t\tvar self = this;\n\t\t\tvar plugins = [];\n\t\t\tif(!self.__plugins) return;\n\t\t\tfor (var i = 0, l = self.__plugins.length;i < l;i++) {\n\t\t\t\tif (self.__plugins[i] && self.__plugins[i].pluginId == pluginId) {\n\t\t\t\t\tplugins.push(self.__plugins[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn plugins.length > 1 ? plugins : plugins[0] || null;\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Base;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Base;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Timer = __webpack_require__(10);\n\tvar Easing = __webpack_require__(9);\n\tvar Base = __webpack_require__(2);\n\t//transform\n\tvar vendorTransform = Util.prefixStyle(\"transform\");\n\t//transition webkitTransition MozTransition OTransition msTtransition\n\tvar vendorTransition = Util.prefixStyle(\"transition\");\n\t\n\tvar vendorTransitionDuration = Util.prefixStyle(\"transitionDuration\");\n\t\n\tvar vendorTransformOrigin = Util.prefixStyle(\"transformOrigin\");\n\t\n\tvar vendorTransitionEnd = Util.vendor ? Util.prefixStyle(\"transitionEnd\") : \"transitionend\";\n\t\n\tvar vendorTransformStr = Util.vendor ? [\"-\", Util.vendor, \"-transform\"].join(\"\") : \"transform\";\n\t\n\tvar translateTpl = 'translateX({translateX}px) translateY({translateY}px) translateZ(0)';\n\t//limit attrs\n\tvar animAttrs = {\n\t\t'transform': true,\n\t\t'opacity': true,\n\t\t'scrollTop': true,\n\t\t'scrollLeft': true\n\t};\n\t\n\tfunction myParse(v) {\n\t\treturn Math.round(parseFloat(v) * 1e5) / 1e5;\n\t}\n\t\n\tfunction defaultDecompose() {\n\t\treturn {\n\t\t\ttranslateX: 0,\n\t\t\ttranslateY: 0,\n\t\t\trotate: 0,\n\t\t\tskewX: 0,\n\t\t\tskewY: 0,\n\t\t\tscaleX: 1,\n\t\t\tscaleY: 1\n\t\t};\n\t}\n\t\n\tfunction toMatrixArray(matrix) {\n\t\tmatrix = matrix.split(/,/);\n\t\tmatrix = Array.prototype.map.call(matrix, function(v) {\n\t\t\treturn myParse(v);\n\t\t});\n\t\treturn matrix;\n\t}\n\t\n\tfunction decomposeMatrix(matrix) {\n\t\tmatrix = toMatrixArray(matrix);\n\t\tvar scaleX, scaleY, skew,\n\t\t\tA = matrix[0],\n\t\t\tB = matrix[1],\n\t\t\tC = matrix[2],\n\t\t\tD = matrix[3];\n\t\n\t\t// Make sure matrix is not singular\n\t\tif (A * D - B * C) {\n\t\t\tscaleX = Math.sqrt(A * A + B * B);\n\t\t\tskew = (A * C + B * D) / (A * D - C * B);\n\t\t\tscaleY = (A * D - B * C) / scaleX;\n\t\t\t// step (6)\n\t\t\tif (A * D < B * C) {\n\t\t\t\tskew = -skew;\n\t\t\t\tscaleX = -scaleX;\n\t\t\t}\n\t\t\t// matrix is singular and cannot be interpolated\n\t\t} else {\n\t\t\t// In this case the elem shouldn't be rendered, hence scale == 0\n\t\t\tscaleX = scaleY = skew = 0;\n\t\t}\n\t\n\t\t// The recomposition order is very important\n\t\t// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971\n\t\treturn {\n\t\t\ttranslateX: myParse(matrix[4]),\n\t\t\ttranslateY: myParse(matrix[5]),\n\t\t\trotate: myParse(Math.atan2(B, A) * 180 / Math.PI),\n\t\t\tskewX: myParse(Math.atan(skew) * 180 / Math.PI),\n\t\t\tskewY: 0,\n\t\t\tscaleX: myParse(scaleX),\n\t\t\tscaleY: myParse(scaleY)\n\t\t};\n\t}\n\t\n\tfunction getTransformInfo(transform) {\n\t\ttransform = transform.split(')');\n\t\tvar trim = Util.trim,\n\t\t\ti = -1,\n\t\t\tl = transform.length - 1,\n\t\t\tsplit, prop, val,\n\t\t\tret = defaultDecompose();\n\t\n\t\t// Loop through the transform properties, parse and multiply them\n\t\twhile (++i < l) {\n\t\t\tsplit = transform[i].split('(');\n\t\t\tprop = trim(split[0]);\n\t\t\tval = split[1];\n\t\t\tswitch (prop) {\n\t\t\t\tcase 'translateX':\n\t\t\t\tcase 'translateY':\n\t\t\t\tcase 'scaleX':\n\t\t\t\tcase 'scaleY':\n\t\t\t\t\tret[prop] = myParse(val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'translate':\n\t\t\t\tcase 'translate3d':\n\t\t\t\t\tval = val.split(',');\n\t\t\t\t\tret.translateX = myParse(val[0]);\n\t\t\t\t\tret.translateY = myParse(val[1] || 0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'scale':\n\t\t\t\t\tval = val.split(',');\n\t\t\t\t\tret.scaleX = myParse(val[0]);\n\t\t\t\t\tret.scaleY = myParse(val[1] || val[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'matrix':\n\t\t\t\t\treturn decomposeMatrix(val);\n\t\t\t}\n\t\t}\n\t\n\t\treturn ret;\n\t}\n\t\n\t/**\n\t * animate function\n\t * @constructor\n\t * @param {HTMLElement} el element to animate\n\t * @param {Object} config config for animate\n\t * @param {Object} config.css\n\t * @param {Number} config.duration\n\t * @param {String} config.easing\n\t * @extends {Base}\n\t */\n\tfunction Animate(el, cfg) {\n\t\tif (!el || !cfg || !cfg.css) return;\n\t\tvar self = this;\n\t\tself.cfg = cfg;\n\t\tself.el = el;\n\t\tvar duration = cfg.duration || 0,\n\t\t\teasing = cfg.easing || \"ease\",\n\t\t\tdelay = cfg.delay || 0;\n\t\t//trigger run\n\t\tif (cfg.run) {\n\t\t\t//frame animate\n\t\t\tself.timer = self.timer || new Timer({\n\t\t\t\tduration: Math.round(duration),\n\t\t\t\teasing: easing,\n\t\t\t});\n\t\t\tself.timer.on(\"run\", cfg.run);\n\t\t}\n\t\tself._bindEvt();\n\t\treturn self;\n\t}\n\t\n\tfunction computeTransform(prevTransform, destTransform) {\n\t\tvar transform = getTransformInfo(prevTransform);\n\t\tvar dest = getTransformInfo(destTransform);\n\t\tvar trans = {};\n\t\tfor (var i in dest) {\n\t\t\ttrans[i] = {\n\t\t\t\tprevVal: transform[i],\n\t\t\t\tnewVal: dest[i]\n\t\t\t}\n\t\t}\n\t\treturn trans;\n\t}\n\t\n\t//for scroll only\n\tfunction setStyle(el, styleName, prevVal, newVal, percent) {\n\t\tprevVal = isNaN(Number(prevVal)) ? 0 : Number(prevVal);\n\t\tvar curVal = ((newVal - prevVal) * percent + prevVal);\n\t\tcss(el, styleName, curVal);\n\t}\n\t\n\tfunction css(el, styleName, val) {\n\t\tswitch (styleName) {\n\t\t\tcase \"scrollTop\":\n\t\t\tcase \"scrollLeft\":\n\t\t\t\tel[styleName] = val;\n\t\t\t\tbreak;\n\t\t\tcase \"transform\":\n\t\t\t\tel.style[vendorTransform] = val;\n\t\t\tcase \"opacity\":\n\t\t\t\tel.style[styleName] = val;\n\t\t\t\tbreak;\n\t\n\t\t}\n\t}\n\t\n\tUtil.extend(Animate, Base, {\n\t\t/**\n\t\t * to start the animation\n\t\t * @memberof Animate\n\t\t * @return {Animate}\n\t\t */\n\t\trun: function() {\n\t\t\tvar self = this;\n\t\t\tvar cfg = self.cfg,\n\t\t\t\tel = self.el,\n\t\t\t\tduration = cfg.duration || 0,\n\t\t\t\teasing = cfg.easing || \"ease\",\n\t\t\t\tdelay = cfg.delay || 0;\n\t\t\tself.__isTransitionEnd = false;\n\t\t\tclearTimeout(self.__itv)\n\t\t\tself.timer && self.timer.run();\n\t\t\tif (duration <= Timer.MIN_DURATION) {\n\t\t\t\tfor (var i in cfg.css) {\n\t\t\t\t\tcss(el, i, cfg.css[i]);\n\t\t\t\t}\n\t\t\t\tself.stop()\n\t\t\t\tself.__handlers.stop.call(self);\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif(Util.isBadAndroid()){\n\t\t\t\t//use frame animate on bad android device\n\t\t\t\tcfg.useTransition = false;\n\t\t\t}\n\t\n\t\t\tif (cfg.useTransition) {\n\t\t\t\t//transition\n\t\t\t\tel.style[vendorTransition] = Util.substitute('all {duration}ms {easing} {delay}ms', {\n\t\t\t\t\tduration: Math.round(duration),\n\t\t\t\t\teasing: Easing.format(easing),\n\t\t\t\t\tdelay: delay\n\t\t\t\t});\n\t\t\t\tfor (var i in cfg.css) {\n\t\t\t\t\t//set css\n\t\t\t\t\tcss(el, i, cfg.css[i]);\n\t\t\t\t}\n\t\t\t\tself.__itv = setTimeout(function() {\n\t\t\t\t\tif (!self.__isTransitionEnd) {\n\t\t\t\t\t\tself.__isTransitionEnd = true;\n\t\t\t\t\t\tself.trigger(\"transitionend\");\n\t\t\t\t\t}\n\t\t\t\t}, Number(duration) + 60);\n\t\t\t} else {\n\t\t\t\tself.computeStyle = self.computeStyle || window.getComputedStyle(el);\n\t\t\t\t//transform\n\t\t\t\tif (cfg.css.transform && self.timer) {\n\t\t\t\t\tvar transmap = self.transmap = computeTransform(self.computeStyle[vendorTransform], cfg.css.transform);\n\t\t\t\t\tself.timer.off(\"run\", self.__handlers.transRun);\n\t\t\t\t\tself.timer.on(\"run\", self.__handlers.transRun, self);\n\t\t\t\t\tself.timer.off(\"end\",self.__handlers.transRun);\n\t\t\t\t\tself.timer.on(\"end\", self.__handlers.transRun, self);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_transitionEndHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tself.stop();\n\t\t\tself.__handlers.stop.call(self);\n\t\t},\n\t\t__handlers: {\n\t\t\ttransRun: function(e) {\n\t\t\t\tvar self = this;\n\t\t\t\tvar transmap = self.transmap;\n\t\t\t\tvar el = self.el;\n\t\t\t\tvar newTrans = {};\n\t\t\t\tfor (var i in transmap) {\n\t\t\t\t\tnewTrans[i] = (transmap[i].newVal - transmap[i].prevVal) * e.percent + transmap[i].prevVal\n\t\t\t\t}\n\t\t\t\tvar ret = Util.substitute(translateTpl + ' ' +\n\t\t\t\t\t'scale({scaleX},{scaleY})', newTrans);\n\t\t\t\tel.style[vendorTransform] = ret;\n\t\t\t},\n\t\t\tstop: function(e) {\n\t\t\t\tvar self = this;\n\t\t\t\tvar cfg = self.cfg;\n\t\t\t\tcfg.end && cfg.end({\n\t\t\t\t\tpercent: 1\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tvar cfg = self.cfg;\n\t\t\tvar el = self.el;\n\t\t\tself.el.addEventListener(vendorTransitionEnd, function(e) {\n\t\t\t\tself.__isTransitionEnd = true;\n\t\t\t\tif (e.target !== e.currentTarget) return;\n\t\t\t\tself.trigger(\"transitionend\", e);\n\t\t\t})\n\t\t\tself.on(\"transitionend\", self._transitionEndHandler, self);\n\t\t\tvar cssRun = function(e) {\n\t\t\t\tself.computeStyle = self.computeStyle || window.getComputedStyle(el);\n\t\t\t\tfor (var i in cfg.css) {\n\t\t\t\t\tif (!/transform/.test(i)) {\n\t\t\t\t\t\tsetStyle(self.el, i, self.computeStyle[i], cfg.css[i], e.percent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tself.timer && self.timer.on(\"run\", cssRun);\n\t\t\tself.timer && self.timer.on(\"stop\", self.__handlers.stop, self);\n\t\t},\n\t\t/**\n\t\t * to stop the animation\n\t\t * @memberof Animate\n\t\t * @return {Animate}\n\t\t */\n\t\tstop: function() {\n\t\t\tvar self = this;\n\t\t\tif (self.cfg.useTransition && self.cfg.duration > Timer.MIN_DURATION) {\n\t\t\t\tvar computeStyle = window.getComputedStyle(this.el);\n\t\t\t\tfor (var i in self.cfg.css) {\n\t\t\t\t\tif (animAttrs[i]) {\n\t\t\t\t\t\tvar value = /transform/.test(i) ? computeStyle[vendorTransform] : computeStyle[i];\n\t\t\t\t\t\tcss(self.el, i, Util.substitute(translateTpl + ' ' + 'scale({scaleX},{scaleY})', getTransformInfo(value)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tself.el.style[vendorTransition] = \"none\";\n\t\t\t}\n\t\t\tself.timer && self.timer.stop() && self.timer.reset();\n\t\t\tself.computeStyle = null;\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * to reset the animation to a new state\n\t\t * @memberof Animate\n\t\t * @param {object} cfg cfg for new animation\n\t\t * @return {Animate}\n\t\t */\n\t\treset: function(cfg) {\n\t\t\tvar self = this;\n\t\t\tself.computeStyle = null;\n\t\t\tUtil.mix(self.cfg, cfg);\n\t\t\tthis.timer && self.timer.reset({\n\t\t\t\tduration: Math.round(self.cfg.duration),\n\t\t\t\teasing: self.cfg.easing\n\t\t\t});\n\t\t\treturn self;\n\t\t}\n\t});\n\t\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Animate;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Animate;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t/*! Hammer.JS - v2.0.4 - 2014-09-28\n\t * http://hammerjs.github.io/\n\t *\n\t * Copyright (c) 2014 Jorik Tangelder;\n\t * Licensed under the MIT license */\n\t  'use strict';\n\t\n\tvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\n\tvar TEST_ELEMENT = document.createElement('div');\n\t\n\tvar TYPE_FUNCTION = 'function';\n\t\n\tvar round = Math.round;\n\tvar abs = Math.abs;\n\tvar now = Date.now;\n\t\n\t/**\n\t * set a timeout with a given scope\n\t * @param {Function} fn\n\t * @param {Number} timeout\n\t * @param {Object} context\n\t * @returns {number}\n\t */\n\tfunction setTimeoutContext(fn, timeout, context) {\n\t    return setTimeout(bindFn(fn, context), timeout);\n\t}\n\t\n\t/**\n\t * if the argument is an array, we want to execute the fn on each entry\n\t * if it aint an array we don't want to do a thing.\n\t * this is used by all the methods that accept a single and array argument.\n\t * @param {*|Array} arg\n\t * @param {String} fn\n\t * @param {Object} [context]\n\t * @returns {Boolean}\n\t */\n\tfunction invokeArrayArg(arg, fn, context) {\n\t    if (Array.isArray(arg)) {\n\t        each(arg, context[fn], context);\n\t        return true;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * walk objects and arrays\n\t * @param {Object} obj\n\t * @param {Function} iterator\n\t * @param {Object} context\n\t */\n\tfunction each(obj, iterator, context) {\n\t    var i;\n\t\n\t    if (!obj) {\n\t        return;\n\t    }\n\t\n\t    if (obj.forEach) {\n\t        obj.forEach(iterator, context);\n\t    } else if (obj.length !== undefined) {\n\t        i = 0;\n\t        while (i < obj.length) {\n\t            iterator.call(context, obj[i], i, obj);\n\t            i++;\n\t        }\n\t    } else {\n\t        for (i in obj) {\n\t            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * extend object.\n\t * means that properties in dest will be overwritten by the ones in src.\n\t * @param {Object} dest\n\t * @param {Object} src\n\t * @param {Boolean} [merge]\n\t * @returns {Object} dest\n\t */\n\tfunction extend(dest, src, merge) {\n\t    var keys = Object.keys(src);\n\t    var i = 0;\n\t    while (i < keys.length) {\n\t        if (!merge || (merge && dest[keys[i]] === undefined)) {\n\t            dest[keys[i]] = src[keys[i]];\n\t        }\n\t        i++;\n\t    }\n\t    return dest;\n\t}\n\t\n\t/**\n\t * merge the values from src in the dest.\n\t * means that properties that exist in dest will not be overwritten by src\n\t * @param {Object} dest\n\t * @param {Object} src\n\t * @returns {Object} dest\n\t */\n\tfunction merge(dest, src) {\n\t    return extend(dest, src, true);\n\t}\n\t\n\t/**\n\t * simple class inheritance\n\t * @param {Function} child\n\t * @param {Function} base\n\t * @param {Object} [properties]\n\t */\n\tfunction inherit(child, base, properties) {\n\t    var baseP = base.prototype,\n\t        childP;\n\t\n\t    childP = child.prototype = Object.create(baseP);\n\t    childP.constructor = child;\n\t    childP._super = baseP;\n\t\n\t    if (properties) {\n\t        extend(childP, properties);\n\t    }\n\t}\n\t\n\t/**\n\t * simple function bind\n\t * @param {Function} fn\n\t * @param {Object} context\n\t * @returns {Function}\n\t */\n\tfunction bindFn(fn, context) {\n\t    return function boundFn() {\n\t        return fn.apply(context, arguments);\n\t    };\n\t}\n\t\n\t/**\n\t * let a boolean value also be a function that must return a boolean\n\t * this first item in args will be used as the context\n\t * @param {Boolean|Function} val\n\t * @param {Array} [args]\n\t * @returns {Boolean}\n\t */\n\tfunction boolOrFn(val, args) {\n\t    if (typeof val == TYPE_FUNCTION) {\n\t        return val.apply(args ? args[0] || undefined : undefined, args);\n\t    }\n\t    return val;\n\t}\n\t\n\t/**\n\t * use the val2 when val1 is undefined\n\t * @param {*} val1\n\t * @param {*} val2\n\t * @returns {*}\n\t */\n\tfunction ifUndefined(val1, val2) {\n\t    return (val1 === undefined) ? val2 : val1;\n\t}\n\t\n\t/**\n\t * addEventListener with multiple events at once\n\t * @param {EventTarget} target\n\t * @param {String} types\n\t * @param {Function} handler\n\t */\n\tfunction addEventListeners(target, types, handler) {\n\t    each(splitStr(types), function(type) {\n\t        target.addEventListener(type, handler, false);\n\t    });\n\t}\n\t\n\t/**\n\t * removeEventListener with multiple events at once\n\t * @param {EventTarget} target\n\t * @param {String} types\n\t * @param {Function} handler\n\t */\n\tfunction removeEventListeners(target, types, handler) {\n\t    each(splitStr(types), function(type) {\n\t        target.removeEventListener(type, handler, false);\n\t    });\n\t}\n\t\n\t/**\n\t * find if a node is in the given parent\n\t * @method hasParent\n\t * @param {HTMLElement} node\n\t * @param {HTMLElement} parent\n\t * @return {Boolean} found\n\t */\n\tfunction hasParent(node, parent) {\n\t    while (node) {\n\t        if (node == parent) {\n\t            return true;\n\t        }\n\t        node = node.parentNode;\n\t    }\n\t    return false;\n\t}\n\t\n\t/**\n\t * small indexOf wrapper\n\t * @param {String} str\n\t * @param {String} find\n\t * @returns {Boolean} found\n\t */\n\tfunction inStr(str, find) {\n\t    return str.indexOf(find) > -1;\n\t}\n\t\n\t/**\n\t * split string on whitespace\n\t * @param {String} str\n\t * @returns {Array} words\n\t */\n\tfunction splitStr(str) {\n\t    return str.trim().split(/\\s+/g);\n\t}\n\t\n\t/**\n\t * find if a array contains the object using indexOf or a simple polyFill\n\t * @param {Array} src\n\t * @param {String} find\n\t * @param {String} [findByKey]\n\t * @return {Boolean|Number} false when not found, or the index\n\t */\n\tfunction inArray(src, find, findByKey) {\n\t    if (src.indexOf && !findByKey) {\n\t        return src.indexOf(find);\n\t    } else {\n\t        var i = 0;\n\t        while (i < src.length) {\n\t            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n\t                return i;\n\t            }\n\t            i++;\n\t        }\n\t        return -1;\n\t    }\n\t}\n\t\n\t/**\n\t * convert array-like objects to real arrays\n\t * @param {Object} obj\n\t * @returns {Array}\n\t */\n\tfunction toArray(obj) {\n\t    return Array.prototype.slice.call(obj, 0);\n\t}\n\t\n\t/**\n\t * unique array with objects based on a key (like 'id') or just by the array's value\n\t * @param {Array} src [{id:1},{id:2},{id:1}]\n\t * @param {String} [key]\n\t * @param {Boolean} [sort=False]\n\t * @returns {Array} [{id:1},{id:2}]\n\t */\n\tfunction uniqueArray(src, key, sort) {\n\t    var results = [];\n\t    var values = [];\n\t    var i = 0;\n\t\n\t    while (i < src.length) {\n\t        var val = key ? src[i][key] : src[i];\n\t        if (inArray(values, val) < 0) {\n\t            results.push(src[i]);\n\t        }\n\t        values[i] = val;\n\t        i++;\n\t    }\n\t\n\t    if (sort) {\n\t        if (!key) {\n\t            results = results.sort();\n\t        } else {\n\t            results = results.sort(function sortUniqueArray(a, b) {\n\t                return a[key] > b[key];\n\t            });\n\t        }\n\t    }\n\t\n\t    return results;\n\t}\n\t\n\t/**\n\t * get the prefixed property\n\t * @param {Object} obj\n\t * @param {String} property\n\t * @returns {String|Undefined} prefixed\n\t */\n\tfunction prefixed(obj, property) {\n\t    var prefix, prop;\n\t    var camelProp = property[0].toUpperCase() + property.slice(1);\n\t\n\t    var i = 0;\n\t    while (i < VENDOR_PREFIXES.length) {\n\t        prefix = VENDOR_PREFIXES[i];\n\t        prop = (prefix) ? prefix + camelProp : property;\n\t\n\t        if (prop in obj) {\n\t            return prop;\n\t        }\n\t        i++;\n\t    }\n\t    return undefined;\n\t}\n\t\n\t/**\n\t * get a unique id\n\t * @returns {number} uniqueId\n\t */\n\tvar _uniqueId = 1;\n\tfunction uniqueId() {\n\t    return _uniqueId++;\n\t}\n\t\n\t/**\n\t * get the window object of an element\n\t * @param {HTMLElement} element\n\t * @returns {DocumentView|Window}\n\t */\n\tfunction getWindowForElement(element) {\n\t    var doc = element.ownerDocument;\n\t    return (doc.defaultView || doc.parentWindow);\n\t}\n\t\n\tvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\t\n\tvar SUPPORT_TOUCH = ('ontouchstart' in window);\n\tvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n\tvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\t\n\tvar INPUT_TYPE_TOUCH = 'touch';\n\tvar INPUT_TYPE_PEN = 'pen';\n\tvar INPUT_TYPE_MOUSE = 'mouse';\n\tvar INPUT_TYPE_KINECT = 'kinect';\n\t\n\tvar COMPUTE_INTERVAL = 25;\n\t\n\tvar INPUT_START = 1;\n\tvar INPUT_MOVE = 2;\n\tvar INPUT_END = 4;\n\tvar INPUT_CANCEL = 8;\n\t\n\tvar DIRECTION_NONE = 1;\n\tvar DIRECTION_LEFT = 2;\n\tvar DIRECTION_RIGHT = 4;\n\tvar DIRECTION_UP = 8;\n\tvar DIRECTION_DOWN = 16;\n\t\n\tvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n\tvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n\tvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\t\n\tvar PROPS_XY = ['x', 'y'];\n\tvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\t\n\t/**\n\t * create new input type manager\n\t * @param {Manager} manager\n\t * @param {Function} callback\n\t * @returns {Input}\n\t * @constructor\n\t */\n\tfunction Input(manager, callback) {\n\t    var self = this;\n\t    this.manager = manager;\n\t    this.callback = callback;\n\t    this.element = manager.element;\n\t    this.target = manager.options.inputTarget;\n\t\n\t    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n\t    // so when disabled the input events are completely bypassed.\n\t    this.domHandler = function(ev) {\n\t        if (boolOrFn(manager.options.enable, [manager])) {\n\t            self.handler(ev);\n\t        }\n\t    };\n\t\n\t    this.init();\n\t\n\t}\n\t\n\tInput.prototype = {\n\t    /**\n\t     * should handle the inputEvent data and trigger the callback\n\t     * @virtual\n\t     */\n\t    handler: function() { },\n\t\n\t    /**\n\t     * bind the events\n\t     */\n\t    init: function() {\n\t        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n\t        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n\t        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t    },\n\t\n\t    /**\n\t     * unbind the events\n\t     */\n\t    destroy: function() {\n\t        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n\t        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n\t        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\t    }\n\t};\n\t\n\t/**\n\t * create new input type manager\n\t * called by the Manager constructor\n\t * @param {Hammer} manager\n\t * @returns {Input}\n\t */\n\tfunction createInputInstance(manager) {\n\t    var Type;\n\t    var inputClass = manager.options.inputClass;\n\t\n\t    if (inputClass) {\n\t        Type = inputClass;\n\t    } else if (SUPPORT_POINTER_EVENTS) {\n\t        Type = PointerEventInput;\n\t    } else if (SUPPORT_ONLY_TOUCH) {\n\t        Type = TouchInput;\n\t    } else if (!SUPPORT_TOUCH) {\n\t        Type = MouseInput;\n\t    } else {\n\t        Type = TouchMouseInput;\n\t    }\n\t    return new (Type)(manager, inputHandler);\n\t}\n\t\n\t/**\n\t * handle input events\n\t * @param {Manager} manager\n\t * @param {String} eventType\n\t * @param {Object} input\n\t */\n\tfunction inputHandler(manager, eventType, input) {\n\t    var pointersLen = input.pointers.length;\n\t    var changedPointersLen = input.changedPointers.length;\n\t    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n\t    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\t\n\t    input.isFirst = !!isFirst;\n\t    input.isFinal = !!isFinal;\n\t    if (isFirst) {\n\t        manager.session = {};\n\t    }\n\t\n\t    // source event is the normalized value of the domEvents\n\t    // like 'touchstart, mouseup, pointerdown'\n\t    input.eventType = eventType;\n\t\n\t    // compute scale, rotation etc\n\t    computeInputData(manager, input);\n\t\n\t    // emit secret event\n\t    manager.emit('hammer.input', input);\n\t\n\t    manager.recognize(input);\n\t    manager.session.prevInput = input;\n\t}\n\t\n\t/**\n\t * extend the data with some usable properties like scale, rotate, velocity etc\n\t * @param {Object} manager\n\t * @param {Object} input\n\t */\n\tfunction computeInputData(manager, input) {\n\t    var session = manager.session;\n\t    var pointers = input.pointers;\n\t    var pointersLength = pointers.length;\n\t\n\t    // store the first input to calculate the distance and direction\n\t    if (!session.firstInput) {\n\t        session.firstInput = simpleCloneInputData(input);\n\t    }\n\t\n\t    // to compute scale and rotation we need to store the multiple touches\n\t    if (pointersLength > 1 && !session.firstMultiple) {\n\t        session.firstMultiple = simpleCloneInputData(input);\n\t    } else if (pointersLength === 1) {\n\t        session.firstMultiple = false;\n\t    }\n\t\n\t    var firstInput = session.firstInput;\n\t    var firstMultiple = session.firstMultiple;\n\t    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\t\n\t    var center = input.center = getCenter(pointers);\n\t    input.timeStamp = now();\n\t    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\t\n\t    input.angle = getAngle(offsetCenter, center);\n\t    input.distance = getDistance(offsetCenter, center);\n\t\n\t    computeDeltaXY(session, input);\n\t    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\t\n\t    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n\t    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\t\n\t    computeIntervalInputData(session, input);\n\t\n\t    // find the correct target\n\t    var target = manager.element;\n\t    if (hasParent(input.srcEvent.target, target)) {\n\t        target = input.srcEvent.target;\n\t    }\n\t    input.target = target;\n\t}\n\t\n\tfunction computeDeltaXY(session, input) {\n\t    var center = input.center;\n\t    var offset = session.offsetDelta || {};\n\t    var prevDelta = session.prevDelta || {};\n\t    var prevInput = session.prevInput || {};\n\t\n\t    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n\t        prevDelta = session.prevDelta = {\n\t            x: prevInput.deltaX || 0,\n\t            y: prevInput.deltaY || 0\n\t        };\n\t\n\t        offset = session.offsetDelta = {\n\t            x: center.x,\n\t            y: center.y\n\t        };\n\t    }\n\t\n\t    input.deltaX = prevDelta.x + (center.x - offset.x);\n\t    input.deltaY = prevDelta.y + (center.y - offset.y);\n\t}\n\t\n\t/**\n\t * velocity is calculated every x ms\n\t * @param {Object} session\n\t * @param {Object} input\n\t */\n\tfunction computeIntervalInputData(session, input) {\n\t    var last = session.lastInterval || input,\n\t        deltaTime = input.timeStamp - last.timeStamp,\n\t        velocity, velocityX, velocityY, direction;\n\t\n\t    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n\t        var deltaX = last.deltaX - input.deltaX;\n\t        var deltaY = last.deltaY - input.deltaY;\n\t        var v = getVelocity(deltaTime, deltaX, deltaY);\n\t        velocityX = v.x;\n\t        velocityY = v.y;\n\t        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n\t        direction = getDirection(deltaX, deltaY);\n\t\n\t        session.lastInterval = input;\n\t    } else {\n\t        // use latest velocity info if it doesn't overtake a minimum period\n\t        velocity = last.velocity;\n\t        velocityX = last.velocityX;\n\t        velocityY = last.velocityY;\n\t        direction = last.direction;\n\t    }\n\t\n\t    input.velocity = velocity;\n\t    input.velocityX = velocityX;\n\t    input.velocityY = velocityY;\n\t    input.direction = direction;\n\t}\n\t\n\t/**\n\t * create a simple clone from the input used for storage of firstInput and firstMultiple\n\t * @param {Object} input\n\t * @returns {Object} clonedInputData\n\t */\n\tfunction simpleCloneInputData(input) {\n\t    // make a simple copy of the pointers because we will get a reference if we don't\n\t    // we only need clientXY for the calculations\n\t    var pointers = [];\n\t    var i = 0;\n\t    while (i < input.pointers.length) {\n\t        pointers[i] = {\n\t            clientX: round(input.pointers[i].clientX),\n\t            clientY: round(input.pointers[i].clientY)\n\t        };\n\t        i++;\n\t    }\n\t\n\t    return {\n\t        timeStamp: now(),\n\t        pointers: pointers,\n\t        center: getCenter(pointers),\n\t        deltaX: input.deltaX,\n\t        deltaY: input.deltaY\n\t    };\n\t}\n\t\n\t/**\n\t * get the center of all the pointers\n\t * @param {Array} pointers\n\t * @return {Object} center contains `x` and `y` properties\n\t */\n\tfunction getCenter(pointers) {\n\t    var pointersLength = pointers.length;\n\t\n\t    // no need to loop when only one touch\n\t    if (pointersLength === 1) {\n\t        return {\n\t            x: round(pointers[0].clientX),\n\t            y: round(pointers[0].clientY)\n\t        };\n\t    }\n\t\n\t    var x = 0, y = 0, i = 0;\n\t    while (i < pointersLength) {\n\t        x += pointers[i].clientX;\n\t        y += pointers[i].clientY;\n\t        i++;\n\t    }\n\t\n\t    return {\n\t        x: round(x / pointersLength),\n\t        y: round(y / pointersLength)\n\t    };\n\t}\n\t\n\t/**\n\t * calculate the velocity between two points. unit is in px per ms.\n\t * @param {Number} deltaTime\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Object} velocity `x` and `y`\n\t */\n\tfunction getVelocity(deltaTime, x, y) {\n\t    return {\n\t        x: x / deltaTime || 0,\n\t        y: y / deltaTime || 0\n\t    };\n\t}\n\t\n\t/**\n\t * get the direction between two points\n\t * @param {Number} x\n\t * @param {Number} y\n\t * @return {Number} direction\n\t */\n\tfunction getDirection(x, y) {\n\t    if (x === y) {\n\t        return DIRECTION_NONE;\n\t    }\n\t    \n\t    if (abs(x) >= abs(y)) {\n\t        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t    }\n\t    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t}\n\t\n\t/**\n\t * calculate the absolute distance between two points\n\t * @param {Object} p1 {x, y}\n\t * @param {Object} p2 {x, y}\n\t * @param {Array} [props] containing x and y keys\n\t * @return {Number} distance\n\t */\n\tfunction getDistance(p1, p2, props) {\n\t    if (!props) {\n\t        props = PROPS_XY;\n\t    }\n\t    var x = p2[props[0]] - p1[props[0]],\n\t        y = p2[props[1]] - p1[props[1]];\n\t\n\t    return Math.sqrt((x * x) + (y * y));\n\t}\n\t\n\t/**\n\t * calculate the angle between two coordinates\n\t * @param {Object} p1\n\t * @param {Object} p2\n\t * @param {Array} [props] containing x and y keys\n\t * @return {Number} angle\n\t */\n\tfunction getAngle(p1, p2, props) {\n\t    if (!props) {\n\t        props = PROPS_XY;\n\t    }\n\t    var x = p2[props[0]] - p1[props[0]],\n\t        y = p2[props[1]] - p1[props[1]];\n\t    return Math.atan2(y, x) * 180 / Math.PI;\n\t}\n\t\n\t/**\n\t * calculate the rotation degrees between two pointersets\n\t * @param {Array} start array of pointers\n\t * @param {Array} end array of pointers\n\t * @return {Number} rotation\n\t */\n\tfunction getRotation(start, end) {\n\t    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n\t}\n\t\n\t/**\n\t * calculate the scale factor between two pointersets\n\t * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n\t * @param {Array} start array of pointers\n\t * @param {Array} end array of pointers\n\t * @return {Number} scale\n\t */\n\tfunction getScale(start, end) {\n\t    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n\t}\n\t\n\tvar MOUSE_INPUT_MAP = {\n\t    mousedown: INPUT_START,\n\t    mousemove: INPUT_MOVE,\n\t    mouseup: INPUT_END\n\t};\n\t\n\tvar MOUSE_ELEMENT_EVENTS = 'mousedown';\n\tvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\t\n\t/**\n\t * Mouse events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction MouseInput() {\n\t    this.evEl = MOUSE_ELEMENT_EVENTS;\n\t    this.evWin = MOUSE_WINDOW_EVENTS;\n\t\n\t    this.allow = true; // used by Input.TouchMouse to disable mouse events\n\t    this.pressed = false; // mousedown state\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(MouseInput, Input, {\n\t    /**\n\t     * handle mouse events\n\t     * @param {Object} ev\n\t     */\n\t    handler: function MEhandler(ev) {\n\t        var eventType = MOUSE_INPUT_MAP[ev.type];\n\t\n\t        // on start we want to have the left mouse button down\n\t        if (eventType & INPUT_START && ev.button === 0) {\n\t            this.pressed = true;\n\t        }\n\t\n\t        if (eventType & INPUT_MOVE && ev.which !== 1) {\n\t            eventType = INPUT_END;\n\t        }\n\t\n\t        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n\t        if (!this.pressed || !this.allow) {\n\t            return;\n\t        }\n\t\n\t        if (eventType & INPUT_END) {\n\t            this.pressed = false;\n\t        }\n\t\n\t        this.callback(this.manager, eventType, {\n\t            pointers: [ev],\n\t            changedPointers: [ev],\n\t            pointerType: INPUT_TYPE_MOUSE,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\tvar POINTER_INPUT_MAP = {\n\t    pointerdown: INPUT_START,\n\t    pointermove: INPUT_MOVE,\n\t    pointerup: INPUT_END,\n\t    pointercancel: INPUT_CANCEL,\n\t    pointerout: INPUT_CANCEL\n\t};\n\t\n\t// in IE10 the pointer types is defined as an enum\n\tvar IE10_POINTER_TYPE_ENUM = {\n\t    2: INPUT_TYPE_TOUCH,\n\t    3: INPUT_TYPE_PEN,\n\t    4: INPUT_TYPE_MOUSE,\n\t    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\t};\n\t\n\tvar POINTER_ELEMENT_EVENTS = 'pointerdown';\n\tvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\t\n\t// IE10 has prefixed support, and case-sensitive\n\tif (window.MSPointerEvent) {\n\t    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n\t    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n\t}\n\t\n\t/**\n\t * Pointer events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction PointerEventInput() {\n\t    this.evEl = POINTER_ELEMENT_EVENTS;\n\t    this.evWin = POINTER_WINDOW_EVENTS;\n\t\n\t    Input.apply(this, arguments);\n\t\n\t    this.store = (this.manager.session.pointerEvents = []);\n\t}\n\t\n\tinherit(PointerEventInput, Input, {\n\t    /**\n\t     * handle mouse events\n\t     * @param {Object} ev\n\t     */\n\t    handler: function PEhandler(ev) {\n\t        var store = this.store;\n\t        var removePointer = false;\n\t\n\t        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n\t        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n\t        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\t\n\t        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\t\n\t        // get index of the event in the store\n\t        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\t\n\t        // start and mouse must be down\n\t        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n\t            if (storeIndex < 0) {\n\t                store.push(ev);\n\t                storeIndex = store.length - 1;\n\t            }\n\t        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n\t            removePointer = true;\n\t        }\n\t\n\t        // it not found, so the pointer hasn't been down (so it's probably a hover)\n\t        if (storeIndex < 0) {\n\t            return;\n\t        }\n\t\n\t        // update the event in the store\n\t        store[storeIndex] = ev;\n\t\n\t        this.callback(this.manager, eventType, {\n\t            pointers: store,\n\t            changedPointers: [ev],\n\t            pointerType: pointerType,\n\t            srcEvent: ev\n\t        });\n\t\n\t        if (removePointer) {\n\t            // remove from the store\n\t            store.splice(storeIndex, 1);\n\t        }\n\t    }\n\t});\n\t\n\tvar SINGLE_TOUCH_INPUT_MAP = {\n\t    touchstart: INPUT_START,\n\t    touchmove: INPUT_MOVE,\n\t    touchend: INPUT_END,\n\t    touchcancel: INPUT_CANCEL\n\t};\n\t\n\tvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n\tvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t/**\n\t * Touch events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction SingleTouchInput() {\n\t    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n\t    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n\t    this.started = false;\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(SingleTouchInput, Input, {\n\t    handler: function TEhandler(ev) {\n\t        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\t\n\t        // should we handle the touch events?\n\t        if (type === INPUT_START) {\n\t            this.started = true;\n\t        }\n\t\n\t        if (!this.started) {\n\t            return;\n\t        }\n\t\n\t        var touches = normalizeSingleTouches.call(this, ev, type);\n\t\n\t        // when done, reset the started state\n\t        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n\t            this.started = false;\n\t        }\n\t\n\t        this.callback(this.manager, type, {\n\t            pointers: touches[0],\n\t            changedPointers: touches[1],\n\t            pointerType: INPUT_TYPE_TOUCH,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\t/**\n\t * @this {TouchInput}\n\t * @param {Object} ev\n\t * @param {Number} type flag\n\t * @returns {undefined|Array} [all, changed]\n\t */\n\tfunction normalizeSingleTouches(ev, type) {\n\t    var all = toArray(ev.touches);\n\t    var changed = toArray(ev.changedTouches);\n\t\n\t    if (type & (INPUT_END | INPUT_CANCEL)) {\n\t        all = uniqueArray(all.concat(changed), 'identifier', true);\n\t    }\n\t\n\t    return [all, changed];\n\t}\n\t\n\tvar TOUCH_INPUT_MAP = {\n\t    touchstart: INPUT_START,\n\t    touchmove: INPUT_MOVE,\n\t    touchend: INPUT_END,\n\t    touchcancel: INPUT_CANCEL\n\t};\n\t\n\tvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\t\n\t/**\n\t * Multi-user touch events input\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction TouchInput() {\n\t    this.evTarget = TOUCH_TARGET_EVENTS;\n\t    this.targetIds = {};\n\t\n\t    Input.apply(this, arguments);\n\t}\n\t\n\tinherit(TouchInput, Input, {\n\t    handler: function MTEhandler(ev) {\n\t        var type = TOUCH_INPUT_MAP[ev.type];\n\t        var touches = getTouches.call(this, ev, type);\n\t        if (!touches) {\n\t            return;\n\t        }\n\t\n\t        this.callback(this.manager, type, {\n\t            pointers: touches[0],\n\t            changedPointers: touches[1],\n\t            pointerType: INPUT_TYPE_TOUCH,\n\t            srcEvent: ev\n\t        });\n\t    }\n\t});\n\t\n\t/**\n\t * @this {TouchInput}\n\t * @param {Object} ev\n\t * @param {Number} type flag\n\t * @returns {undefined|Array} [all, changed]\n\t */\n\tfunction getTouches(ev, type) {\n\t    var allTouches = toArray(ev.touches);\n\t    var targetIds = this.targetIds;\n\t\n\t    // when there is only one touch, the process can be simplified\n\t    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n\t        targetIds[allTouches[0].identifier] = true;\n\t        return [allTouches, allTouches];\n\t    }\n\t\n\t    var i,\n\t        targetTouches,\n\t        changedTouches = toArray(ev.changedTouches),\n\t        changedTargetTouches = [],\n\t        target = this.target;\n\t\n\t    // get target touches from touches\n\t    targetTouches = allTouches.filter(function(touch) {\n\t        return hasParent(touch.target, target);\n\t    });\n\t\n\t    // collect touches\n\t    if (type === INPUT_START) {\n\t        i = 0;\n\t        while (i < targetTouches.length) {\n\t            targetIds[targetTouches[i].identifier] = true;\n\t            i++;\n\t        }\n\t    }\n\t\n\t    // filter changed touches to only contain touches that exist in the collected target ids\n\t    i = 0;\n\t    while (i < changedTouches.length) {\n\t        if (targetIds[changedTouches[i].identifier]) {\n\t            changedTargetTouches.push(changedTouches[i]);\n\t        }\n\t\n\t        // cleanup removed touches\n\t        if (type & (INPUT_END | INPUT_CANCEL)) {\n\t            delete targetIds[changedTouches[i].identifier];\n\t        }\n\t        i++;\n\t    }\n\t\n\t    if (!changedTargetTouches.length) {\n\t        return;\n\t    }\n\t\n\t    return [\n\t        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n\t        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n\t        changedTargetTouches\n\t    ];\n\t}\n\t\n\t/**\n\t * Combined touch and mouse input\n\t *\n\t * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n\t * This because touch devices also emit mouse events while doing a touch.\n\t *\n\t * @constructor\n\t * @extends Input\n\t */\n\tfunction TouchMouseInput() {\n\t    Input.apply(this, arguments);\n\t\n\t    var handler = bindFn(this.handler, this);\n\t    this.touch = new TouchInput(this.manager, handler);\n\t    this.mouse = new MouseInput(this.manager, handler);\n\t}\n\t\n\tinherit(TouchMouseInput, Input, {\n\t    /**\n\t     * handle mouse and touch events\n\t     * @param {Hammer} manager\n\t     * @param {String} inputEvent\n\t     * @param {Object} inputData\n\t     */\n\t    handler: function TMEhandler(manager, inputEvent, inputData) {\n\t        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n\t            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\t\n\t        // when we're in a touch event, so  block all upcoming mouse events\n\t        // most mobile browser also emit mouseevents, right after touchstart\n\t        if (isTouch) {\n\t            this.mouse.allow = false;\n\t        } else if (isMouse && !this.mouse.allow) {\n\t            return;\n\t        }\n\t\n\t        // reset the allowMouse when we're done\n\t        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n\t            this.mouse.allow = true;\n\t        }\n\t\n\t        this.callback(manager, inputEvent, inputData);\n\t    },\n\t\n\t    /**\n\t     * remove the event listeners\n\t     */\n\t    destroy: function destroy() {\n\t        this.touch.destroy();\n\t        this.mouse.destroy();\n\t    }\n\t});\n\t\n\tvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n\tvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\t\n\t// magical touchAction value\n\tvar TOUCH_ACTION_COMPUTE = 'compute';\n\tvar TOUCH_ACTION_AUTO = 'auto';\n\tvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\tvar TOUCH_ACTION_NONE = 'none';\n\tvar TOUCH_ACTION_PAN_X = 'pan-x';\n\tvar TOUCH_ACTION_PAN_Y = 'pan-y';\n\t\n\t/**\n\t * Touch Action\n\t * sets the touchAction property or uses the js alternative\n\t * @param {Manager} manager\n\t * @param {String} value\n\t * @constructor\n\t */\n\tfunction TouchAction(manager, value) {\n\t    this.manager = manager;\n\t    this.set(value);\n\t}\n\t\n\tTouchAction.prototype = {\n\t    /**\n\t     * set the touchAction value on the element or enable the polyfill\n\t     * @param {String} value\n\t     */\n\t    set: function(value) {\n\t        // find out the touch-action by the event handlers\n\t        if (value == TOUCH_ACTION_COMPUTE) {\n\t            value = this.compute();\n\t        }\n\t\n\t        if (NATIVE_TOUCH_ACTION) {\n\t            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n\t        }\n\t        this.actions = value.toLowerCase().trim();\n\t    },\n\t\n\t    /**\n\t     * just re-set the touchAction value\n\t     */\n\t    update: function() {\n\t        this.set(this.manager.options.touchAction);\n\t    },\n\t\n\t    /**\n\t     * compute the value for the touchAction property based on the recognizer's settings\n\t     * @returns {String} value\n\t     */\n\t    compute: function() {\n\t        var actions = [];\n\t        each(this.manager.recognizers, function(recognizer) {\n\t            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n\t                actions = actions.concat(recognizer.getTouchAction());\n\t            }\n\t        });\n\t        return cleanTouchActions(actions.join(' '));\n\t    },\n\t\n\t    /**\n\t     * this method is called on each input cycle and provides the preventing of the browser behavior\n\t     * @param {Object} input\n\t     */\n\t    preventDefaults: function(input) {\n\t        // not needed with native support for the touchAction property\n\t        if (NATIVE_TOUCH_ACTION) {\n\t            return;\n\t        }\n\t\n\t        var srcEvent = input.srcEvent;\n\t        var direction = input.offsetDirection;\n\t\n\t        // if the touch action did prevented once this session\n\t        if (this.manager.session.prevented) {\n\t            srcEvent.preventDefault();\n\t            return;\n\t        }\n\t\n\t        var actions = this.actions;\n\t        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n\t        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t\n\t        if (hasNone ||\n\t            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n\t            (hasPanX && direction & DIRECTION_VERTICAL)) {\n\t            return this.preventSrc(srcEvent);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n\t     * @param {Object} srcEvent\n\t     */\n\t    preventSrc: function(srcEvent) {\n\t        this.manager.session.prevented = true;\n\t        srcEvent.preventDefault();\n\t    }\n\t};\n\t\n\t/**\n\t * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n\t * @param {String} actions\n\t * @returns {*}\n\t */\n\tfunction cleanTouchActions(actions) {\n\t    // none\n\t    if (inStr(actions, TOUCH_ACTION_NONE)) {\n\t        return TOUCH_ACTION_NONE;\n\t    }\n\t\n\t    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\t    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\t\n\t    // pan-x and pan-y can be combined\n\t    if (hasPanX && hasPanY) {\n\t        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n\t    }\n\t\n\t    // pan-x OR pan-y\n\t    if (hasPanX || hasPanY) {\n\t        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n\t    }\n\t\n\t    // manipulation\n\t    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n\t        return TOUCH_ACTION_MANIPULATION;\n\t    }\n\t\n\t    return TOUCH_ACTION_AUTO;\n\t}\n\t\n\t/**\n\t * Recognizer flow explained; *\n\t * All recognizers have the initial state of POSSIBLE when a input session starts.\n\t * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n\t * Example session for mouse-input: mousedown -> mousemove -> mouseup\n\t *\n\t * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n\t * which determines with state it should be.\n\t *\n\t * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n\t * POSSIBLE to give it another change on the next cycle.\n\t *\n\t *               Possible\n\t *                  |\n\t *            +-----+---------------+\n\t *            |                     |\n\t *      +-----+-----+               |\n\t *      |           |               |\n\t *   Failed      Cancelled          |\n\t *                          +-------+------+\n\t *                          |              |\n\t *                      Recognized       Began\n\t *                                         |\n\t *                                      Changed\n\t *                                         |\n\t *                                  Ended/Recognized\n\t */\n\tvar STATE_POSSIBLE = 1;\n\tvar STATE_BEGAN = 2;\n\tvar STATE_CHANGED = 4;\n\tvar STATE_ENDED = 8;\n\tvar STATE_RECOGNIZED = STATE_ENDED;\n\tvar STATE_CANCELLED = 16;\n\tvar STATE_FAILED = 32;\n\t\n\t/**\n\t * Recognizer\n\t * Every recognizer needs to extend from this class.\n\t * @constructor\n\t * @param {Object} options\n\t */\n\tfunction Recognizer(options) {\n\t    this.id = uniqueId();\n\t\n\t    this.manager = null;\n\t    this.options = merge(options || {}, this.defaults);\n\t\n\t    // default is enable true\n\t    this.options.enable = ifUndefined(this.options.enable, true);\n\t\n\t    this.state = STATE_POSSIBLE;\n\t\n\t    this.simultaneous = {};\n\t    this.requireFail = [];\n\t}\n\t\n\tRecognizer.prototype = {\n\t    /**\n\t     * @virtual\n\t     * @type {Object}\n\t     */\n\t    defaults: {},\n\t\n\t    /**\n\t     * set options\n\t     * @param {Object} options\n\t     * @return {Recognizer}\n\t     */\n\t    set: function(options) {\n\t        extend(this.options, options);\n\t\n\t        // also update the touchAction, in case something changed about the directions/enabled state\n\t        this.manager && this.manager.touchAction.update();\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * recognize simultaneous with an other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    recognizeWith: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n\t            return this;\n\t        }\n\t\n\t        var simultaneous = this.simultaneous;\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        if (!simultaneous[otherRecognizer.id]) {\n\t            simultaneous[otherRecognizer.id] = otherRecognizer;\n\t            otherRecognizer.recognizeWith(this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    dropRecognizeWith: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n\t            return this;\n\t        }\n\t\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        delete this.simultaneous[otherRecognizer.id];\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * recognizer can only run when an other is failing\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    requireFailure: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n\t            return this;\n\t        }\n\t\n\t        var requireFail = this.requireFail;\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        if (inArray(requireFail, otherRecognizer) === -1) {\n\t            requireFail.push(otherRecognizer);\n\t            otherRecognizer.requireFailure(this);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * drop the requireFailure link. it does not remove the link on the other recognizer.\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Recognizer} this\n\t     */\n\t    dropRequireFailure: function(otherRecognizer) {\n\t        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n\t            return this;\n\t        }\n\t\n\t        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\t        var index = inArray(this.requireFail, otherRecognizer);\n\t        if (index > -1) {\n\t            this.requireFail.splice(index, 1);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * has require failures boolean\n\t     * @returns {boolean}\n\t     */\n\t    hasRequireFailures: function() {\n\t        return this.requireFail.length > 0;\n\t    },\n\t\n\t    /**\n\t     * if the recognizer can recognize simultaneous with an other recognizer\n\t     * @param {Recognizer} otherRecognizer\n\t     * @returns {Boolean}\n\t     */\n\t    canRecognizeWith: function(otherRecognizer) {\n\t        return !!this.simultaneous[otherRecognizer.id];\n\t    },\n\t\n\t    /**\n\t     * You should use `tryEmit` instead of `emit` directly to check\n\t     * that all the needed recognizers has failed before emitting.\n\t     * @param {Object} input\n\t     */\n\t    emit: function(input) {\n\t        var self = this;\n\t        var state = this.state;\n\t\n\t        function emit(withState) {\n\t            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n\t        }\n\t\n\t        // 'panstart' and 'panmove'\n\t        if (state < STATE_ENDED) {\n\t            emit(true);\n\t        }\n\t\n\t        emit(); // simple 'eventName' events\n\t\n\t        // panend and pancancel\n\t        if (state >= STATE_ENDED) {\n\t            emit(true);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Check that all the require failure recognizers has failed,\n\t     * if true, it emits a gesture event,\n\t     * otherwise, setup the state to FAILED.\n\t     * @param {Object} input\n\t     */\n\t    tryEmit: function(input) {\n\t        if (this.canEmit()) {\n\t            return this.emit(input);\n\t        }\n\t        // it's failing anyway\n\t        this.state = STATE_FAILED;\n\t    },\n\t\n\t    /**\n\t     * can we emit?\n\t     * @returns {boolean}\n\t     */\n\t    canEmit: function() {\n\t        var i = 0;\n\t        while (i < this.requireFail.length) {\n\t            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n\t                return false;\n\t            }\n\t            i++;\n\t        }\n\t        return true;\n\t    },\n\t\n\t    /**\n\t     * update the recognizer\n\t     * @param {Object} inputData\n\t     */\n\t    recognize: function(inputData) {\n\t        // make a new copy of the inputData\n\t        // so we can change the inputData without messing up the other recognizers\n\t        var inputDataClone = extend({}, inputData);\n\t\n\t        // is is enabled and allow recognizing?\n\t        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n\t            this.reset();\n\t            this.state = STATE_FAILED;\n\t            return;\n\t        }\n\t\n\t        // reset when we've reached the end\n\t        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n\t            this.state = STATE_POSSIBLE;\n\t        }\n\t\n\t        this.state = this.process(inputDataClone);\n\t\n\t        // the recognizer has recognized a gesture\n\t        // so trigger an event\n\t        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n\t            this.tryEmit(inputDataClone);\n\t        }\n\t    },\n\t\n\t    /**\n\t     * return the state of the recognizer\n\t     * the actual recognizing happens in this method\n\t     * @virtual\n\t     * @param {Object} inputData\n\t     * @returns {Const} STATE\n\t     */\n\t    process: function(inputData) { }, // jshint ignore:line\n\t\n\t    /**\n\t     * return the preferred touch-action\n\t     * @virtual\n\t     * @returns {Array}\n\t     */\n\t    getTouchAction: function() { },\n\t\n\t    /**\n\t     * called when the gesture isn't allowed to recognize\n\t     * like when another is being recognized or it is disabled\n\t     * @virtual\n\t     */\n\t    reset: function() { }\n\t};\n\t\n\t/**\n\t * get a usable string, used as event postfix\n\t * @param {Const} state\n\t * @returns {String} state\n\t */\n\tfunction stateStr(state) {\n\t    if (state & STATE_CANCELLED) {\n\t        return 'cancel';\n\t    } else if (state & STATE_ENDED) {\n\t        return 'end';\n\t    } else if (state & STATE_CHANGED) {\n\t        return 'move';\n\t    } else if (state & STATE_BEGAN) {\n\t        return 'start';\n\t    }\n\t    return '';\n\t}\n\t\n\t/**\n\t * direction cons to string\n\t * @param {Const} direction\n\t * @returns {String}\n\t */\n\tfunction directionStr(direction) {\n\t    if (direction == DIRECTION_DOWN) {\n\t        return 'down';\n\t    } else if (direction == DIRECTION_UP) {\n\t        return 'up';\n\t    } else if (direction == DIRECTION_LEFT) {\n\t        return 'left';\n\t    } else if (direction == DIRECTION_RIGHT) {\n\t        return 'right';\n\t    }\n\t    return '';\n\t}\n\t\n\t/**\n\t * get a recognizer by name if it is bound to a manager\n\t * @param {Recognizer|String} otherRecognizer\n\t * @param {Recognizer} recognizer\n\t * @returns {Recognizer}\n\t */\n\tfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n\t    var manager = recognizer.manager;\n\t    if (manager) {\n\t        return manager.get(otherRecognizer);\n\t    }\n\t    return otherRecognizer;\n\t}\n\t\n\t/**\n\t * This recognizer is just used as a base for the simple attribute recognizers.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction AttrRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(AttrRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof AttrRecognizer\n\t     */\n\t    defaults: {\n\t        /**\n\t         * @type {Number}\n\t         * @default 1\n\t         */\n\t        pointers: 1\n\t    },\n\t\n\t    /**\n\t     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n\t     * @memberof AttrRecognizer\n\t     * @param {Object} input\n\t     * @returns {Boolean} recognized\n\t     */\n\t    attrTest: function(input) {\n\t        var optionPointers = this.options.pointers;\n\t        return optionPointers === 0 || input.pointers.length === optionPointers;\n\t    },\n\t\n\t    /**\n\t     * Process the input and return the state for the recognizer\n\t     * @memberof AttrRecognizer\n\t     * @param {Object} input\n\t     * @returns {*} State\n\t     */\n\t    process: function(input) {\n\t        var state = this.state;\n\t        var eventType = input.eventType;\n\t\n\t        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n\t        var isValid = this.attrTest(input);\n\t\n\t        // on cancel input and we've recognized before, return STATE_CANCELLED\n\t        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n\t            return state | STATE_CANCELLED;\n\t        } else if (isRecognized || isValid) {\n\t            if (eventType & INPUT_END) {\n\t                return state | STATE_ENDED;\n\t            } else if (!(state & STATE_BEGAN)) {\n\t                return STATE_BEGAN;\n\t            }\n\t            return state | STATE_CHANGED;\n\t        }\n\t        return STATE_FAILED;\n\t    }\n\t});\n\t\n\t/**\n\t * Pan\n\t * Recognized when the pointer is down and moved in the allowed direction.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction PanRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t\n\t    this.pX = null;\n\t    this.pY = null;\n\t}\n\t\n\tinherit(PanRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PanRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'pan',\n\t        threshold: 10,\n\t        pointers: 1,\n\t        direction: DIRECTION_ALL\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        var direction = this.options.direction;\n\t        var actions = [];\n\t        if (direction & DIRECTION_HORIZONTAL) {\n\t            actions.push(TOUCH_ACTION_PAN_Y);\n\t        }\n\t        if (direction & DIRECTION_VERTICAL) {\n\t            actions.push(TOUCH_ACTION_PAN_X);\n\t        }\n\t        return actions;\n\t    },\n\t\n\t    directionTest: function(input) {\n\t        var options = this.options;\n\t        var hasMoved = true;\n\t        var distance = input.distance;\n\t        var direction = input.direction;\n\t        var x = input.deltaX;\n\t        var y = input.deltaY;\n\t\n\t        // lock to axis?\n\t        if (!(direction & options.direction)) {\n\t            if (options.direction & DIRECTION_HORIZONTAL) {\n\t                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t                hasMoved = x != this.pX;\n\t                distance = Math.abs(input.deltaX);\n\t            } else {\n\t                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n\t                hasMoved = y != this.pY;\n\t                distance = Math.abs(input.deltaY);\n\t            }\n\t        }\n\t        input.direction = direction;\n\t        return hasMoved && distance > options.threshold && direction & options.direction;\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n\t            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n\t    },\n\t\n\t    emit: function(input) {\n\t        this.pX = input.deltaX;\n\t        this.pY = input.deltaY;\n\t\n\t        var direction = directionStr(input.direction);\n\t        if (direction) {\n\t            this.manager.emit(this.options.event + direction, input);\n\t        }\n\t\n\t        this._super.emit.call(this, input);\n\t    },\n\t    reset:function(){\n\t        \n\t    }\n\t});\n\t\n\t/**\n\t * Pinch\n\t * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction PinchRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(PinchRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PinchRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'pinch',\n\t        threshold: 0,\n\t        pointers: 2\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_NONE];\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return this._super.attrTest.call(this, input) &&\n\t            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n\t    },\n\t\n\t    emit: function(input) {\n\t        this._super.emit.call(this, input);\n\t        if (input.scale !== 1) {\n\t            var inOut = input.scale < 1 ? 'in' : 'out';\n\t            this.manager.emit(this.options.event + inOut, input);\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Press\n\t * Recognized when the pointer is down for x ms without any movement.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction PressRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t\n\t    this._timer = null;\n\t    this._input = null;\n\t}\n\t\n\tinherit(PressRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PressRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'press',\n\t        pointers: 1,\n\t        time: 500, // minimal time of the pointer to be pressed\n\t        threshold: 5 // a minimal movement is ok, but keep it low\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_AUTO];\n\t    },\n\t\n\t    process: function(input) {\n\t        var options = this.options;\n\t        var validPointers = input.pointers.length === options.pointers;\n\t        var validMovement = input.distance < options.threshold;\n\t        var validTime = input.deltaTime > options.time;\n\t\n\t        this._input = input;\n\t\n\t        // we only allow little movement\n\t        // and we've reached an end event, so a tap is possible\n\t        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n\t            this.reset();\n\t        } else if (input.eventType & INPUT_START) {\n\t            this.reset();\n\t            this._timer = setTimeoutContext(function() {\n\t                this.state = STATE_RECOGNIZED;\n\t                this.tryEmit();\n\t            }, options.time, this);\n\t        } else if (input.eventType & INPUT_END) {\n\t            return STATE_RECOGNIZED;\n\t        }\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    reset: function() {\n\t        clearTimeout(this._timer);\n\t    },\n\t\n\t    emit: function(input) {\n\t        if (this.state !== STATE_RECOGNIZED) {\n\t            return;\n\t        }\n\t\n\t        if (input && (input.eventType & INPUT_END)) {\n\t            this.manager.emit(this.options.event + 'up', input);\n\t        } else {\n\t            this._input.timeStamp = now();\n\t            this.manager.emit(this.options.event, this._input);\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Rotate\n\t * Recognized when two or more pointer are moving in a circular motion.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction RotateRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(RotateRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof RotateRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'rotate',\n\t        threshold: 0,\n\t        pointers: 2\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_NONE];\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        return this._super.attrTest.call(this, input) &&\n\t            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n\t    }\n\t});\n\t\n\t/**\n\t * Swipe\n\t * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n\t * @constructor\n\t * @extends AttrRecognizer\n\t */\n\tfunction SwipeRecognizer() {\n\t    AttrRecognizer.apply(this, arguments);\n\t}\n\t\n\tinherit(SwipeRecognizer, AttrRecognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof SwipeRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'swipe',\n\t        threshold: 10,\n\t        velocity: 0.65,\n\t        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n\t        pointers: 1\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return PanRecognizer.prototype.getTouchAction.call(this);\n\t    },\n\t\n\t    attrTest: function(input) {\n\t        var direction = this.options.direction;\n\t        var velocity;\n\t\n\t        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n\t            velocity = input.velocity;\n\t        } else if (direction & DIRECTION_HORIZONTAL) {\n\t            velocity = input.velocityX;\n\t        } else if (direction & DIRECTION_VERTICAL) {\n\t            velocity = input.velocityY;\n\t        }\n\t\n\t        return this._super.attrTest.call(this, input) &&\n\t            direction & input.direction &&\n\t            input.distance > this.options.threshold &&\n\t            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n\t    },\n\t\n\t    emit: function(input) {\n\t        var direction = directionStr(input.direction);\n\t        if (direction) {\n\t            this.manager.emit(this.options.event + direction, input);\n\t        }\n\t\n\t        this.manager.emit(this.options.event, input);\n\t    }\n\t});\n\t\n\t/**\n\t * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n\t * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n\t * a single tap.\n\t *\n\t * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n\t * multi-taps being recognized.\n\t * @constructor\n\t * @extends Recognizer\n\t */\n\tfunction TapRecognizer() {\n\t    Recognizer.apply(this, arguments);\n\t\n\t    // previous time and center,\n\t    // used for tap counting\n\t    this.pTime = false;\n\t    this.pCenter = false;\n\t\n\t    this._timer = null;\n\t    this._input = null;\n\t    this.count = 0;\n\t}\n\t\n\tinherit(TapRecognizer, Recognizer, {\n\t    /**\n\t     * @namespace\n\t     * @memberof PinchRecognizer\n\t     */\n\t    defaults: {\n\t        event: 'tap',\n\t        pointers: 1,\n\t        taps: 1,\n\t        interval: 300, // max time between the multi-tap taps\n\t        time: 250, // max time of the pointer to be down (like finger on the screen)\n\t        threshold: 10, // a minimal movement is ok, but keep it low\n\t        posThreshold: 10 // a multi-tap can be a bit off the initial position\n\t    },\n\t\n\t    getTouchAction: function() {\n\t        return [TOUCH_ACTION_MANIPULATION];\n\t    },\n\t\n\t    process: function(input) {\n\t        var options = this.options;\n\t        var validPointers = input.pointers.length === options.pointers;\n\t        var validMovement = input.distance < options.threshold;\n\t        var validTouchTime = input.deltaTime < options.time;\n\t        this.reset();\n\t\n\t        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n\t            return this.failTimeout();\n\t        }\n\t        // we only allow little movement\n\t        // and we've reached an end event, so a tap is possible\n\t        if (validMovement && validTouchTime && validPointers) {\n\t            if (input.eventType != INPUT_END) {\n\t                return this.failTimeout();\n\t            }\n\t\n\t            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n\t            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\t\n\t            this.pTime = input.timeStamp;\n\t            this.pCenter = input.center;\n\t            if (!validMultiTap || !validInterval) {\n\t                this.count = 1;\n\t            } else {\n\t                this.count += 1;\n\t            }\n\t\n\t            this._input = input;\n\t\n\t            // if tap count matches we have recognized it,\n\t            // else it has began recognizing...\n\t            var tapCount = this.count % options.taps;\n\t            if (tapCount === 0) {\n\t                // no failing requirements, immediately trigger the tap event\n\t                // or wait as long as the multitap interval to trigger\n\t                if (!this.hasRequireFailures()) {\n\t                    return STATE_RECOGNIZED;\n\t                } else {\n\t                    this._timer = setTimeoutContext(function() {\n\t                        this.state = STATE_RECOGNIZED;\n\t                        this.tryEmit();\n\t                    }, options.interval, this);\n\t                    return STATE_BEGAN;\n\t                }\n\t            }\n\t        }\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    failTimeout: function() {\n\t        this._timer = setTimeoutContext(function() {\n\t            this.state = STATE_FAILED;\n\t        }, this.options.interval, this);\n\t        return STATE_FAILED;\n\t    },\n\t\n\t    reset: function() {\n\t        clearTimeout(this._timer);\n\t    },\n\t\n\t    emit: function() {\n\t        if (this.state == STATE_RECOGNIZED ) {\n\t            this._input.tapCount = this.count;\n\t            this.manager.emit(this.options.event, this._input);\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Simple way to create an manager with a default set of recognizers.\n\t * @param {HTMLElement} element\n\t * @param {Object} [options]\n\t * @constructor\n\t */\n\tfunction Hammer(element, options) {\n\t    options = options || {};\n\t    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n\t    return new Manager(element, options);\n\t}\n\t\n\t/**\n\t * @const {string}\n\t */\n\tHammer.VERSION = '2.0.4';\n\t\n\t/**\n\t * default settings\n\t * @namespace\n\t */\n\tHammer.defaults = {\n\t    /**\n\t     * set if DOM events are being triggered.\n\t     * But this is slower and unused by simple implementations, so disabled by default.\n\t     * @type {Boolean}\n\t     * @default false\n\t     */\n\t    domEvents: false,\n\t\n\t    /**\n\t     * The value for the touchAction property/fallback.\n\t     * When set to `compute` it will magically set the correct value based on the added recognizers.\n\t     * @type {String}\n\t     * @default compute\n\t     */\n\t    touchAction: TOUCH_ACTION_COMPUTE,\n\t\n\t    /**\n\t     * @type {Boolean}\n\t     * @default true\n\t     */\n\t    enable: true,\n\t\n\t    /**\n\t     * EXPERIMENTAL FEATURE -- can be removed/changed\n\t     * Change the parent input target element.\n\t     * If Null, then it is being set the to main element.\n\t     * @type {Null|EventTarget}\n\t     * @default null\n\t     */\n\t    inputTarget: null,\n\t\n\t    /**\n\t     * force an input class\n\t     * @type {Null|Function}\n\t     * @default null\n\t     */\n\t    inputClass: null,\n\t\n\t    /**\n\t     * Default recognizer setup when calling `Hammer()`\n\t     * When creating a new Manager these will be skipped.\n\t     * @type {Array}\n\t     */\n\t    preset: [\n\t        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n\t        [RotateRecognizer, { enable: false }],\n\t        [PinchRecognizer, { enable: false }, ['rotate']],\n\t        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\n\t        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n\t        [TapRecognizer],\n\t        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n\t        [PressRecognizer]\n\t    ],\n\t\n\t    /**\n\t     * Some CSS properties can be used to improve the working of Hammer.\n\t     * Add them to this method and they will be set when creating a new Manager.\n\t     * @namespace\n\t     */\n\t    cssProps: {\n\t        /**\n\t         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        userSelect: 'none',\n\t\n\t        /**\n\t         * Disable the Windows Phone grippers when pressing an element.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        touchSelect: 'none',\n\t\n\t        /**\n\t         * Disables the default callout shown when you touch and hold a touch target.\n\t         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n\t         * a callout containing information about the link. This property allows you to disable that callout.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        touchCallout: 'none',\n\t\n\t        /**\n\t         * Specifies whether zooming is enabled. Used by IE10>\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        contentZooming: 'none',\n\t\n\t        /**\n\t         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n\t         * @type {String}\n\t         * @default 'none'\n\t         */\n\t        userDrag: 'none',\n\t\n\t        /**\n\t         * Overrides the highlight color shown when the user taps a link or a JavaScript\n\t         * clickable element in iOS. This property obeys the alpha value, if specified.\n\t         * @type {String}\n\t         * @default 'rgba(0,0,0,0)'\n\t         */\n\t        tapHighlightColor: 'rgba(0,0,0,0)'\n\t    }\n\t};\n\t\n\tvar STOP = 1;\n\tvar FORCED_STOP = 2;\n\t\n\t/**\n\t * Manager\n\t * @param {HTMLElement} element\n\t * @param {Object} [options]\n\t * @constructor\n\t */\n\tfunction Manager(element, options) {\n\t    options = options || {};\n\t\n\t    this.options = merge(options, Hammer.defaults);\n\t    this.options.inputTarget = this.options.inputTarget || element;\n\t    this.handlers = {};\n\t    this.session = {};\n\t    this.recognizers = [];\n\t\n\t    this.element = element;\n\t    this.input = createInputInstance(this);\n\t    this.touchAction = new TouchAction(this, this.options.touchAction);\n\t\n\t    toggleCssProps(this, true);\n\t\n\t    each(options.recognizers, function(item) {\n\t        var recognizer = this.add(new (item[0])(item[1]));\n\t        item[2] && recognizer.recognizeWith(item[2]);\n\t        item[3] && recognizer.requireFailure(item[3]);\n\t    }, this);\n\t}\n\t\n\tManager.prototype = {\n\t    /**\n\t     * set options\n\t     * @param {Object} options\n\t     * @returns {Manager}\n\t     */\n\t    set: function(options) {\n\t        extend(this.options, options);\n\t\n\t        // Options that need a little more setup\n\t        if (options.touchAction) {\n\t            this.touchAction.update();\n\t        }\n\t        if (options.inputTarget) {\n\t            // Clean up existing event listeners and reinitialize\n\t            this.input.destroy();\n\t            this.input.target = options.inputTarget;\n\t            this.input.init();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * stop recognizing for this session.\n\t     * This session will be discarded, when a new [input]start event is fired.\n\t     * When forced, the recognizer cycle is stopped immediately.\n\t     * @param {Boolean} [force]\n\t     */\n\t    stop: function(force) {\n\t        this.session.stopped = force ? FORCED_STOP : STOP;\n\t    },\n\t\n\t    /**\n\t     * run the recognizers!\n\t     * called by the inputHandler function on every movement of the pointers (touches)\n\t     * it walks through all the recognizers and tries to detect the gesture that is being made\n\t     * @param {Object} inputData\n\t     */\n\t    recognize: function(inputData) {\n\t        var session = this.session;\n\t        if (session.stopped) {\n\t            return;\n\t        }\n\t\n\t        // run the touch-action polyfill\n\t        this.touchAction.preventDefaults(inputData);\n\t\n\t        var recognizer;\n\t        var recognizers = this.recognizers;\n\t\n\t        // this holds the recognizer that is being recognized.\n\t        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n\t        // if no recognizer is detecting a thing, it is set to `null`\n\t        var curRecognizer = session.curRecognizer;\n\t\n\t        // reset when the last recognizer is recognized\n\t        // or when we're in a new session\n\t        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n\t            curRecognizer = session.curRecognizer = null;\n\t        }\n\t\n\t        var i = 0;\n\t        while (i < recognizers.length) {\n\t            recognizer = recognizers[i];\n\t\n\t            // find out if we are allowed try to recognize the input for this one.\n\t            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n\t            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n\t            //      that is being recognized.\n\t            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n\t            //      this can be setup with the `recognizeWith()` method on the recognizer.\n\t            if (session.stopped !== FORCED_STOP && ( // 1\n\t                    !curRecognizer || recognizer == curRecognizer || // 2\n\t                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n\t                recognizer.recognize(inputData);\n\t            } else {\n\t                recognizer.reset();\n\t            }\n\t\n\t            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n\t            // current active recognizer. but only if we don't already have an active recognizer\n\t            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n\t                curRecognizer = session.curRecognizer = recognizer;\n\t            }\n\t            i++;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * get a recognizer by its event name.\n\t     * @param {Recognizer|String} recognizer\n\t     * @returns {Recognizer|Null}\n\t     */\n\t    get: function(recognizer) {\n\t        if (recognizer instanceof Recognizer) {\n\t            return recognizer;\n\t        }\n\t\n\t        var recognizers = this.recognizers;\n\t        for (var i = 0; i < recognizers.length; i++) {\n\t            if (recognizers[i].options.event == recognizer) {\n\t                return recognizers[i];\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * add a recognizer to the manager\n\t     * existing recognizers with the same event name will be removed\n\t     * @param {Recognizer} recognizer\n\t     * @returns {Recognizer|Manager}\n\t     */\n\t    add: function(recognizer) {\n\t        if (invokeArrayArg(recognizer, 'add', this)) {\n\t            return this;\n\t        }\n\t\n\t        // remove existing\n\t        var existing = this.get(recognizer.options.event);\n\t        if (existing) {\n\t            this.remove(existing);\n\t        }\n\t\n\t        this.recognizers.push(recognizer);\n\t        recognizer.manager = this;\n\t\n\t        this.touchAction.update();\n\t        return recognizer;\n\t    },\n\t\n\t    /**\n\t     * remove a recognizer by name or instance\n\t     * @param {Recognizer|String} recognizer\n\t     * @returns {Manager}\n\t     */\n\t    remove: function(recognizer) {\n\t        if (invokeArrayArg(recognizer, 'remove', this)) {\n\t            return this;\n\t        }\n\t\n\t        var recognizers = this.recognizers;\n\t        recognizer = this.get(recognizer);\n\t        recognizers.splice(inArray(recognizers, recognizer), 1);\n\t\n\t        this.touchAction.update();\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * bind event\n\t     * @param {String} events\n\t     * @param {Function} handler\n\t     * @returns {EventEmitter} this\n\t     */\n\t    on: function(events, handler) {\n\t        var handlers = this.handlers;\n\t        each(splitStr(events), function(event) {\n\t            handlers[event] = handlers[event] || [];\n\t            handlers[event].push(handler);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * unbind event, leave emit blank to remove all handlers\n\t     * @param {String} events\n\t     * @param {Function} [handler]\n\t     * @returns {EventEmitter} this\n\t     */\n\t    off: function(events, handler) {\n\t        var handlers = this.handlers;\n\t        each(splitStr(events), function(event) {\n\t            if (!handler) {\n\t                delete handlers[event];\n\t            } else {\n\t                handlers[event].splice(inArray(handlers[event], handler), 1);\n\t            }\n\t        });\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * emit event to the listeners\n\t     * @param {String} event\n\t     * @param {Object} data\n\t     */\n\t    emit: function(event, data) {\n\t        // we also want to trigger dom events\n\t        if (this.options.domEvents) {\n\t            triggerDomEvent(event, data);\n\t        }\n\t\n\t        // no handlers, so skip it all\n\t        var handlers = this.handlers[event] && this.handlers[event].slice();\n\t        if (!handlers || !handlers.length) {\n\t            return;\n\t        }\n\t\n\t        data.type = event;\n\t        data.preventDefault = function() {\n\t            data.srcEvent.preventDefault();\n\t        };\n\t\n\t        var i = 0;\n\t        while (i < handlers.length) {\n\t            handlers[i](data);\n\t            i++;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * destroy the manager and unbinds all events\n\t     * it doesn't unbind dom events, that is the user own responsibility\n\t     */\n\t    destroy: function() {\n\t        this.element && toggleCssProps(this, false);\n\t\n\t        this.handlers = {};\n\t        this.session = {};\n\t        this.input.destroy();\n\t        this.element = null;\n\t    }\n\t};\n\t\n\t/**\n\t * add/remove the css properties as defined in manager.options.cssProps\n\t * @param {Manager} manager\n\t * @param {Boolean} add\n\t */\n\tfunction toggleCssProps(manager, add) {\n\t    var element = manager.element;\n\t    each(manager.options.cssProps, function(value, name) {\n\t        element.style[prefixed(element.style, name)] = add ? value : '';\n\t    });\n\t}\n\t\n\t/**\n\t * trigger dom event\n\t * @param {String} event\n\t * @param {Object} data\n\t */\n\tfunction triggerDomEvent(event, data) {\n\t    var gestureEvent = document.createEvent('Event');\n\t    gestureEvent.initEvent(event, true, true);\n\t    gestureEvent.gesture = data;\n\t    data.target.dispatchEvent(gestureEvent);\n\t}\n\t\n\textend(Hammer, {\n\t    INPUT_START: INPUT_START,\n\t    INPUT_MOVE: INPUT_MOVE,\n\t    INPUT_END: INPUT_END,\n\t    INPUT_CANCEL: INPUT_CANCEL,\n\t\n\t    STATE_POSSIBLE: STATE_POSSIBLE,\n\t    STATE_BEGAN: STATE_BEGAN,\n\t    STATE_CHANGED: STATE_CHANGED,\n\t    STATE_ENDED: STATE_ENDED,\n\t    STATE_RECOGNIZED: STATE_RECOGNIZED,\n\t    STATE_CANCELLED: STATE_CANCELLED,\n\t    STATE_FAILED: STATE_FAILED,\n\t\n\t    DIRECTION_NONE: DIRECTION_NONE,\n\t    DIRECTION_LEFT: DIRECTION_LEFT,\n\t    DIRECTION_RIGHT: DIRECTION_RIGHT,\n\t    DIRECTION_UP: DIRECTION_UP,\n\t    DIRECTION_DOWN: DIRECTION_DOWN,\n\t    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n\t    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n\t    DIRECTION_ALL: DIRECTION_ALL,\n\t\n\t    Manager: Manager,\n\t    Input: Input,\n\t    TouchAction: TouchAction,\n\t\n\t    TouchInput: TouchInput,\n\t    MouseInput: MouseInput,\n\t    PointerEventInput: PointerEventInput,\n\t    TouchMouseInput: TouchMouseInput,\n\t    SingleTouchInput: SingleTouchInput,\n\t\n\t    Recognizer: Recognizer,\n\t    AttrRecognizer: AttrRecognizer,\n\t    Tap: TapRecognizer,\n\t    Pan: PanRecognizer,\n\t    Swipe: SwipeRecognizer,\n\t    Pinch: PinchRecognizer,\n\t    Rotate: RotateRecognizer,\n\t    Press: PressRecognizer,\n\t\n\t    on: addEventListeners,\n\t    off: removeEventListeners,\n\t    each: each,\n\t    merge: merge,\n\t    extend: extend,\n\t    inherit: inherit,\n\t    bindFn: bindFn,\n\t    prefixed: prefixed\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t    module.exports = Hammer;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t    return Hammer;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(React) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\t__webpack_require__(18);\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(17);\n\t\n\tvar _xscroll = __webpack_require__(30);\n\t\n\tvar _xscroll2 = _interopRequireDefault(_xscroll);\n\t\n\tvar _pullup = __webpack_require__(28);\n\t\n\tvar _pullup2 = _interopRequireDefault(_pullup);\n\t\n\tvar _pulldown = __webpack_require__(27);\n\t\n\tvar _pulldown2 = _interopRequireDefault(_pulldown);\n\t\n\tvar _infinite = __webpack_require__(26);\n\t\n\tvar _infinite2 = _interopRequireDefault(_infinite);\n\t\n\tvar _classnames = __webpack_require__(31);\n\t\n\tvar _classnames2 = _interopRequireDefault(_classnames);\n\t\n\tvar _nZepto = __webpack_require__(15);\n\t\n\tvar _nZepto2 = _interopRequireDefault(_nZepto);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar instanceMap = {};\n\t\n\tvar ReactXScroll = function (_React$Component) {\n\t  _inherits(ReactXScroll, _React$Component);\n\t\n\t  _createClass(ReactXScroll, null, [{\n\t    key: 'createIscroll',\n\t    value: function createIscroll(inOptions) {\n\t      return new _xscroll2.default(inOptions);\n\t    }\n\t  }, {\n\t    key: 'createPullUpPlugin',\n\t    value: function createPullUpPlugin(inScrollInstance, inOptions) {\n\t      var pullup = new _pullup2.default(inOptions);\n\t      inScrollInstance.plug(pullup);\n\t      return pullup;\n\t    }\n\t  }, {\n\t    key: 'createPullDownPlugin',\n\t    value: function createPullDownPlugin(inScrollInstance, inOptions) {\n\t      var pulldown = new _pulldown2.default(inOptions);\n\t      inScrollInstance.plug(pulldown);\n\t      return pulldown;\n\t    }\n\t  }, {\n\t    key: 'createInfinitePlugin',\n\t    value: function createInfinitePlugin(inScrollInstance, inOptions) {\n\t      var infinite = new _infinite2.default(inOptions);\n\t      inScrollInstance.plug(infinite);\n\t      return infinite;\n\t    }\n\t  }, {\n\t    key: 'getInstance',\n\t    value: function getInstance(inHandle) {\n\t      return instanceMap[inHandle];\n\t    }\n\t  }]);\n\t\n\t  function ReactXScroll(inProps) {\n\t    _classCallCheck(this, ReactXScroll);\n\t\n\t    var _this = _possibleConstructorReturn(this, (ReactXScroll.__proto__ || Object.getPrototypeOf(ReactXScroll)).call(this, inProps));\n\t\n\t    instanceMap[inProps.delegateHandle] = _this;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(ReactXScroll, [{\n\t    key: 'componentDidMount',\n\t    value: function componentDidMount() {\n\t      var self = this;\n\t      var xscroll = this._xscroll = ReactXScroll.createIscroll(this.props.xscrollOptions);\n\t      var infinite = this._infinite = ReactXScroll.createInfinitePlugin(this._xscroll, this.props.infiniteOptions);\n\t      var pullup = this._pullup = ReactXScroll.createPullUpPlugin(this._xscroll, this.props.pullupOptions);\n\t      var pulldown = this._pulldown = ReactXScroll.createPullDownPlugin(this._xscroll, this.props.pulldownOptions);\n\t\n\t      pullup.on('loading', function () {\n\t        self.props.onInfinite(self);\n\t      });\n\t\n\t      pulldown.on('loading', function (e) {\n\t        self.props.onRefresh(self);\n\t      });\n\t\n\t      this.props.onInfinite(this);\n\t      xscroll.render();\n\t    }\n\t  }, {\n\t    key: 'invoke',\n\t    value: function invoke(inName) {\n\t      var args = [].slice.call(arguments, 1);\n\t      return this._xscroll[inName].apply(this._xscroll, args);\n\t    }\n\t  }, {\n\t    key: 'render',\n\t    value: function render() {\n\t      return React.createElement(\n\t        'div',\n\t        { 'data-delegate-handle': this.props.delegateHandle, className: (0, _classnames2.default)('react-xscroll-wrapper', this.props.cssClass) },\n\t        this.props.children\n\t      );\n\t    }\n\t  }]);\n\t\n\t  return ReactXScroll;\n\t}(React.Component);\n\t\n\tReactXScroll.propTypes = {\n\t  cssClass: React.PropTypes.string,\n\t  delegateHandle: React.PropTypes.string,\n\t  xscrollOptions: React.PropTypes.object,\n\t  pulldownOptions: React.PropTypes.object,\n\t  pullupOptions: React.PropTypes.object,\n\t  infiniteOptions: React.PropTypes.object,\n\t  onRefresh: React.PropTypes.func,\n\t  onInfinite: React.PropTypes.func\n\t};\n\tReactXScroll.defaultProps = {\n\t  cssClass: 'wrapper',\n\t  delegateHandle: '',\n\t  xscrollOptions: {},\n\t  pulldownOptions: {},\n\t  pullupOptions: {},\n\t  infiniteOptions: {},\n\t  onRefresh: null,\n\t  onInfinite: null\n\t};\n\texports.default = ReactXScroll;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t    Base = __webpack_require__(2),\n\t    Animate = __webpack_require__(3),\n\t    Boundry = __webpack_require__(19),\n\t    Hammer = __webpack_require__(6),\n\t    Sticky = __webpack_require__(23),\n\t    Fixed = __webpack_require__(21);\n\t// boundry checked bounce effect\n\tvar BOUNDRY_CHECK_DURATION = 500;\n\tvar BOUNDRY_CHECK_EASING = \"ease\";\n\tvar BOUNDRY_CHECK_ACCELERATION = 0.1;\n\t/** \n\t * @constructor\n\t * @param {object} cfg config for scroll\n\t * @param {number} cfg.SCROLL_ACCELERATION  acceleration for scroll, min value make the scrolling smoothly\n\t * @param {number} cfg.BOUNDRY_CHECK_DURATION duration for boundry bounce\n\t * @param {number} cfg.BOUNDRY_CHECK_EASING easing for boundry bounce\n\t * @param {number} cfg.BOUNDRY_CHECK_ACCELERATION acceleration for boundry bounce\n\t * @param {boolean} cfg.lockX just like overflow-x:hidden\n\t * @param {boolean} cfg.lockY just like overflow-y:hidden\n\t * @param {boolean} cfg.scrollbarX config if the scrollbar-x is visible\n\t * @param {boolean} cfg.scrollbarY config if the scrollbar-y is visible\n\t * @param {boolean} cfg.useTransition config if use css3 transition or raf for scroll animation\n\t * @param {boolean} cfg.useOriginScroll config if use simulate or origin scroll\n\t * @param {boolean} cfg.bounce config if use has the bounce effect when scrolling outside of the boundry\n\t * @param {boolean} cfg.boundryCheck config if scrolling inside of the boundry\n\t * @param {boolean} cfg.preventDefault prevent touchstart\n\t * @param {boolean} cfg.preventTouchMove prevent touchmove\n\t * @param {string|HTMLElement}  cfg.container config for scroller's container which default value is \".xs-container\"\n\t * @param {string|HTMLElement}  cfg.content config for scroller's content which default value is \".xs-content\"\n\t * @param {object}  cfg.indicatorInsets  config scrollbars position {top: number, left: number, bottom: number, right: number}\n\t * @param {string}  cfg.stickyElements config for sticky-positioned elements\n\t * @param {string}  cfg.fixedElements config for fixed-positioned elements\n\t * @param {string}  cfg.touchAction config for touchAction of the scroller\n\t * @extends XScroll\n\t * @example\n\t * var xscroll = new XScroll({\n\t *    renderTo:\"#scroll\",\n\t *    lockX:false,\n\t *    scrollbarX:true\n\t * });\n\t * xscroll.render();\n\t */\n\tfunction XScroll(cfg) {\n\t    XScroll.superclass.constructor.call(this);\n\t    this.userConfig = cfg;\n\t    this.init();\n\t}\n\t\n\tUtil.extend(XScroll, Base, {\n\t    /**\n\t     * version\n\t     * @memberof XScroll\n\t     * @type {string}\n\t     */\n\t    version: \"3.0.13\",\n\t    /**\n\t     * init scroll\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    init: function() {\n\t        var self = this;\n\t        var defaultCfg = {\n\t            preventDefault: true,\n\t            bounce: true,\n\t            boundryCheck: true,\n\t            useTransition: true,\n\t            gpuAcceleration: true,\n\t            BOUNDRY_CHECK_EASING: BOUNDRY_CHECK_EASING,\n\t            BOUNDRY_CHECK_DURATION: BOUNDRY_CHECK_DURATION,\n\t            BOUNDRY_CHECK_ACCELERATION: BOUNDRY_CHECK_ACCELERATION,\n\t            useOriginScroll: false,\n\t            zoomType: \"y\",\n\t            indicatorInsets: {\n\t                top: 3,\n\t                bottom: 3,\n\t                left: 3,\n\t                right: 3,\n\t                width: 3,\n\t                spacing: 5\n\t            },\n\t            container: \".xs-container\",\n\t            content: \".xs-content\",\n\t            stickyElements: \".xs-sticky\",\n\t            fixedElements: \".xs-fixed\",\n\t            touchAction: \"auto\"\n\t        };\n\t        //generate guid\n\t        self.guid = Util.guid();\n\t        self.renderTo = Util.getNode(self.userConfig.renderTo);\n\t        //timer for animtion\n\t        self.__timers = {};\n\t        //config attributes on element\n\t        var elCfg = JSON.parse(self.renderTo.getAttribute('xs-cfg'));\n\t        var userConfig = self.userConfig = Util.mix(Util.mix(defaultCfg, elCfg), self.userConfig);\n\t        self.container = Util.getNode(userConfig.container,self.renderTo);\n\t        self.content = Util.getNode(userConfig.content,self.renderTo);\n\t        self.boundry = new Boundry();\n\t        self.boundry.refresh();\n\t        return self;\n\t    },\n\t    /**\n\t     * destroy scroll\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    destroy: function() {\n\t        var self = this;\n\t        self.mc && self.mc.destroy();\n\t        self.sticky && self.sticky.destroy();\n\t        self.fixed && self.fixed.destroy();\n\t    },\n\t    _initContainer: function() {},\n\t    /**\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    enableGPUAcceleration: function() {\n\t        this.userConfig.gpuAcceleration = true;\n\t        return this;\n\t    },\n\t    /**\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    disableGPUAcceleration: function() {\n\t        this.userConfig.gpuAcceleration = false;\n\t        return this;\n\t    },\n\t    /**\n\t     * get scroll offset\n\t     * @memberof XScroll\n\t     * @return {Object} {scrollTop:scrollTop,scrollLeft:scrollLeft}\n\t     */\n\t    getScrollPos: function() {\n\t        var self = this;\n\t        return {\n\t            scrollLeft: self.getScrollLeft(),\n\t            scrollTop: self.getScrollTop()\n\t        }\n\t    },\n\t    /**\n\t     * get scroll top value\n\t     * @memberof XScroll\n\t     * @return {number} scrollTop\n\t     */\n\t    getScrollTop: function() {},\n\t    /**\n\t     * get scroll left value\n\t     * @memberof XScroll\n\t     * @return {number} scrollLeft\n\t     */\n\t    getScrollLeft: function() {},\n\t    /**\n\t     * scroll absolute to the destination\n\t     * @memberof XScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollTo: function(scrollLeft, scrollTop, duration, easing, callback) {\n\t        var self = this;\n\t        var scrollLeft = (undefined === scrollLeft || isNaN(scrollLeft)) ? -self.getScrollLeft() : scrollLeft;\n\t        var scrollTop = (undefined === scrollTop || isNaN(scrollTop)) ? -self.getScrollTop() : scrollTop;\n\t        self.scrollLeft(scrollLeft, duration, easing, callback);\n\t        self.scrollTop(scrollTop, duration, easing, callback);\n\t    },\n\t    /**\n\t     * scroll relative to the destination\n\t     * @memberof XScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollBy: function(scrollLeft, scrollTop, duration, easing, callback) {\n\t        this.scrollByX(scrollLeft, duration, easing, callback);\n\t        this.scrollByY(scrollTop, duration, easing, callback);\n\t    },\n\t    /**\n\t     * horizontal scroll relative to the destination\n\t     * @memberof XScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollLeftBy: function(scrollLeft, duration, easing, callback) {\n\t        this.scrollLeft(Number(scrollLeft) + Number(this.getScrollLeft()), duration, easing, callback);\n\t    },\n\t    /**\n\t     * vertical scroll relative to the destination\n\t     * @memberof XScroll\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollTopBy: function(scrollTop, duration, easing, callback) {\n\t        this.scrollTop(Number(scrollTop) + Number(this.getScrollTop()), duration, easing, callback);\n\t    },\n\t    /**\n\t     * horizontal scroll absolute to the destination\n\t     * @memberof XScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollLeft: function(scrollLeft, duration, easing, callback) {},\n\t    /**\n\t     * vertical scroll absolute to the destination\n\t     * @memberof XScroll\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollTop: function(scrollTop, duration, easing, callback) {},\n\t    /**\n\t     * reset the boundry size\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    resetSize: function() {\n\t        var self = this;\n\t        if(!self.container || !self.content) return;\n\t        var userConfig = self.userConfig;\n\t        var renderToStyle = getComputedStyle(self.renderTo);\n\t        var width = self.width = (userConfig.width || self.renderTo.offsetWidth) - Util.px2Num(renderToStyle['padding-left']) - Util.px2Num(renderToStyle['padding-right']);\n\t        var height = self.height = (userConfig.height || self.renderTo.offsetHeight) - Util.px2Num(renderToStyle['padding-top']) - Util.px2Num(renderToStyle['padding-bottom']);;\n\t        var containerWidth = userConfig.containerWidth || self.content.offsetWidth;\n\t        var containerHeight = userConfig.containerHeight || self.content.offsetHeight;\n\t        self.containerWidth = containerWidth < self.width ? self.width : containerWidth;\n\t        self.containerHeight = containerHeight < self.height ? self.height : containerHeight;\n\t        self.boundry.refresh({\n\t            width: self.width,\n\t            height: self.height\n\t        });\n\t        return self;\n\t    },\n\t    /**\n\t     * render scroll\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    render: function() {\n\t        var self = this;\n\t        self.resetSize();\n\t        //init stickies\n\t        self.initSticky();\n\t        //init fixed elements\n\t        self.initFixed();\n\t\n\t        self.trigger(\"afterrender\", {\n\t            type: \"afterrender\"\n\t        });\n\t        self._bindEvt();\n\t        //update touch-action \n\t        self.initTouchAction();\n\t        return self;\n\t    },\n\t    /**\n\t     * init touch action\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     */\n\t    initTouchAction: function() {\n\t        var self = this;\n\t        self.mc.set({\n\t            touchAction: self.userConfig.touchAction\n\t        });\n\t        return self;\n\t    },\n\t    initFixed: function() {\n\t        var self = this,\n\t            userConfig = self.userConfig;\n\t        self.fixed = self.fixed || new Fixed({\n\t            fixedElements:userConfig.fixedElements,\n\t            xscroll:self,\n\t            fixedRenderTo:userConfig.fixedRenderTo\n\t        });\n\t        self.fixed.render();\n\t        self.resetSize();\n\t        return self;\n\t    },\n\t    initSticky:function(){\n\t        var self = this,userConfig = self.userConfig;\n\t        var sticky = self.sticky = self.sticky || new Sticky({\n\t            xscroll:self,\n\t            zoomType:userConfig.zoomType,\n\t            stickyRenderTo:userConfig.stickyRenderTo\n\t        });\n\t        sticky.render();\n\t    },\n\t    /**\n\t     * bounce to the boundry vertical and horizontal\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    boundryCheck: function() {\n\t        return this;\n\t    },\n\t    /**\n\t     * bounce to the boundry horizontal\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    boundryCheckX: function() {\n\t        return this;\n\t    },\n\t    /**\n\t     * bounce to the boundry vertical\n\t     * @memberof XScroll\n\t     * @return {XScroll}\n\t     **/\n\t    boundryCheckY: function() {\n\t        return this;\n\t    },\n\t    _bindEvt: function() {\n\t        var self = this;\n\t        if (self.___isEvtBind) return;\n\t        self.___isEvtBind = true;\n\t        var mc = self.mc = new Hammer.Manager(self.renderTo);\n\t        var tap = new Hammer.Tap();\n\t        var pan = new Hammer.Pan();\n\t        var pinch = new Hammer.Pinch();\n\t        mc.add([tap, pan]);\n\t        //trigger all events \n\t        self.mc.on(\"panstart pan panend pancancel pinchstart pinchmove pinchend pinchcancel pinchin pinchout\", function(e) {\n\t            self.trigger(e.type, e);\n\t        });\n\t        //trigger touch events\n\t        var touchEvents = ['touchstart', 'touchmove', 'touchend', 'touchcancel','mousedown'];\n\t        for (var i = 0, l = touchEvents.length; i < l; i++) {\n\t            self.renderTo.addEventListener(touchEvents[i], function(e) {\n\t                self.trigger(e.type, e);\n\t            });\n\t        }\n\t        self.mc.on(\"tap\", function(e) {\n\t            if (e.tapCount == 1) {\n\t                e.type = \"tap\";\n\t                self.trigger(e.type, e);\n\t            } else if (e.tapCount == 2) {\n\t                e.type = \"doubletap\";\n\t                self.trigger(\"doubletap\", e);\n\t            }\n\t        });\n\t        return self;\n\t    },\n\t    _resetLockConfig: function() {},\n\t    stop: function() {}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t    module.exports = XScroll;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t    return XScroll;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\t//easing\n\tvar Easing = {\n\t\t\"linear\": [0, 0, 1, 1],\n\t\t\"ease\": [.25, .1, .25, 1],\n\t\t\"ease-in\":[.42,0,1,1],\n\t\t\"ease-out\": [0, 0, .58, 1],\n\t\t\"ease-in-out\": [.42, 0, .58, 1],\n\t\t\"quadratic\": [0.33, 0.66, 0.66, 1],\n\t\t\"circular\": [0.1, 0.57, 0.1, 1],\n\t\t\"bounce\": [.71, 1.35, .47, 1.41],\n\t\tformat: function(easing) {\n\t\t\tif (!easing) return;\n\t\t\tif (typeof easing === \"string\" && this[easing]) {\n\t\t\t\treturn this[easing] instanceof Array ? [\" cubic-bezier(\", this[easing], \") \"].join(\"\") : this[easing];\n\t\t\t}\n\t\t\tif (easing instanceof Array) {\n\t\t\t\treturn [\" cubic-bezier(\", easing, \") \"].join(\"\");\n\t\t\t}\n\t\t\treturn easing;\n\t\t}\n\t}\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Easing;\n\t}\n\t/** ignored by jsdoc **/\n\t else {\n\t\treturn Easing;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\tvar Easing = __webpack_require__(9);\n\t\n\tvar RAF = window.requestAnimationFrame ||\n\t\twindow.webkitRequestAnimationFrame ||\n\t\twindow.mozRequestAnimationFrame ||\n\t\twindow.oRequestAnimationFrame ||\n\t\twindow.msRequestAnimationFrame ||\n\t\tfunction(callback) {\n\t\t\twindow.setTimeout(callback, 1000 / 60);\n\t\t};\n\t\n\tvar vendors = ['webkit', 'moz', 'ms', 'o'];\n\tvar cancelRAF = window.cancelAnimationFrame;\n\tfor (var i = 0; i < vendors.length; i++) {\n\t\tif (window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame']) {\n\t\t\tcancelRAF = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];\n\t\t}\n\t}\n\tcancelRAF = cancelRAF || window.clearTimeout;\n\t\n\tfunction Bezier(x1, y1, x2, y2, epsilon) {\n\t\tvar curveX = function(t) {\n\t\t\tvar v = 1 - t;\n\t\t\treturn 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;\n\t\t};\n\t\n\t\tvar curveY = function(t) {\n\t\t\tvar v = 1 - t;\n\t\t\treturn 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;\n\t\t};\n\t\n\t\tvar derivativeCurveX = function(t) {\n\t\t\tvar v = 1 - t;\n\t\t\treturn 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (-t * t * t + 2 * v * t) * x2;\n\t\t};\n\t\n\t\treturn function(t) {\n\t\n\t\t\tvar x = t,\n\t\t\t\tt0, t1, t2, x2, d2, i;\n\t\n\t\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\t\tfor (t2 = x, i = 0; i < 8; i++) {\n\t\t\t\tx2 = curveX(t2) - x;\n\t\t\t\tif (Math.abs(x2) < epsilon) return curveY(t2);\n\t\t\t\td2 = derivativeCurveX(t2);\n\t\t\t\tif (Math.abs(d2) < 1e-6) break;\n\t\t\t\tt2 = t2 - x2 / d2;\n\t\t\t}\n\t\n\t\t\tt0 = 0, t1 = 1, t2 = x;\n\t\n\t\t\tif (t2 < t0) return curveY(t0);\n\t\t\tif (t2 > t1) return curveY(t1);\n\t\n\t\t\t// Fallback to the bisection method for reliability.\n\t\t\twhile (t0 < t1) {\n\t\t\t\tx2 = curveX(t2);\n\t\t\t\tif (Math.abs(x2 - x) < epsilon) return curveY(t2);\n\t\t\t\tif (x > x2) t0 = t2;\n\t\t\t\telse t1 = t2;\n\t\t\t\tt2 = (t1 - t0) * .5 + t0;\n\t\t\t}\n\t\n\t\t\t// Failure\n\t\t\treturn curveY(t2);\n\t\n\t\t};\n\t\n\t};\n\t\n\t\n\t\n\tfunction Timer(cfg) {\n\t\tvar self = this;\n\t\tself.cfg = Util.mix({\n\t\t\teasing: \"linear\"\n\t\t}, cfg)\n\t}\n\t\n\tTimer.MIN_DURATION = 1;\n\t\n\tUtil.extend(Timer, Base, {\n\t\treset: function(cfg) {\n\t\t\tvar self = this;\n\t\t\tUtil.mix(self.cfg, cfg);\n\t\t\tself.isfinished = false;\n\t\t\tself.percent = 0;\n\t\t\tself._stop = null;\n\t\t},\n\t\trun: function() {\n\t\t\tvar self = this;\n\t\t\tvar duration = self.cfg.duration;\n\t\t\tif (duration <= Timer.MIN_DURATION) {\n\t\t\t\tself.isfinished = true;\n\t\t\t\tself.trigger(\"run\", {\n\t\t\t\t\tpercent: 1\n\t\t\t\t});\n\t\t\t\tself.trigger(\"end\", {\n\t\t\t\t\tpercent: 1\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (self.isfinished) return;\n\t\t\tself._hasFinishedPercent = self._stop && self._stop.percent || 0;\n\t\t\tself._stop = null;\n\t\t\tself.start = Date.now();\n\t\t\tself.percent = 0;\n\t\t\t// epsilon determines the precision of the solved values\n\t\t\tvar epsilon = (1000 / 60 / duration) / 4;\n\t\t\tvar b = Easing[self.cfg.easing];\n\t\t\tself.easingFn = Bezier(b[0], b[1], b[2], b[3], epsilon);\n\t\t\tself._run();\n\t\t},\n\t\t_run: function() {\n\t\t\tvar self = this;\n\t\t\tcancelRAF(self._raf);\n\t\t\tself._raf = RAF(function() {\n\t\t\t\tself.now = Date.now();\n\t\t\t\tself.duration = self.now - self.start >= self.cfg.duration ? self.cfg.duration : self.now - self.start;\n\t\t\t\tself.progress = self.easingFn(self.duration / self.cfg.duration);\n\t\t\t\tself.percent = self.duration / self.cfg.duration + self._hasFinishedPercent;\n\t\t\t\tif (self.percent >= 1 || self._stop) {\n\t\t\t\t\tself.percent = self._stop && self._stop.percent ? self._stop.percent : 1;\n\t\t\t\t\tself.duration = self._stop && self._stop.duration ? self._stop.duration : self.duration;\n\t\t\t\t\tvar param = {\n\t\t\t\t\t\tpercent: self.percent\n\t\t\t\t\t};\n\t\t\t\t\tself.trigger(\"stop\", param);\n\t\t\t\t\tif (self.percent >= 1) {\n\t\t\t\t\t\tself.isfinished = true;\n\t\t\t\t\t\tself.trigger(\"end\", {\n\t\t\t\t\t\t\tpercent: 1\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tself.trigger(\"run\", {\n\t\t\t\t\tpercent: self.progress,\n\t\t\t\t\toriginPercent:self.percent\n\t\t\t\t});\n\t\t\t\tself._run();\n\t\t\t})\n\t\t},\n\t\tstop: function() {\n\t\t\tvar self = this;\n\t\t\tself._stop = {\n\t\t\t\tpercent: self.percent,\n\t\t\t\tnow: self.now\n\t\t\t};\n\t\t\tcancelRAF(self._raf)\n\t\t}\n\t});\n\t\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Timer;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Timer;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _reactXscroll = __webpack_require__(7);\n\t\n\tvar _reactXscroll2 = _interopRequireDefault(_reactXscroll);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ReactXScrollCtrl = function () {\n\t  function ReactXScrollCtrl() {\n\t    _classCallCheck(this, ReactXScrollCtrl);\n\t  }\n\t\n\t  _createClass(ReactXScrollCtrl, null, [{\n\t    key: 'getInstance',\n\t    value: function getInstance(inHandle) {\n\t      return _reactXscroll2.default.getInstance(inHandle);\n\t    }\n\t  }]);\n\t\n\t  return ReactXScrollCtrl;\n\t}();\n\t\n\texports.default = ReactXScrollCtrl;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".xs-plugin-pulldown-container{text-align:center;width:100%;line-height:50px}.xs-plugin-pulldown-up .up{display:inline}.xs-plugin-pulldown-down .up,.xs-plugin-pulldown-up .down{display:none}.xs-plugin-pulldown-down .down{display:inline}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".xs-plugin-pullup-container{line-height:40px;text-align:center}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(4)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\r\n\t(function(global, factory) {\r\n\t    if(exports === 'object' && typeof module !== 'undefined')\r\n\t        module.exports = factory(global)\r\n\t    if (true)\r\n\t        !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return factory(global) }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\t    else\r\n\t        factory(global)\r\n\t}( typeof window !== \"undefined\" ? window : this, function(window) {\r\n\t    var Zepto = (function() {\r\n\t        var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\r\n\t            document = window.document,\r\n\t            elementDisplay = {}, classCache = {},\r\n\t            cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\r\n\t            fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\r\n\t            singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\r\n\t            tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\r\n\t            rootNodeRE = /^(?:body|html)$/i,\r\n\t            capitalRE = /([A-Z])/g,\r\n\t\r\n\t            // special attributes that should be get/set via method calls\r\n\t            methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\r\n\t\r\n\t            adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\r\n\t            table = document.createElement('table'),\r\n\t            tableRow = document.createElement('tr'),\r\n\t            containers = {\r\n\t                'tr': document.createElement('tbody'),\r\n\t                'tbody': table, 'thead': table, 'tfoot': table,\r\n\t                'td': tableRow, 'th': tableRow,\r\n\t                '*': document.createElement('div')\r\n\t            },\r\n\t            readyRE = /complete|loaded|interactive/,\r\n\t            simpleSelectorRE = /^[\\w-]*$/,\r\n\t            class2type = {},\r\n\t            toString = class2type.toString,\r\n\t            zepto = {},\r\n\t            camelize, uniq,\r\n\t            tempParent = document.createElement('div'),\r\n\t            propMap = {\r\n\t                'tabindex': 'tabIndex',\r\n\t                'readonly': 'readOnly',\r\n\t                'for': 'htmlFor',\r\n\t                'class': 'className',\r\n\t                'maxlength': 'maxLength',\r\n\t                'cellspacing': 'cellSpacing',\r\n\t                'cellpadding': 'cellPadding',\r\n\t                'rowspan': 'rowSpan',\r\n\t                'colspan': 'colSpan',\r\n\t                'usemap': 'useMap',\r\n\t                'frameborder': 'frameBorder',\r\n\t                'contenteditable': 'contentEditable'\r\n\t            },\r\n\t            isArray = Array.isArray ||\r\n\t                function(object){ return object instanceof Array }\r\n\t\r\n\t        zepto.matches = function(element, selector) {\r\n\t            if (!selector || !element || element.nodeType !== 1) return false\r\n\t            var matchesSelector = element.matches || element.webkitMatchesSelector ||\r\n\t                element.mozMatchesSelector || element.oMatchesSelector ||\r\n\t                element.matchesSelector\r\n\t            if (matchesSelector) return matchesSelector.call(element, selector)\r\n\t            // fall back to performing a selector:\r\n\t            var match, parent = element.parentNode, temp = !parent\r\n\t            if (temp) (parent = tempParent).appendChild(element)\r\n\t            match = ~zepto.qsa(parent, selector).indexOf(element)\r\n\t            temp && tempParent.removeChild(element)\r\n\t            return match\r\n\t        }\r\n\t\r\n\t        function type(obj) {\r\n\t            return obj == null ? String(obj) :\r\n\t            class2type[toString.call(obj)] || \"object\"\r\n\t        }\r\n\t\r\n\t        function isFunction(value) { return type(value) == \"function\" }\r\n\t        function isWindow(obj)     { return obj != null && obj == obj.window }\r\n\t        function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\r\n\t        function isObject(obj)     { return type(obj) == \"object\" }\r\n\t        function isPlainObject(obj) {\r\n\t            return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\r\n\t        }\r\n\t\r\n\t        function likeArray(obj) {\r\n\t            var length = !!obj && 'length' in obj && obj.length,\r\n\t                type = $.type(obj)\r\n\t\r\n\t            return 'function' != type && !isWindow(obj) && (\r\n\t                    'array' == type || length === 0 ||\r\n\t                    (typeof length == 'number' && length > 0 && (length - 1) in obj)\r\n\t                )\r\n\t        }\r\n\t\r\n\t        function compact(array) { return filter.call(array, function(item){ return item != null }) }\r\n\t        function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\r\n\t        camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\r\n\t        function dasherize(str) {\r\n\t            return str.replace(/::/g, '/')\r\n\t                .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\r\n\t                .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\r\n\t                .replace(/_/g, '-')\r\n\t                .toLowerCase()\r\n\t        }\r\n\t        uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\r\n\t\r\n\t        function classRE(name) {\r\n\t            return name in classCache ?\r\n\t                classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\r\n\t        }\r\n\t\r\n\t        function maybeAddPx(name, value) {\r\n\t            return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\r\n\t        }\r\n\t\r\n\t        function defaultDisplay(nodeName) {\r\n\t            var element, display\r\n\t            if (!elementDisplay[nodeName]) {\r\n\t                element = document.createElement(nodeName)\r\n\t                document.body.appendChild(element)\r\n\t                display = getComputedStyle(element, '').getPropertyValue(\"display\")\r\n\t                element.parentNode.removeChild(element)\r\n\t                display == \"none\" && (display = \"block\")\r\n\t                elementDisplay[nodeName] = display\r\n\t            }\r\n\t            return elementDisplay[nodeName]\r\n\t        }\r\n\t\r\n\t        function children(element) {\r\n\t            return 'children' in element ?\r\n\t                slice.call(element.children) :\r\n\t                $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\r\n\t        }\r\n\t\r\n\t        function Z(dom, selector) {\r\n\t            var i, len = dom ? dom.length : 0\r\n\t            for (i = 0; i < len; i++) this[i] = dom[i]\r\n\t            this.length = len\r\n\t            this.selector = selector || ''\r\n\t        }\r\n\t\r\n\t        // `$.zepto.fragment` takes a html string and an optional tag name\r\n\t        // to generate DOM nodes from the given html string.\r\n\t        // The generated DOM nodes are returned as an array.\r\n\t        // This function can be overridden in plugins for example to make\r\n\t        // it compatible with browsers that don't support the DOM fully.\r\n\t        zepto.fragment = function(html, name, properties) {\r\n\t            var dom, nodes, container\r\n\t\r\n\t            // A special case optimization for a single tag\r\n\t            if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\r\n\t\r\n\t            if (!dom) {\r\n\t                if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\r\n\t                if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\r\n\t                if (!(name in containers)) name = '*'\r\n\t\r\n\t                container = containers[name]\r\n\t                container.innerHTML = '' + html\r\n\t                dom = $.each(slice.call(container.childNodes), function(){\r\n\t                    container.removeChild(this)\r\n\t                })\r\n\t            }\r\n\t\r\n\t            if (isPlainObject(properties)) {\r\n\t                nodes = $(dom)\r\n\t                $.each(properties, function(key, value) {\r\n\t                    if (methodAttributes.indexOf(key) > -1) nodes[key](value)\r\n\t                    else nodes.attr(key, value)\r\n\t                })\r\n\t            }\r\n\t\r\n\t            return dom\r\n\t        }\r\n\t\r\n\t        // `$.zepto.Z` swaps out the prototype of the given `dom` array\r\n\t        // of nodes with `$.fn` and thus supplying all the Zepto functions\r\n\t        // to the array. This method can be overridden in plugins.\r\n\t        zepto.Z = function(dom, selector) {\r\n\t            return new Z(dom, selector)\r\n\t        }\r\n\t\r\n\t        // `$.zepto.isZ` should return `true` if the given object is a Zepto\r\n\t        // collection. This method can be overridden in plugins.\r\n\t        zepto.isZ = function(object) {\r\n\t            return object instanceof zepto.Z\r\n\t        }\r\n\t\r\n\t        // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\r\n\t        // takes a CSS selector and an optional context (and handles various\r\n\t        // special cases).\r\n\t        // This method can be overridden in plugins.\r\n\t        zepto.init = function(selector, context) {\r\n\t            var dom\r\n\t            // If nothing given, return an empty Zepto collection\r\n\t            if (!selector) return zepto.Z()\r\n\t            // Optimize for string selectors\r\n\t            else if (typeof selector == 'string') {\r\n\t                selector = selector.trim()\r\n\t                // If it's a html fragment, create nodes from it\r\n\t                // Note: In both Chrome 21 and Firefox 15, DOM error 12\r\n\t                // is thrown if the fragment doesn't begin with <\r\n\t                if (selector[0] == '<' && fragmentRE.test(selector))\r\n\t                    dom = zepto.fragment(selector, RegExp.$1, context), selector = null\r\n\t                // If there's a context, create a collection on that context first, and select\r\n\t                // nodes from there\r\n\t                else if (context !== undefined) return $(context).find(selector)\r\n\t                // If it's a CSS selector, use it to select nodes.\r\n\t                else dom = zepto.qsa(document, selector)\r\n\t            }\r\n\t            // If a function is given, call it when the DOM is ready\r\n\t            else if (isFunction(selector)) return $(document).ready(selector)\r\n\t            // If a Zepto collection is given, just return it\r\n\t            else if (zepto.isZ(selector)) return selector\r\n\t            else {\r\n\t                // normalize array if an array of nodes is given\r\n\t                if (isArray(selector)) dom = compact(selector)\r\n\t                // Wrap DOM nodes.\r\n\t                else if (isObject(selector))\r\n\t                    dom = [selector], selector = null\r\n\t                // If it's a html fragment, create nodes from it\r\n\t                else if (fragmentRE.test(selector))\r\n\t                    dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\r\n\t                // If there's a context, create a collection on that context first, and select\r\n\t                // nodes from there\r\n\t                else if (context !== undefined) return $(context).find(selector)\r\n\t                // And last but no least, if it's a CSS selector, use it to select nodes.\r\n\t                else dom = zepto.qsa(document, selector)\r\n\t            }\r\n\t            // create a new Zepto collection from the nodes found\r\n\t            return zepto.Z(dom, selector)\r\n\t        }\r\n\t\r\n\t        // `$` will be the base `Zepto` object. When calling this\r\n\t        // function just call `$.zepto.init, which makes the implementation\r\n\t        // details of selecting nodes and creating Zepto collections\r\n\t        // patchable in plugins.\r\n\t        $ = function(selector, context){\r\n\t            return zepto.init(selector, context)\r\n\t        }\r\n\t\r\n\t        function extend(target, source, deep) {\r\n\t            for (key in source)\r\n\t                if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n\t                    if (isPlainObject(source[key]) && !isPlainObject(target[key]))\r\n\t                        target[key] = {}\r\n\t                    if (isArray(source[key]) && !isArray(target[key]))\r\n\t                        target[key] = []\r\n\t                    extend(target[key], source[key], deep)\r\n\t                }\r\n\t                else if (source[key] !== undefined) target[key] = source[key]\r\n\t        }\r\n\t\r\n\t        // Copy all but undefined properties from one or more\r\n\t        // objects to the `target` object.\r\n\t        $.extend = function(target){\r\n\t            var deep, args = slice.call(arguments, 1)\r\n\t            if (typeof target == 'boolean') {\r\n\t                deep = target\r\n\t                target = args.shift()\r\n\t            }\r\n\t            args.forEach(function(arg){ extend(target, arg, deep) })\r\n\t            return target\r\n\t        }\r\n\t\r\n\t        // `$.zepto.qsa` is Zepto's CSS selector implementation which\r\n\t        // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\r\n\t        // This method can be overridden in plugins.\r\n\t        zepto.qsa = function(element, selector){\r\n\t            var found,\r\n\t                maybeID = selector[0] == '#',\r\n\t                maybeClass = !maybeID && selector[0] == '.',\r\n\t                nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\r\n\t                isSimple = simpleSelectorRE.test(nameOnly)\r\n\t            return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\r\n\t                ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\r\n\t                (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\r\n\t                    slice.call(\r\n\t                        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\r\n\t                            maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\r\n\t                                element.getElementsByTagName(selector) : // Or a tag\r\n\t                            element.querySelectorAll(selector) // Or it's not simple, and we need to query all\r\n\t                    )\r\n\t        }\r\n\t\r\n\t        function filtered(nodes, selector) {\r\n\t            return selector == null ? $(nodes) : $(nodes).filter(selector)\r\n\t        }\r\n\t\r\n\t        $.contains = document.documentElement.contains ?\r\n\t            function(parent, node) {\r\n\t                return parent !== node && parent.contains(node)\r\n\t            } :\r\n\t            function(parent, node) {\r\n\t                while (node && (node = node.parentNode))\r\n\t                    if (node === parent) return true\r\n\t                return false\r\n\t            }\r\n\t\r\n\t        function funcArg(context, arg, idx, payload) {\r\n\t            return isFunction(arg) ? arg.call(context, idx, payload) : arg\r\n\t        }\r\n\t\r\n\t        function setAttribute(node, name, value) {\r\n\t            value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\r\n\t        }\r\n\t\r\n\t        // access className property while respecting SVGAnimatedString\r\n\t        function className(node, value){\r\n\t            var klass = node.className || '',\r\n\t                svg   = klass && klass.baseVal !== undefined\r\n\t\r\n\t            if (value === undefined) return svg ? klass.baseVal : klass\r\n\t            svg ? (klass.baseVal = value) : (node.className = value)\r\n\t        }\r\n\t\r\n\t        // \"true\"  => true\r\n\t        // \"false\" => false\r\n\t        // \"null\"  => null\r\n\t        // \"42\"    => 42\r\n\t        // \"42.5\"  => 42.5\r\n\t        // \"08\"    => \"08\"\r\n\t        // JSON    => parse if valid\r\n\t        // String  => self\r\n\t        function deserializeValue(value) {\r\n\t            try {\r\n\t                return value ?\r\n\t                value == \"true\" ||\r\n\t                ( value == \"false\" ? false :\r\n\t                    value == \"null\" ? null :\r\n\t                        +value + \"\" == value ? +value :\r\n\t                            /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\r\n\t                                value )\r\n\t                    : value\r\n\t            } catch(e) {\r\n\t                return value\r\n\t            }\r\n\t        }\r\n\t\r\n\t        $.type = type\r\n\t        $.isFunction = isFunction\r\n\t        $.isWindow = isWindow\r\n\t        $.isArray = isArray\r\n\t        $.isPlainObject = isPlainObject\r\n\t\r\n\t        $.isEmptyObject = function(obj) {\r\n\t            var name\r\n\t            for (name in obj) return false\r\n\t            return true\r\n\t        }\r\n\t\r\n\t        $.isNumeric = function(val) {\r\n\t            var num = Number(val), type = typeof val\r\n\t            return val != null && type != 'boolean' &&\r\n\t                (type != 'string' || val.length) &&\r\n\t                !isNaN(num) && isFinite(num) || false\r\n\t        }\r\n\t\r\n\t        $.inArray = function(elem, array, i){\r\n\t            return emptyArray.indexOf.call(array, elem, i)\r\n\t        }\r\n\t\r\n\t        $.camelCase = camelize\r\n\t        $.trim = function(str) {\r\n\t            return str == null ? \"\" : String.prototype.trim.call(str)\r\n\t        }\r\n\t\r\n\t        // plugin compatibility\r\n\t        $.uuid = 0\r\n\t        $.support = { }\r\n\t        $.expr = { }\r\n\t        $.noop = function() {}\r\n\t\r\n\t        $.map = function(elements, callback){\r\n\t            var value, values = [], i, key\r\n\t            if (likeArray(elements))\r\n\t                for (i = 0; i < elements.length; i++) {\r\n\t                    value = callback(elements[i], i)\r\n\t                    if (value != null) values.push(value)\r\n\t                }\r\n\t            else\r\n\t                for (key in elements) {\r\n\t                    value = callback(elements[key], key)\r\n\t                    if (value != null) values.push(value)\r\n\t                }\r\n\t            return flatten(values)\r\n\t        }\r\n\t\r\n\t        $.each = function(elements, callback){\r\n\t            var i, key\r\n\t            if (likeArray(elements)) {\r\n\t                for (i = 0; i < elements.length; i++)\r\n\t                    if (callback.call(elements[i], i, elements[i]) === false) return elements\r\n\t            } else {\r\n\t                for (key in elements)\r\n\t                    if (callback.call(elements[key], key, elements[key]) === false) return elements\r\n\t            }\r\n\t\r\n\t            return elements\r\n\t        }\r\n\t\r\n\t        $.grep = function(elements, callback){\r\n\t            return filter.call(elements, callback)\r\n\t        }\r\n\t\r\n\t        if (window.JSON) $.parseJSON = JSON.parse\r\n\t\r\n\t        // Populate the class2type map\r\n\t        $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\r\n\t            class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\r\n\t        })\r\n\t\r\n\t        // Define methods that will be available on all\r\n\t        // Zepto collections\r\n\t        $.fn = {\r\n\t            constructor: zepto.Z,\r\n\t            length: 0,\r\n\t\r\n\t            // Because a collection acts like an array\r\n\t            // copy over these useful array functions.\r\n\t            forEach: emptyArray.forEach,\r\n\t            reduce: emptyArray.reduce,\r\n\t            push: emptyArray.push,\r\n\t            sort: emptyArray.sort,\r\n\t            splice: emptyArray.splice,\r\n\t            indexOf: emptyArray.indexOf,\r\n\t            concat: function(){\r\n\t                var i, value, args = []\r\n\t                for (i = 0; i < arguments.length; i++) {\r\n\t                    value = arguments[i]\r\n\t                    args[i] = zepto.isZ(value) ? value.toArray() : value\r\n\t                }\r\n\t                return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\r\n\t            },\r\n\t\r\n\t            // `map` and `slice` in the jQuery API work differently\r\n\t            // from their array counterparts\r\n\t            map: function(fn){\r\n\t                return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\r\n\t            },\r\n\t            slice: function(){\r\n\t                return $(slice.apply(this, arguments))\r\n\t            },\r\n\t\r\n\t            ready: function(callback){\r\n\t                // need to check if document.body exists for IE as that browser reports\r\n\t                // document ready when it hasn't yet created the body element\r\n\t                if (readyRE.test(document.readyState) && document.body) callback($)\r\n\t                else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\r\n\t                return this\r\n\t            },\r\n\t            get: function(idx){\r\n\t                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\r\n\t            },\r\n\t            toArray: function(){ return this.get() },\r\n\t            size: function(){\r\n\t                return this.length\r\n\t            },\r\n\t            remove: function(){\r\n\t                return this.each(function(){\r\n\t                    if (this.parentNode != null)\r\n\t                        this.parentNode.removeChild(this)\r\n\t                })\r\n\t            },\r\n\t            each: function(callback){\r\n\t                emptyArray.every.call(this, function(el, idx){\r\n\t                    return callback.call(el, idx, el) !== false\r\n\t                })\r\n\t                return this\r\n\t            },\r\n\t            filter: function(selector){\r\n\t                if (isFunction(selector)) return this.not(this.not(selector))\r\n\t                return $(filter.call(this, function(element){\r\n\t                    return zepto.matches(element, selector)\r\n\t                }))\r\n\t            },\r\n\t            add: function(selector,context){\r\n\t                return $(uniq(this.concat($(selector,context))))\r\n\t            },\r\n\t            is: function(selector){\r\n\t                return this.length > 0 && zepto.matches(this[0], selector)\r\n\t            },\r\n\t            not: function(selector){\r\n\t                var nodes=[]\r\n\t                if (isFunction(selector) && selector.call !== undefined)\r\n\t                    this.each(function(idx){\r\n\t                        if (!selector.call(this,idx)) nodes.push(this)\r\n\t                    })\r\n\t                else {\r\n\t                    var excludes = typeof selector == 'string' ? this.filter(selector) :\r\n\t                        (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\r\n\t                    this.forEach(function(el){\r\n\t                        if (excludes.indexOf(el) < 0) nodes.push(el)\r\n\t                    })\r\n\t                }\r\n\t                return $(nodes)\r\n\t            },\r\n\t            has: function(selector){\r\n\t                return this.filter(function(){\r\n\t                    return isObject(selector) ?\r\n\t                        $.contains(this, selector) :\r\n\t                        $(this).find(selector).size()\r\n\t                })\r\n\t            },\r\n\t            eq: function(idx){\r\n\t                return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\r\n\t            },\r\n\t            first: function(){\r\n\t                var el = this[0]\r\n\t                return el && !isObject(el) ? el : $(el)\r\n\t            },\r\n\t            last: function(){\r\n\t                var el = this[this.length - 1]\r\n\t                return el && !isObject(el) ? el : $(el)\r\n\t            },\r\n\t            find: function(selector){\r\n\t                var result, $this = this\r\n\t                if (!selector) result = $()\r\n\t                else if (typeof selector == 'object')\r\n\t                    result = $(selector).filter(function(){\r\n\t                        var node = this\r\n\t                        return emptyArray.some.call($this, function(parent){\r\n\t                            return $.contains(parent, node)\r\n\t                        })\r\n\t                    })\r\n\t                else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\r\n\t                else result = this.map(function(){ return zepto.qsa(this, selector) })\r\n\t                return result\r\n\t            },\r\n\t            closest: function(selector, context){\r\n\t                var nodes = [], collection = typeof selector == 'object' && $(selector)\r\n\t                this.each(function(_, node){\r\n\t                    while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\r\n\t                        node = node !== context && !isDocument(node) && node.parentNode\r\n\t                    if (node && nodes.indexOf(node) < 0) nodes.push(node)\r\n\t                })\r\n\t                return $(nodes)\r\n\t            },\r\n\t            parents: function(selector){\r\n\t                var ancestors = [], nodes = this\r\n\t                while (nodes.length > 0)\r\n\t                    nodes = $.map(nodes, function(node){\r\n\t                        if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\r\n\t                            ancestors.push(node)\r\n\t                            return node\r\n\t                        }\r\n\t                    })\r\n\t                return filtered(ancestors, selector)\r\n\t            },\r\n\t            parent: function(selector){\r\n\t                return filtered(uniq(this.pluck('parentNode')), selector)\r\n\t            },\r\n\t            children: function(selector){\r\n\t                return filtered(this.map(function(){ return children(this) }), selector)\r\n\t            },\r\n\t            contents: function() {\r\n\t                return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\r\n\t            },\r\n\t            siblings: function(selector){\r\n\t                return filtered(this.map(function(i, el){\r\n\t                    return filter.call(children(el.parentNode), function(child){ return child!==el })\r\n\t                }), selector)\r\n\t            },\r\n\t            empty: function(){\r\n\t                return this.each(function(){ this.innerHTML = '' })\r\n\t            },\r\n\t            // `pluck` is borrowed from Prototype.js\r\n\t            pluck: function(property){\r\n\t                return $.map(this, function(el){ return el[property] })\r\n\t            },\r\n\t            show: function(){\r\n\t                return this.each(function(){\r\n\t                    this.style.display == \"none\" && (this.style.display = '')\r\n\t                    if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\r\n\t                        this.style.display = defaultDisplay(this.nodeName)\r\n\t                })\r\n\t            },\r\n\t            replaceWith: function(newContent){\r\n\t                return this.before(newContent).remove()\r\n\t            },\r\n\t            wrap: function(structure){\r\n\t                var func = isFunction(structure)\r\n\t                if (this[0] && !func)\r\n\t                    var dom   = $(structure).get(0),\r\n\t                        clone = dom.parentNode || this.length > 1\r\n\t\r\n\t                return this.each(function(index){\r\n\t                    $(this).wrapAll(\r\n\t                        func ? structure.call(this, index) :\r\n\t                            clone ? dom.cloneNode(true) : dom\r\n\t                    )\r\n\t                })\r\n\t            },\r\n\t            wrapAll: function(structure){\r\n\t                if (this[0]) {\r\n\t                    $(this[0]).before(structure = $(structure))\r\n\t                    var children\r\n\t                    // drill down to the inmost element\r\n\t                    while ((children = structure.children()).length) structure = children.first()\r\n\t                    $(structure).append(this)\r\n\t                }\r\n\t                return this\r\n\t            },\r\n\t            wrapInner: function(structure){\r\n\t                var func = isFunction(structure)\r\n\t                return this.each(function(index){\r\n\t                    var self = $(this), contents = self.contents(),\r\n\t                        dom  = func ? structure.call(this, index) : structure\r\n\t                    contents.length ? contents.wrapAll(dom) : self.append(dom)\r\n\t                })\r\n\t            },\r\n\t            unwrap: function(){\r\n\t                this.parent().each(function(){\r\n\t                    $(this).replaceWith($(this).children())\r\n\t                })\r\n\t                return this\r\n\t            },\r\n\t            clone: function(){\r\n\t                return this.map(function(){ return this.cloneNode(true) })\r\n\t            },\r\n\t            hide: function(){\r\n\t                return this.css(\"display\", \"none\")\r\n\t            },\r\n\t            toggle: function(setting){\r\n\t                return this.each(function(){\r\n\t                    var el = $(this)\r\n\t                        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\r\n\t                })\r\n\t            },\r\n\t            prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\r\n\t            next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\r\n\t            html: function(html){\r\n\t                return 0 in arguments ?\r\n\t                    this.each(function(idx){\r\n\t                        var originHtml = this.innerHTML\r\n\t                        $(this).empty().append( funcArg(this, html, idx, originHtml) )\r\n\t                    }) :\r\n\t                    (0 in this ? this[0].innerHTML : null)\r\n\t            },\r\n\t            text: function(text){\r\n\t                return 0 in arguments ?\r\n\t                    this.each(function(idx){\r\n\t                        var newText = funcArg(this, text, idx, this.textContent)\r\n\t                        this.textContent = newText == null ? '' : ''+newText\r\n\t                    }) :\r\n\t                    (0 in this ? this.pluck('textContent').join(\"\") : null)\r\n\t            },\r\n\t            attr: function(name, value){\r\n\t                var result\r\n\t                return (typeof name == 'string' && !(1 in arguments)) ?\r\n\t                    (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\r\n\t                    this.each(function(idx){\r\n\t                        if (this.nodeType !== 1) return\r\n\t                        if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\r\n\t                        else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\r\n\t                    })\r\n\t            },\r\n\t            removeAttr: function(name){\r\n\t                return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\r\n\t                    setAttribute(this, attribute)\r\n\t                }, this)})\r\n\t            },\r\n\t            prop: function(name, value){\r\n\t                name = propMap[name] || name\r\n\t                return (1 in arguments) ?\r\n\t                    this.each(function(idx){\r\n\t                        this[name] = funcArg(this, value, idx, this[name])\r\n\t                    }) :\r\n\t                    (this[0] && this[0][name])\r\n\t            },\r\n\t            removeProp: function(name){\r\n\t                name = propMap[name] || name\r\n\t                return this.each(function(){ delete this[name] })\r\n\t            },\r\n\t            data: function(name, value){\r\n\t                var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\r\n\t\r\n\t                var data = (1 in arguments) ?\r\n\t                    this.attr(attrName, value) :\r\n\t                    this.attr(attrName)\r\n\t\r\n\t                return data !== null ? deserializeValue(data) : undefined\r\n\t            },\r\n\t            val: function(value){\r\n\t                if (0 in arguments) {\r\n\t                    if (value == null) value = \"\"\r\n\t                    return this.each(function(idx){\r\n\t                        this.value = funcArg(this, value, idx, this.value)\r\n\t                    })\r\n\t                } else {\r\n\t                    return this[0] && (this[0].multiple ?\r\n\t                            $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\r\n\t                            this[0].value)\r\n\t                }\r\n\t            },\r\n\t            offset: function(coordinates){\r\n\t                if (coordinates) return this.each(function(index){\r\n\t                    var $this = $(this),\r\n\t                        coords = funcArg(this, coordinates, index, $this.offset()),\r\n\t                        parentOffset = $this.offsetParent().offset(),\r\n\t                        props = {\r\n\t                            top:  coords.top  - parentOffset.top,\r\n\t                            left: coords.left - parentOffset.left\r\n\t                        }\r\n\t\r\n\t                    if ($this.css('position') == 'static') props['position'] = 'relative'\r\n\t                    $this.css(props)\r\n\t                })\r\n\t                if (!this.length) return null\r\n\t                if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\r\n\t                    return {top: 0, left: 0}\r\n\t                var obj = this[0].getBoundingClientRect()\r\n\t                return {\r\n\t                    left: obj.left + window.pageXOffset,\r\n\t                    top: obj.top + window.pageYOffset,\r\n\t                    width: Math.round(obj.width),\r\n\t                    height: Math.round(obj.height)\r\n\t                }\r\n\t            },\r\n\t            css: function(property, value){\r\n\t                if (arguments.length < 2) {\r\n\t                    var element = this[0]\r\n\t                    if (typeof property == 'string') {\r\n\t                        if (!element) return\r\n\t                        return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\r\n\t                    } else if (isArray(property)) {\r\n\t                        if (!element) return\r\n\t                        var props = {}\r\n\t                        var computedStyle = getComputedStyle(element, '')\r\n\t                        $.each(property, function(_, prop){\r\n\t                            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\r\n\t                        })\r\n\t                        return props\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                var css = ''\r\n\t                if (type(property) == 'string') {\r\n\t                    if (!value && value !== 0)\r\n\t                        this.each(function(){ this.style.removeProperty(dasherize(property)) })\r\n\t                    else\r\n\t                        css = dasherize(property) + \":\" + maybeAddPx(property, value)\r\n\t                } else {\r\n\t                    for (key in property)\r\n\t                        if (!property[key] && property[key] !== 0)\r\n\t                            this.each(function(){ this.style.removeProperty(dasherize(key)) })\r\n\t                        else\r\n\t                            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\r\n\t                }\r\n\t\r\n\t                return this.each(function(){ this.style.cssText += ';' + css })\r\n\t            },\r\n\t            index: function(element){\r\n\t                return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\r\n\t            },\r\n\t            hasClass: function(name){\r\n\t                if (!name) return false\r\n\t                return emptyArray.some.call(this, function(el){\r\n\t                    return this.test(className(el))\r\n\t                }, classRE(name))\r\n\t            },\r\n\t            addClass: function(name){\r\n\t                if (!name) return this\r\n\t                return this.each(function(idx){\r\n\t                    if (!('className' in this)) return\r\n\t                    classList = []\r\n\t                    var cls = className(this), newName = funcArg(this, name, idx, cls)\r\n\t                    newName.split(/\\s+/g).forEach(function(klass){\r\n\t                        if (!$(this).hasClass(klass)) classList.push(klass)\r\n\t                    }, this)\r\n\t                    classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\r\n\t                })\r\n\t            },\r\n\t            removeClass: function(name){\r\n\t                return this.each(function(idx){\r\n\t                    if (!('className' in this)) return\r\n\t                    if (name === undefined) return className(this, '')\r\n\t                    classList = className(this)\r\n\t                    funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\r\n\t                        classList = classList.replace(classRE(klass), \" \")\r\n\t                    })\r\n\t                    className(this, classList.trim())\r\n\t                })\r\n\t            },\r\n\t            toggleClass: function(name, when){\r\n\t                if (!name) return this\r\n\t                return this.each(function(idx){\r\n\t                    var $this = $(this), names = funcArg(this, name, idx, className(this))\r\n\t                    names.split(/\\s+/g).forEach(function(klass){\r\n\t                        (when === undefined ? !$this.hasClass(klass) : when) ?\r\n\t                            $this.addClass(klass) : $this.removeClass(klass)\r\n\t                    })\r\n\t                })\r\n\t            },\r\n\t            scrollTop: function(value){\r\n\t                if (!this.length) return\r\n\t                var hasScrollTop = 'scrollTop' in this[0]\r\n\t                if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\r\n\t                return this.each(hasScrollTop ?\r\n\t                    function(){ this.scrollTop = value } :\r\n\t                    function(){ this.scrollTo(this.scrollX, value) })\r\n\t            },\r\n\t            scrollLeft: function(value){\r\n\t                if (!this.length) return\r\n\t                var hasScrollLeft = 'scrollLeft' in this[0]\r\n\t                if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\r\n\t                return this.each(hasScrollLeft ?\r\n\t                    function(){ this.scrollLeft = value } :\r\n\t                    function(){ this.scrollTo(value, this.scrollY) })\r\n\t            },\r\n\t            position: function() {\r\n\t                if (!this.length) return\r\n\t\r\n\t                var elem = this[0],\r\n\t                    // Get *real* offsetParent\r\n\t                    offsetParent = this.offsetParent(),\r\n\t                    // Get correct offsets\r\n\t                    offset       = this.offset(),\r\n\t                    parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\r\n\t\r\n\t                // Subtract element margins\r\n\t                // note: when an element has margin: auto the offsetLeft and marginLeft\r\n\t                // are the same in Safari causing offset.left to incorrectly be 0\r\n\t                offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\r\n\t                offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\r\n\t\r\n\t                // Add offsetParent borders\r\n\t                parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\r\n\t                parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\r\n\t\r\n\t                // Subtract the two offsets\r\n\t                return {\r\n\t                    top:  offset.top  - parentOffset.top,\r\n\t                    left: offset.left - parentOffset.left\r\n\t                }\r\n\t            },\r\n\t            offsetParent: function() {\r\n\t                return this.map(function(){\r\n\t                    var parent = this.offsetParent || document.body\r\n\t                    while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\r\n\t                        parent = parent.offsetParent\r\n\t                    return parent\r\n\t                })\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // for now\r\n\t        $.fn.detach = $.fn.remove\r\n\t\r\n\t        // Generate the `width` and `height` functions\r\n\t        ;['width', 'height'].forEach(function(dimension){\r\n\t            var dimensionProperty =\r\n\t                dimension.replace(/./, function(m){ return m[0].toUpperCase() })\r\n\t\r\n\t            $.fn[dimension] = function(value){\r\n\t                var offset, el = this[0]\r\n\t                if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\r\n\t                    isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\r\n\t                    (offset = this.offset()) && offset[dimension]\r\n\t                else return this.each(function(idx){\r\n\t                    el = $(this)\r\n\t                    el.css(dimension, funcArg(this, value, idx, el[dimension]()))\r\n\t                })\r\n\t            }\r\n\t        })\r\n\t\r\n\t        function traverseNode(node, fun) {\r\n\t            fun(node)\r\n\t            for (var i = 0, len = node.childNodes.length; i < len; i++)\r\n\t                traverseNode(node.childNodes[i], fun)\r\n\t        }\r\n\t\r\n\t        // Generate the `after`, `prepend`, `before`, `append`,\r\n\t        // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\r\n\t        adjacencyOperators.forEach(function(operator, operatorIndex) {\r\n\t            var inside = operatorIndex % 2 //=> prepend, append\r\n\t\r\n\t            $.fn[operator] = function(){\r\n\t                // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\r\n\t                var argType, nodes = $.map(arguments, function(arg) {\r\n\t                        var arr = []\r\n\t                        argType = type(arg)\r\n\t                        if (argType == \"array\") {\r\n\t                            arg.forEach(function(el) {\r\n\t                                if (el.nodeType !== undefined) return arr.push(el)\r\n\t                                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\r\n\t                                arr = arr.concat(zepto.fragment(el))\r\n\t                            })\r\n\t                            return arr\r\n\t                        }\r\n\t                        return argType == \"object\" || arg == null ?\r\n\t                            arg : zepto.fragment(arg)\r\n\t                    }),\r\n\t                    parent, copyByClone = this.length > 1\r\n\t                if (nodes.length < 1) return this\r\n\t\r\n\t                return this.each(function(_, target){\r\n\t                    parent = inside ? target : target.parentNode\r\n\t\r\n\t                    // convert all methods to a \"before\" operation\r\n\t                    target = operatorIndex == 0 ? target.nextSibling :\r\n\t                        operatorIndex == 1 ? target.firstChild :\r\n\t                            operatorIndex == 2 ? target :\r\n\t                                null\r\n\t\r\n\t                    var parentInDocument = $.contains(document.documentElement, parent)\r\n\t\r\n\t                    nodes.forEach(function(node){\r\n\t                        if (copyByClone) node = node.cloneNode(true)\r\n\t                        else if (!parent) return $(node).remove()\r\n\t\r\n\t                        parent.insertBefore(node, target)\r\n\t                        if (parentInDocument) traverseNode(node, function(el){\r\n\t                            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\r\n\t                                (!el.type || el.type === 'text/javascript') && !el.src){\r\n\t                                var target = el.ownerDocument ? el.ownerDocument.defaultView : window\r\n\t                                target['eval'].call(target, el.innerHTML)\r\n\t                            }\r\n\t                        })\r\n\t                    })\r\n\t                })\r\n\t            }\r\n\t\r\n\t            // after    => insertAfter\r\n\t            // prepend  => prependTo\r\n\t            // before   => insertBefore\r\n\t            // append   => appendTo\r\n\t            $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\r\n\t                $(html)[operator](this)\r\n\t                return this\r\n\t            }\r\n\t        })\r\n\t\r\n\t        zepto.Z.prototype = Z.prototype = $.fn\r\n\t\r\n\t        // Export internal API functions in the `$.zepto` namespace\r\n\t        zepto.uniq = uniq\r\n\t        zepto.deserializeValue = deserializeValue\r\n\t        $.zepto = zepto\r\n\t\r\n\t        return $\r\n\t    })()\r\n\t\r\n\t    window.Zepto = Zepto\r\n\t    window.$ === undefined && (window.$ = Zepto)\r\n\t\r\n\t    ;(function($){\r\n\t        var _zid = 1, undefined,\r\n\t            slice = Array.prototype.slice,\r\n\t            isFunction = $.isFunction,\r\n\t            isString = function(obj){ return typeof obj == 'string' },\r\n\t            handlers = {},\r\n\t            specialEvents={},\r\n\t            focusinSupported = 'onfocusin' in window,\r\n\t            focus = { focus: 'focusin', blur: 'focusout' },\r\n\t            hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\r\n\t\r\n\t        specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\r\n\t\r\n\t        function zid(element) {\r\n\t            return element._zid || (element._zid = _zid++)\r\n\t        }\r\n\t        function findHandlers(element, event, fn, selector) {\r\n\t            event = parse(event)\r\n\t            if (event.ns) var matcher = matcherFor(event.ns)\r\n\t            return (handlers[zid(element)] || []).filter(function(handler) {\r\n\t                return handler\r\n\t                    && (!event.e  || handler.e == event.e)\r\n\t                    && (!event.ns || matcher.test(handler.ns))\r\n\t                    && (!fn       || zid(handler.fn) === zid(fn))\r\n\t                    && (!selector || handler.sel == selector)\r\n\t            })\r\n\t        }\r\n\t        function parse(event) {\r\n\t            var parts = ('' + event).split('.')\r\n\t            return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\r\n\t        }\r\n\t        function matcherFor(ns) {\r\n\t            return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\r\n\t        }\r\n\t\r\n\t        function eventCapture(handler, captureSetting) {\r\n\t            return handler.del &&\r\n\t                (!focusinSupported && (handler.e in focus)) ||\r\n\t                !!captureSetting\r\n\t        }\r\n\t\r\n\t        function realEvent(type) {\r\n\t            return hover[type] || (focusinSupported && focus[type]) || type\r\n\t        }\r\n\t\r\n\t        function add(element, events, fn, data, selector, delegator, capture){\r\n\t            var id = zid(element), set = (handlers[id] || (handlers[id] = []))\r\n\t            events.split(/\\s/).forEach(function(event){\r\n\t                if (event == 'ready') return $(document).ready(fn)\r\n\t                var handler   = parse(event)\r\n\t                handler.fn    = fn\r\n\t                handler.sel   = selector\r\n\t                // emulate mouseenter, mouseleave\r\n\t                if (handler.e in hover) fn = function(e){\r\n\t                    var related = e.relatedTarget\r\n\t                    if (!related || (related !== this && !$.contains(this, related)))\r\n\t                        return handler.fn.apply(this, arguments)\r\n\t                }\r\n\t                handler.del   = delegator\r\n\t                var callback  = delegator || fn\r\n\t                handler.proxy = function(e){\r\n\t                    e = compatible(e)\r\n\t                    if (e.isImmediatePropagationStopped()) return\r\n\t                    e.data = data\r\n\t                    var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\r\n\t                    if (result === false) e.preventDefault(), e.stopPropagation()\r\n\t                    return result\r\n\t                }\r\n\t                handler.i = set.length\r\n\t                set.push(handler)\r\n\t                if ('addEventListener' in element)\r\n\t                    element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\r\n\t            })\r\n\t        }\r\n\t        function remove(element, events, fn, selector, capture){\r\n\t            var id = zid(element)\r\n\t                ;(events || '').split(/\\s/).forEach(function(event){\r\n\t                findHandlers(element, event, fn, selector).forEach(function(handler){\r\n\t                    delete handlers[id][handler.i]\r\n\t                    if ('removeEventListener' in element)\r\n\t                        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\r\n\t                })\r\n\t            })\r\n\t        }\r\n\t\r\n\t        $.event = { add: add, remove: remove }\r\n\t\r\n\t        $.proxy = function(fn, context) {\r\n\t            var args = (2 in arguments) && slice.call(arguments, 2)\r\n\t            if (isFunction(fn)) {\r\n\t                var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\r\n\t                proxyFn._zid = zid(fn)\r\n\t                return proxyFn\r\n\t            } else if (isString(context)) {\r\n\t                if (args) {\r\n\t                    args.unshift(fn[context], fn)\r\n\t                    return $.proxy.apply(null, args)\r\n\t                } else {\r\n\t                    return $.proxy(fn[context], fn)\r\n\t                }\r\n\t            } else {\r\n\t                throw new TypeError(\"expected function\")\r\n\t            }\r\n\t        }\r\n\t\r\n\t        $.fn.bind = function(event, data, callback){\r\n\t            return this.on(event, data, callback)\r\n\t        }\r\n\t        $.fn.unbind = function(event, callback){\r\n\t            return this.off(event, callback)\r\n\t        }\r\n\t        $.fn.one = function(event, selector, data, callback){\r\n\t            return this.on(event, selector, data, callback, 1)\r\n\t        }\r\n\t\r\n\t        var returnTrue = function(){return true},\r\n\t            returnFalse = function(){return false},\r\n\t            ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\r\n\t            eventMethods = {\r\n\t                preventDefault: 'isDefaultPrevented',\r\n\t                stopImmediatePropagation: 'isImmediatePropagationStopped',\r\n\t                stopPropagation: 'isPropagationStopped'\r\n\t            }\r\n\t\r\n\t        function compatible(event, source) {\r\n\t            if (source || !event.isDefaultPrevented) {\r\n\t                source || (source = event)\r\n\t\r\n\t                $.each(eventMethods, function(name, predicate) {\r\n\t                    var sourceMethod = source[name]\r\n\t                    event[name] = function(){\r\n\t                        this[predicate] = returnTrue\r\n\t                        return sourceMethod && sourceMethod.apply(source, arguments)\r\n\t                    }\r\n\t                    event[predicate] = returnFalse\r\n\t                })\r\n\t\r\n\t                event.timeStamp || (event.timeStamp = Date.now())\r\n\t\r\n\t                if (source.defaultPrevented !== undefined ? source.defaultPrevented :\r\n\t                        'returnValue' in source ? source.returnValue === false :\r\n\t                        source.getPreventDefault && source.getPreventDefault())\r\n\t                    event.isDefaultPrevented = returnTrue\r\n\t            }\r\n\t            return event\r\n\t        }\r\n\t\r\n\t        function createProxy(event) {\r\n\t            var key, proxy = { originalEvent: event }\r\n\t            for (key in event)\r\n\t                if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\r\n\t\r\n\t            return compatible(proxy, event)\r\n\t        }\r\n\t\r\n\t        $.fn.delegate = function(selector, event, callback){\r\n\t            return this.on(event, selector, callback)\r\n\t        }\r\n\t        $.fn.undelegate = function(selector, event, callback){\r\n\t            return this.off(event, selector, callback)\r\n\t        }\r\n\t\r\n\t        $.fn.live = function(event, callback){\r\n\t            $(document.body).delegate(this.selector, event, callback)\r\n\t            return this\r\n\t        }\r\n\t        $.fn.die = function(event, callback){\r\n\t            $(document.body).undelegate(this.selector, event, callback)\r\n\t            return this\r\n\t        }\r\n\t\r\n\t        $.fn.on = function(event, selector, data, callback, one){\r\n\t            var autoRemove, delegator, $this = this\r\n\t            if (event && !isString(event)) {\r\n\t                $.each(event, function(type, fn){\r\n\t                    $this.on(type, selector, data, fn, one)\r\n\t                })\r\n\t                return $this\r\n\t            }\r\n\t\r\n\t            if (!isString(selector) && !isFunction(callback) && callback !== false)\r\n\t                callback = data, data = selector, selector = undefined\r\n\t            if (callback === undefined || data === false)\r\n\t                callback = data, data = undefined\r\n\t\r\n\t            if (callback === false) callback = returnFalse\r\n\t\r\n\t            return $this.each(function(_, element){\r\n\t                if (one) autoRemove = function(e){\r\n\t                    remove(element, e.type, callback)\r\n\t                    return callback.apply(this, arguments)\r\n\t                }\r\n\t\r\n\t                if (selector) delegator = function(e){\r\n\t                    var evt, match = $(e.target).closest(selector, element).get(0)\r\n\t                    if (match && match !== element) {\r\n\t                        evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\r\n\t                        return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\r\n\t                    }\r\n\t                }\r\n\t\r\n\t                add(element, event, callback, data, selector, delegator || autoRemove)\r\n\t            })\r\n\t        }\r\n\t        $.fn.off = function(event, selector, callback){\r\n\t            var $this = this\r\n\t            if (event && !isString(event)) {\r\n\t                $.each(event, function(type, fn){\r\n\t                    $this.off(type, selector, fn)\r\n\t                })\r\n\t                return $this\r\n\t            }\r\n\t\r\n\t            if (!isString(selector) && !isFunction(callback) && callback !== false)\r\n\t                callback = selector, selector = undefined\r\n\t\r\n\t            if (callback === false) callback = returnFalse\r\n\t\r\n\t            return $this.each(function(){\r\n\t                remove(this, event, callback, selector)\r\n\t            })\r\n\t        }\r\n\t\r\n\t        $.fn.trigger = function(event, args){\r\n\t            event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\r\n\t            event._args = args\r\n\t            return this.each(function(){\r\n\t                // handle focus(), blur() by calling them directly\r\n\t                if (event.type in focus && typeof this[event.type] == \"function\") this[event.type]()\r\n\t                // items in the collection might not be DOM elements\r\n\t                else if ('dispatchEvent' in this) this.dispatchEvent(event)\r\n\t                else $(this).triggerHandler(event, args)\r\n\t            })\r\n\t        }\r\n\t\r\n\t        // triggers event handlers on current element just as if an event occurred,\r\n\t        // doesn't trigger an actual event, doesn't bubble\r\n\t        $.fn.triggerHandler = function(event, args){\r\n\t            var e, result\r\n\t            this.each(function(i, element){\r\n\t                e = createProxy(isString(event) ? $.Event(event) : event)\r\n\t                e._args = args\r\n\t                e.target = element\r\n\t                $.each(findHandlers(element, event.type || event), function(i, handler){\r\n\t                    result = handler.proxy(e)\r\n\t                    if (e.isImmediatePropagationStopped()) return false\r\n\t                })\r\n\t            })\r\n\t            return result\r\n\t        }\r\n\t\r\n\t        // shortcut methods for `.bind(event, fn)` for each event type\r\n\t        ;('focusin focusout focus blur load resize scroll unload click dblclick '+\r\n\t        'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\r\n\t        'change select keydown keypress keyup error').split(' ').forEach(function(event) {\r\n\t            $.fn[event] = function(callback) {\r\n\t                return (0 in arguments) ?\r\n\t                    this.bind(event, callback) :\r\n\t                    this.trigger(event)\r\n\t            }\r\n\t        })\r\n\t\r\n\t        $.Event = function(type, props) {\r\n\t            if (!isString(type)) props = type, type = props.type\r\n\t            var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\r\n\t            if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\r\n\t            event.initEvent(type, bubbles, true)\r\n\t            return compatible(event)\r\n\t        }\r\n\t\r\n\t    })(Zepto)\r\n\t\r\n\t    ;(function($){\r\n\t        var jsonpID = +new Date(),\r\n\t            document = window.document,\r\n\t            key,\r\n\t            name,\r\n\t            rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\r\n\t            scriptTypeRE = /^(?:text|application)\\/javascript/i,\r\n\t            xmlTypeRE = /^(?:text|application)\\/xml/i,\r\n\t            jsonType = 'application/json',\r\n\t            htmlType = 'text/html',\r\n\t            blankRE = /^\\s*$/,\r\n\t            originAnchor = document.createElement('a')\r\n\t\r\n\t        originAnchor.href = window.location.href\r\n\t\r\n\t        // trigger a custom event and return false if it was cancelled\r\n\t        function triggerAndReturn(context, eventName, data) {\r\n\t            var event = $.Event(eventName)\r\n\t            $(context).trigger(event, data)\r\n\t            return !event.isDefaultPrevented()\r\n\t        }\r\n\t\r\n\t        // trigger an Ajax \"global\" event\r\n\t        function triggerGlobal(settings, context, eventName, data) {\r\n\t            if (settings.global) return triggerAndReturn(context || document, eventName, data)\r\n\t        }\r\n\t\r\n\t        // Number of active Ajax requests\r\n\t        $.active = 0\r\n\t\r\n\t        function ajaxStart(settings) {\r\n\t            if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\r\n\t        }\r\n\t        function ajaxStop(settings) {\r\n\t            if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\r\n\t        }\r\n\t\r\n\t        // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\r\n\t        function ajaxBeforeSend(xhr, settings) {\r\n\t            var context = settings.context\r\n\t            if (settings.beforeSend.call(context, xhr, settings) === false ||\r\n\t                triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\r\n\t                return false\r\n\t\r\n\t            triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\r\n\t        }\r\n\t        function ajaxSuccess(data, xhr, settings, deferred) {\r\n\t            var context = settings.context, status = 'success'\r\n\t            settings.success.call(context, data, status, xhr)\r\n\t            if (deferred) deferred.resolveWith(context, [data, status, xhr])\r\n\t            triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\r\n\t            ajaxComplete(status, xhr, settings)\r\n\t        }\r\n\t        // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\r\n\t        function ajaxError(error, type, xhr, settings, deferred) {\r\n\t            var context = settings.context\r\n\t            settings.error.call(context, xhr, type, error)\r\n\t            if (deferred) deferred.rejectWith(context, [xhr, type, error])\r\n\t            triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\r\n\t            ajaxComplete(type, xhr, settings)\r\n\t        }\r\n\t        // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\r\n\t        function ajaxComplete(status, xhr, settings) {\r\n\t            var context = settings.context\r\n\t            settings.complete.call(context, xhr, status)\r\n\t            triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\r\n\t            ajaxStop(settings)\r\n\t        }\r\n\t\r\n\t        function ajaxDataFilter(data, type, settings) {\r\n\t            if (settings.dataFilter == empty) return data\r\n\t            var context = settings.context\r\n\t            return settings.dataFilter.call(context, data, type)\r\n\t        }\r\n\t\r\n\t        // Empty function, used as default callback\r\n\t        function empty() {}\r\n\t\r\n\t        $.ajaxJSONP = function(options, deferred){\r\n\t            if (!('type' in options)) return $.ajax(options)\r\n\t\r\n\t            var _callbackName = options.jsonpCallback,\r\n\t                callbackName = ($.isFunction(_callbackName) ?\r\n\t                        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\r\n\t                script = document.createElement('script'),\r\n\t                originalCallback = window[callbackName],\r\n\t                responseData,\r\n\t                abort = function(errorType) {\r\n\t                    $(script).triggerHandler('error', errorType || 'abort')\r\n\t                },\r\n\t                xhr = { abort: abort }, abortTimeout\r\n\t\r\n\t            if (deferred) deferred.promise(xhr)\r\n\t\r\n\t            $(script).on('load error', function(e, errorType){\r\n\t                clearTimeout(abortTimeout)\r\n\t                $(script).off().remove()\r\n\t\r\n\t                if (e.type == 'error' || !responseData) {\r\n\t                    ajaxError(null, errorType || 'error', xhr, options, deferred)\r\n\t                } else {\r\n\t                    ajaxSuccess(responseData[0], xhr, options, deferred)\r\n\t                }\r\n\t\r\n\t                window[callbackName] = originalCallback\r\n\t                if (responseData && $.isFunction(originalCallback))\r\n\t                    originalCallback(responseData[0])\r\n\t\r\n\t                originalCallback = responseData = undefined\r\n\t            })\r\n\t\r\n\t            if (ajaxBeforeSend(xhr, options) === false) {\r\n\t                abort('abort')\r\n\t                return xhr\r\n\t            }\r\n\t\r\n\t            window[callbackName] = function(){\r\n\t                responseData = arguments\r\n\t            }\r\n\t\r\n\t            script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName)\r\n\t            document.head.appendChild(script)\r\n\t\r\n\t            if (options.timeout > 0) abortTimeout = setTimeout(function(){\r\n\t                abort('timeout')\r\n\t            }, options.timeout)\r\n\t\r\n\t            return xhr\r\n\t        }\r\n\t\r\n\t        $.ajaxSettings = {\r\n\t            // Default type of request\r\n\t            type: 'GET',\r\n\t            // Callback that is executed before request\r\n\t            beforeSend: empty,\r\n\t            // Callback that is executed if the request succeeds\r\n\t            success: empty,\r\n\t            // Callback that is executed the the server drops error\r\n\t            error: empty,\r\n\t            // Callback that is executed on request complete (both: error and success)\r\n\t            complete: empty,\r\n\t            // The context for the callbacks\r\n\t            context: null,\r\n\t            // Whether to trigger \"global\" Ajax events\r\n\t            global: true,\r\n\t            // Transport\r\n\t            xhr: function () {\r\n\t                return new window.XMLHttpRequest()\r\n\t            },\r\n\t            // MIME types mapping\r\n\t            // IIS returns Javascript as \"application/x-javascript\"\r\n\t            accepts: {\r\n\t                script: 'text/javascript, application/javascript, application/x-javascript',\r\n\t                json:   jsonType,\r\n\t                xml:    'application/xml, text/xml',\r\n\t                html:   htmlType,\r\n\t                text:   'text/plain'\r\n\t            },\r\n\t            // Whether the request is to another domain\r\n\t            crossDomain: false,\r\n\t            // Default timeout\r\n\t            timeout: 0,\r\n\t            // Whether data should be serialized to string\r\n\t            processData: true,\r\n\t            // Whether the browser should be allowed to cache GET responses\r\n\t            cache: true,\r\n\t            //Used to handle the raw response data of XMLHttpRequest.\r\n\t            //This is a pre-filtering function to sanitize the response.\r\n\t            //The sanitized response should be returned\r\n\t            dataFilter: empty\r\n\t        }\r\n\t\r\n\t        function mimeToDataType(mime) {\r\n\t            if (mime) mime = mime.split(';', 2)[0]\r\n\t            return mime && ( mime == htmlType ? 'html' :\r\n\t                    mime == jsonType ? 'json' :\r\n\t                        scriptTypeRE.test(mime) ? 'script' :\r\n\t                        xmlTypeRE.test(mime) && 'xml' ) || 'text'\r\n\t        }\r\n\t\r\n\t        function appendQuery(url, query) {\r\n\t            if (query == '') return url\r\n\t            return (url + '&' + query).replace(/[&?]{1,2}/, '?')\r\n\t        }\r\n\t\r\n\t        // serialize payload and append it to the URL for GET requests\r\n\t        function serializeData(options) {\r\n\t            if (options.processData && options.data && $.type(options.data) != \"string\")\r\n\t                options.data = $.param(options.data, options.traditional)\r\n\t            if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\r\n\t                options.url = appendQuery(options.url, options.data), options.data = undefined\r\n\t        }\r\n\t\r\n\t        $.ajax = function(options){\r\n\t            var settings = $.extend({}, options || {}),\r\n\t                deferred = $.Deferred && $.Deferred(),\r\n\t                urlAnchor, hashIndex\r\n\t            for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\r\n\t\r\n\t            ajaxStart(settings)\r\n\t\r\n\t            if (!settings.crossDomain) {\r\n\t                urlAnchor = document.createElement('a')\r\n\t                urlAnchor.href = settings.url\r\n\t                // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\r\n\t                urlAnchor.href = urlAnchor.href\r\n\t                settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\r\n\t            }\r\n\t\r\n\t            if (!settings.url) settings.url = window.location.toString()\r\n\t            if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\r\n\t            serializeData(settings)\r\n\t\r\n\t            var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url)\r\n\t            if (hasPlaceholder) dataType = 'jsonp'\r\n\t\r\n\t            if (settings.cache === false || (\r\n\t                    (!options || options.cache !== true) &&\r\n\t                    ('script' == dataType || 'jsonp' == dataType)\r\n\t                ))\r\n\t                settings.url = appendQuery(settings.url, '_=' + Date.now())\r\n\t\r\n\t            if ('jsonp' == dataType) {\r\n\t                if (!hasPlaceholder)\r\n\t                    settings.url = appendQuery(settings.url,\r\n\t                        settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\r\n\t                return $.ajaxJSONP(settings, deferred)\r\n\t            }\r\n\t\r\n\t            var mime = settings.accepts[dataType],\r\n\t                headers = { },\r\n\t                setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\r\n\t                protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\r\n\t                xhr = settings.xhr(),\r\n\t                nativeSetHeader = xhr.setRequestHeader,\r\n\t                abortTimeout\r\n\t\r\n\t            if (deferred) deferred.promise(xhr)\r\n\t\r\n\t            if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\r\n\t            setHeader('Accept', mime || '*/*')\r\n\t            if (mime = settings.mimeType || mime) {\r\n\t                if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\r\n\t                xhr.overrideMimeType && xhr.overrideMimeType(mime)\r\n\t            }\r\n\t            if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\r\n\t                setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\r\n\t\r\n\t            if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\r\n\t            xhr.setRequestHeader = setHeader\r\n\t\r\n\t            xhr.onreadystatechange = function(){\r\n\t                if (xhr.readyState == 4) {\r\n\t                    xhr.onreadystatechange = empty\r\n\t                    clearTimeout(abortTimeout)\r\n\t                    var result, error = false\r\n\t                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\r\n\t                        dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\r\n\t\r\n\t                        if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\r\n\t                            result = xhr.response\r\n\t                        else {\r\n\t                            result = xhr.responseText\r\n\t\r\n\t                            try {\r\n\t                                // http://perfectionkills.com/global-eval-what-are-the-options/\r\n\t                                // sanitize response accordingly if data filter callback provided\r\n\t                                result = ajaxDataFilter(result, dataType, settings)\r\n\t                                if (dataType == 'script')    (1,eval)(result)\r\n\t                                else if (dataType == 'xml')  result = xhr.responseXML\r\n\t                                else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\r\n\t                            } catch (e) { error = e }\r\n\t\r\n\t                            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\r\n\t                        }\r\n\t\r\n\t                        ajaxSuccess(result, xhr, settings, deferred)\r\n\t                    } else {\r\n\t                        ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t\r\n\t            if (ajaxBeforeSend(xhr, settings) === false) {\r\n\t                xhr.abort()\r\n\t                ajaxError(null, 'abort', xhr, settings, deferred)\r\n\t                return xhr\r\n\t            }\r\n\t\r\n\t            var async = 'async' in settings ? settings.async : true\r\n\t            xhr.open(settings.type, settings.url, async, settings.username, settings.password)\r\n\t\r\n\t            if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\r\n\t\r\n\t            for (name in headers) nativeSetHeader.apply(xhr, headers[name])\r\n\t\r\n\t            if (settings.timeout > 0) abortTimeout = setTimeout(function(){\r\n\t                xhr.onreadystatechange = empty\r\n\t                xhr.abort()\r\n\t                ajaxError(null, 'timeout', xhr, settings, deferred)\r\n\t            }, settings.timeout)\r\n\t\r\n\t            // avoid sending empty string (#319)\r\n\t            xhr.send(settings.data ? settings.data : null)\r\n\t            return xhr\r\n\t        }\r\n\t\r\n\t        // handle optional data/success arguments\r\n\t        function parseArguments(url, data, success, dataType) {\r\n\t            if ($.isFunction(data)) dataType = success, success = data, data = undefined\r\n\t            if (!$.isFunction(success)) dataType = success, success = undefined\r\n\t            return {\r\n\t                url: url\r\n\t                , data: data\r\n\t                , success: success\r\n\t                , dataType: dataType\r\n\t            }\r\n\t        }\r\n\t\r\n\t        $.get = function(/* url, data, success, dataType */){\r\n\t            return $.ajax(parseArguments.apply(null, arguments))\r\n\t        }\r\n\t\r\n\t        $.post = function(/* url, data, success, dataType */){\r\n\t            var options = parseArguments.apply(null, arguments)\r\n\t            options.type = 'POST'\r\n\t            return $.ajax(options)\r\n\t        }\r\n\t\r\n\t        $.getJSON = function(/* url, data, success */){\r\n\t            var options = parseArguments.apply(null, arguments)\r\n\t            options.dataType = 'json'\r\n\t            return $.ajax(options)\r\n\t        }\r\n\t\r\n\t        $.fn.load = function(url, data, success){\r\n\t            if (!this.length) return this\r\n\t            var self = this, parts = url.split(/\\s/), selector,\r\n\t                options = parseArguments(url, data, success),\r\n\t                callback = options.success\r\n\t            if (parts.length > 1) options.url = parts[0], selector = parts[1]\r\n\t            options.success = function(response){\r\n\t                self.html(selector ?\r\n\t                    $('<div>').html(response.replace(rscript, \"\")).find(selector)\r\n\t                    : response)\r\n\t                callback && callback.apply(self, arguments)\r\n\t            }\r\n\t            $.ajax(options)\r\n\t            return this\r\n\t        }\r\n\t\r\n\t        var escape = encodeURIComponent\r\n\t\r\n\t        function serialize(params, obj, traditional, scope){\r\n\t            var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\r\n\t            $.each(obj, function(key, value) {\r\n\t                type = $.type(value)\r\n\t                if (scope) key = traditional ? scope :\r\n\t                scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\r\n\t                // handle data in serializeArray() format\r\n\t                if (!scope && array) params.add(value.name, value.value)\r\n\t                // recurse into nested objects\r\n\t                else if (type == \"array\" || (!traditional && type == \"object\"))\r\n\t                    serialize(params, value, traditional, key)\r\n\t                else params.add(key, value)\r\n\t            })\r\n\t        }\r\n\t\r\n\t        $.param = function(obj, traditional){\r\n\t            var params = []\r\n\t            params.add = function(key, value) {\r\n\t                if ($.isFunction(value)) value = value()\r\n\t                if (value == null) value = \"\"\r\n\t                this.push(escape(key) + '=' + escape(value))\r\n\t            }\r\n\t            serialize(params, obj, traditional)\r\n\t            return params.join('&').replace(/%20/g, '+')\r\n\t        }\r\n\t    })(Zepto)\r\n\t\r\n\t    ;(function($){\r\n\t        $.fn.serializeArray = function() {\r\n\t            var name, type, result = [],\r\n\t                add = function(value) {\r\n\t                    if (value.forEach) return value.forEach(add)\r\n\t                    result.push({ name: name, value: value })\r\n\t                }\r\n\t            if (this[0]) $.each(this[0].elements, function(_, field){\r\n\t                type = field.type, name = field.name\r\n\t                if (name && field.nodeName.toLowerCase() != 'fieldset' &&\r\n\t                    !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\r\n\t                    ((type != 'radio' && type != 'checkbox') || field.checked))\r\n\t                    add($(field).val())\r\n\t            })\r\n\t            return result\r\n\t        }\r\n\t\r\n\t        $.fn.serialize = function(){\r\n\t            var result = []\r\n\t            this.serializeArray().forEach(function(elm){\r\n\t                result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\r\n\t            })\r\n\t            return result.join('&')\r\n\t        }\r\n\t\r\n\t        $.fn.submit = function(callback) {\r\n\t            if (0 in arguments) this.bind('submit', callback)\r\n\t            else if (this.length) {\r\n\t                var event = $.Event('submit')\r\n\t                this.eq(0).trigger(event)\r\n\t                if (!event.isDefaultPrevented()) this.get(0).submit()\r\n\t            }\r\n\t            return this\r\n\t        }\r\n\t\r\n\t    })(Zepto)\r\n\t\r\n\t    ;(function(){\r\n\t        // getComputedStyle shouldn't freak out when called\r\n\t        // without a valid element as argument\r\n\t        try {\r\n\t            getComputedStyle(undefined)\r\n\t        } catch(e) {\r\n\t            var nativeGetComputedStyle = getComputedStyle\r\n\t            window.getComputedStyle = function(element, pseudoElement){\r\n\t                try {\r\n\t                    return nativeGetComputedStyle(element, pseudoElement)\r\n\t                } catch(e) {\r\n\t                    return null\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    })()\r\n\t    return Zepto\r\n\t}))\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(12);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(13);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(14);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(5)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\t var Util = __webpack_require__(1);\n\t\n\t function Boundry(cfg) {\n\t     this.cfg = Util.mix({\n\t         width: 0,\n\t         height: 0\n\t     }, cfg)\n\t     this.init();\n\t }\n\t Util.mix(Boundry.prototype, {\n\t     init: function() {\n\t         var self = this;\n\t         self._xtop = 0;\n\t         self._xright = 0;\n\t         self._xleft = 0;\n\t         self._xbottom = 0;\n\t         self.refresh({\n\t             width: self.cfg.width,\n\t             height: self.cfg.height\n\t         });\n\t     },\n\t     reset: function() {\n\t         this.resetTop();\n\t         this.resetLeft();\n\t         this.resetBottom();\n\t         this.resetRight();\n\t         return this;\n\t     },\n\t     resetTop: function() {\n\t         this._xtop = 0;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     resetLeft: function() {\n\t         this._xleft = 0;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     resetBottom: function() {\n\t         this._xbottom = 0;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     resetRight: function() {\n\t         this._xright = 0;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     expandTop: function(top) {\n\t         this._xtop = top;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     expandLeft: function(left) {\n\t         this._xleft = left;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     expandRight: function(right) {\n\t         this._xright = right;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     expandBottom: function(bottom) {\n\t         this._xbottom = bottom;\n\t         this.refresh();\n\t         return this;\n\t     },\n\t     refresh: function(cfg) {\n\t         Util.mix(this.cfg, cfg);\n\t         this.top = this._xtop;\n\t         this.left = this._xleft;\n\t         this.bottom = (cfg && cfg.height || this.cfg.height || 0) - this._xbottom;\n\t         this.right = (cfg && cfg.width || this.cfg.width || 0) - this._xright;\n\t         this.width = this.right - this.left > 0 ? this.right - this.left : 0;\n\t         this.height = this.bottom - this.top > 0 ? this.bottom - this.top : 0;\n\t         return this;\n\t     }\n\t });\n\t\n\t\n\t if (typeof module == 'object' && module.exports) {\n\t     module.exports = Boundry;\n\t }\n\t /** ignored by jsdoc **/\n\t else{\n\t    return Boundry;\n\t }\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t/*\n\t\twrapped scroll controller\n\t*/\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t\tBase = __webpack_require__(2);\n\t\n\tvar Controller = function(cfg) {\n\t\tController.superclass.constructor.call(this, cfg);\n\t\tthis.userConfig = Util.mix({}, cfg);\n\t\tthis.init();\n\t}\n\t\n\tUtil.extend(Controller, Base, {\n\t\tinit: function() {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = self.userConfig.xscroll;\n\t\t},\n\t\tadd: function(scroll, cfg) {\n\t\t\tvar self = this;\n\t\t\tcfg = Util.extend({\n\t\t\t\tcaptureBounce: false,\n\t\t\t\tstopPropagation: true\n\t\t\t}, cfg)\n\t\t\tif (!self.__scrolls) {\n\t\t\t\tself.__scrolls = {};\n\t\t\t}\n\t\t\tif (scroll.guid && !self.__scrolls[scroll.guid]) {\n\t\t\t\tscroll.parentscroll = self.xscroll;\n\t\t\t\tself._bind(scroll);\n\t\t\t\treturn self.__scrolls[scroll.guid] = scroll;\n\t\t\t}\n\t\t\treturn;\n\t\t},\n\t\tremove: function(scroll) {\n\t\t\tvar self = this;\n\t\t\tif (!scroll || !scroll.guid) return;\n\t\t\tvar subscroll = self.__scrolls[scroll.guid];\n\t\t\tif (subscroll) {\n\t\t\t\tsubscroll.parentscroll = null;\n\t\t\t\tself._unbind(scroll);\n\t\t\t\tsubscroll = null;\n\t\t\t}\n\t\t},\n\t\tget: function(guid) {\n\t\t\tif (guid) {\n\t\t\t\treturn this.__scrolls[guid];\n\t\t\t}\n\t\t\treturn this.__scrolls;\n\t\t},\n\t\n\t\t_unbind: function(sub) {\n\t\n\t\t},\n\t\n\t\t_bind: function(sub) {\n\t\t\tvar self = this,\n\t\t\t\txscroll = self.xscroll;\n\t\t\txscroll.renderTo.addEventListener(\"touchstart\", function() {\n\t\t\t\txscroll._resetLockConfig();\n\t\t\t});\n\t\t\tsub.renderTo.addEventListener(\"touchstart\", function() {\n\t\t\t\tsub._resetLockConfig();\n\t\t\t});\n\t\t\txscroll.on(\"panend\", xscroll._resetLockConfig);\n\t\t\tsub.on(\"panend\", sub._resetLockConfig);\n\t\t\tsub.on(\"panstart\", function(e) {\n\t\t\t\t//vertical scroll enabled\n\t\t\t\tif (!sub.userConfig.lockY && !xscroll.userConfig.lockY) {\n\t\t\t\t\t//outside of boundry\n\t\t\t\t\tif (sub.isBoundryOut()) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.direction == 16 && sub.getBoundryOutTop() >= 0) {\n\t\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t\t} else if (e.direction == 8 && sub.getBoundryOutTop() >= 0 && sub.getBoundryOutBottom() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.direction == 8 && sub.getBoundryOutBottom() >= 0) {\n\t\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t\t} else if (e.direction == 16 && sub.getBoundryOutBottom() >= 0 && sub.getBoundryOutTop() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (sub.getBoundryOutTop() < 0 && sub.getBoundryOutBottom() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//horizontal scroll enabled\n\t\t\t\tif (!sub.userConfig.lockX && !xscroll.userConfig.lockX) {\n\t\t\t\t\tif (sub.isBoundryOut()) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.direction == 4 && sub.getBoundryOutLeft() >= 0) {\n\t\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t\t} else if (e.direction == 2 && sub.getBoundryOutLeft() >= 0 && sub.getBoundryOutRight() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (e.direction == 2 && sub.getBoundryOutRight() >= 0) {\n\t\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t\t} else if (e.direction == 4 && sub.getBoundryOutRight() >= 0 && sub.getBoundryOutLeft() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (sub.getBoundryOutLeft() < 0 && sub.getBoundryOutRight() < 0) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!sub.userConfig.lockX && xscroll.userConfig.lockX) {\n\t\t\t\t\t//pan x\n\t\t\t\t\tif (e.direction == 2 || e.direction == 4) {\n\t\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!sub.userConfig.lockY && xscroll.userConfig.lockY) {\n\t\t\t\t\t//pan y\n\t\t\t\t\tif (e.direction == 8 || e.direction == 16) {\n\t\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Controller;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn Controller;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\tvar transform = Util.prefixStyle(\"transform\");\n\t\n\tvar Fixed = function(cfg) {\n\t  Fixed.superclass.constructor.call(this, cfg);\n\t  this.userConfig = Util.mix({\n\t    fixedRenderTo: undefined,\n\t    fixedElements: \".xs-fixed\",\n\t    prefix: \"xs-fixed-container\",\n\t    zoomType: \"y\"\n\t  }, cfg);\n\t  this.init();\n\t}\n\t\n\tUtil.extend(Fixed, Base, {\n\t  fixedElements: [],\n\t  init: function() {\n\t    var self = this,\n\t      userConfig = self.userConfig,\n\t      xscroll = self.xscroll = userConfig.xscroll,\n\t      xscrollConfig = self.xscrollConfig = xscroll.userConfig;\n\t    self.isY = !!(userConfig.zoomType == \"y\");\n\t    self._ = self.isY ? {\n\t      top: \"top\",\n\t      height: \"height\",\n\t      width: \"width\",\n\t      offsetTop:\"offsetTop\"\n\t    } : {\n\t      top: \"left\",\n\t      height: \"width\",\n\t      width: \"height\",\n\t      offsetTop:\"offsetLeft\"\n\t    };\n\t    self.fixedRenderTo = Util.getNode(userConfig.fixedRenderTo);\n\t    return self;\n\t  },\n\t  render: function() {\n\t    var self = this;\n\t    var xscroll = self.xscroll;\n\t    self.infinite = xscroll.getPlugin(\"infinite\");\n\t    if (!self.fixedRenderTo) {\n\t      self.fixedRenderTo = document.createElement('div');\n\t      xscroll.renderTo.appendChild(self.fixedRenderTo);\n\t    }\n\t    Util.addClass(self.fixedRenderTo, self.userConfig.prefix);\n\t    var originalFixedElements = self.originalFixedElements = self.getFixedElements();\n\t    for (var i = 0, l = originalFixedElements.length; i < l; i++) {\n\t      self.renderFixedElement(originalFixedElements[i], i,self.fixedRenderTo);\n\t    }\n\t    return self;\n\t  },\n\t  getFixedElements: function() {\n\t    var self = this;\n\t    var infinite = self.infinite;\n\t    var userConfig = self.userConfig;\n\t    if (infinite) {\n\t      var els = [];\n\t      for (var i in infinite.__serializedData) {\n\t        var data = infinite.__serializedData[i];\n\t        if (data && data.style && data.style.position == \"fixed\") {\n\t          els.push(data);\n\t        }\n\t      }\n\t      return els;\n\t    } else {\n\t      return Util.getNodes(userConfig.fixedElements, self.xscroll.content);\n\t    }\n\t  },\n\t  renderFixedElement: function(el, fixedIndex,fixedRenderTo) {\n\t    var self = this;\n\t    var isRender = true;\n\t    var _ = self._;\n\t    var xscroll = self.xscroll;\n\t    var userConfig = self.userConfig;\n\t    var xscrollConfig = self.xscrollConfig;\n\t    var useOriginScroll = xscrollConfig.useOriginScroll;\n\t    var infinite = self.infinite;\n\t    var fixedElement = self.fixedElements[fixedIndex];\n\t    if (!self.fixedElements[fixedIndex]) {\n\t      isRender = false;\n\t      if (useOriginScroll && !infinite) {\n\t        //use original position:fixed stylesheet\n\t        el.style.position = \"fixed\";\n\t        el.style.display = \"block\";\n\t      } else {\n\t        //deep clone fixed nodes and hide original nodes\n\t        fixedElement = document.createElement(\"div\");\n\t        if (infinite) {\n\t          fixedElement.setAttribute(\"style\", Util.stringifyStyle(Util.mix(el.style, {\n\t            display: \"block\",\n\t            width: \"100%\"\n\t          })));\n\t          fixedElement.style[_.top] = (el.style[_.top] >= 0 ? el.style[_.top] : el._top) + \"px\";\n\t          if (el.style[_.height]) {\n\t            fixedElement.style[_.height] = el.style[_.height] + \"px\";\n\t          }\n\t          infinite.userConfig.renderHook.call(self, fixedElement, el);\n\t        } else {\n\t          fixedElement.style.display = \"block\";\n\t          fixedElement.style.position = \"absolute\";\n\t          fixedElement.style[_.width] = \"100%\";\n\t          fixedElement.innerHTML = el.innerHTML;\n\t          fixedElement.className = el.className;\n\t          fixedElement.setAttribute(\"style\", el.getAttribute(\"style\"));\n\t          fixedElement.style[_.top] = el[_.offsetTop] + \"px\";\n\t          el.style.display = \"none\";\n\t        }\n\t        fixedRenderTo.appendChild(fixedElement);\n\t        self.fixedElements.push(fixedElement);\n\t      }\n\t    }\n\t    xscroll.trigger(\"fixedchange\", {\n\t      fixedIndex: fixedIndex,\n\t      fixedElement: useOriginScroll ? el : fixedElement,\n\t      originalFixedElement: el,\n\t      isRender: isRender\n\t    });\n\t  },\n\t  destroy: function() {\n\t    var self = this;\n\t    self.fixedElements = undefined;\n\t  }\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t  module.exports = Fixed;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t  return Fixed;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Animate = __webpack_require__(3);\n\tvar MAX_BOUNCE_DISTANCE = 40;\n\tvar MIN_BAR_SCROLLED_SIZE = 10;\n\tvar MIN_BAR_SIZE = 50;\n\tvar transform = Util.prefixStyle(\"transform\");\n\tvar transformStr = Util.vendor ? [\"-\", Util.vendor, \"-transform\"].join(\"\") : \"transform\";\n\tvar transition = Util.prefixStyle(\"transition\");\n\tvar borderRadius = Util.prefixStyle(\"borderRadius\");\n\tvar transitionDuration = Util.prefixStyle(\"transitionDuration\");\n\t\n\tvar ScrollBar = function(cfg) {\n\t\tthis.userConfig = Util.mix({\n\t\t\tMIN_BAR_SCROLLED_SIZE:MIN_BAR_SCROLLED_SIZE,\n\t\t\tMIN_BAR_SIZE:MIN_BAR_SIZE,\n\t\t\tMAX_BOUNCE_DISTANCE:MAX_BOUNCE_DISTANCE,\n\t\t\tspacing:5\n\t\t}, cfg);\n\t\tthis.init(cfg.xscroll);\n\t}\n\t\n\tUtil.mix(ScrollBar.prototype, {\n\t\tinit: function(xscroll) {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = xscroll;\n\t\t\tself.type = self.userConfig.type;\n\t\t\tself.isY = self.type == \"y\" ? true : false;\n\t\t\tself.scrollTopOrLeft = self.isY ? \"scrollTop\" : \"scrollLeft\";\n\t\t},\n\t\tdestroy: function() {\n\t\t\tvar self = this;\n\t\t\tUtil.remove(self.scrollbar);\n\t\t\tself.xscroll.off(\"scroll\", self._scrollHandler, self);\n\t\t\tself.xscroll.off(\"scrollend\", self._scrollEndHandler, self);\n\t\t},\n\t\trender: function() {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar boundry = xscroll.boundry;\n\t\t\tvar indicatorInsets = self.xscroll.userConfig.indicatorInsets;\n\t\t\tvar translateZ = xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\tvar transform = translateZ ? transformStr + \":\" + translateZ + \";\" : \"\";\n\t\t\tvar commonCss = \"opacity:0;position:absolute;z-index:999;overflow:hidden;-webkit-border-radius:3px;-moz-border-radius:3px;-o-border-radius:3px;\" + transform;\n\t\t\tindicatorInsets._xright =  indicatorInsets.right + indicatorInsets.spacing;\n\t\t\tindicatorInsets._xbottom =  indicatorInsets.bottom + indicatorInsets.spacing;\n\t\t\tvar css = self.isY ?\n\t\t\t\tUtil.substitute(\"width:{width}px;bottom:{_xbottom}px;top:{top}px;right:{right}px;\", indicatorInsets) + commonCss :\n\t\t\t\tUtil.substitute(\"height:{width}px;left:{left}px;right:{_xright}px;bottom:{bottom}px;\",indicatorInsets) + commonCss;\n\t\t\t\n\t\n\t\t\tif(!self.scrollbar){\n\t\t\t\tself.scrollbar = document.createElement(\"div\");\t\n\t\t\t\tself.indicate = document.createElement(\"div\");\n\t\t\t\txscroll.renderTo.appendChild(self.scrollbar);\n\t\t\t\tself.scrollbar.appendChild(self.indicate);\n\t\t\t}\n\t\t\tself.scrollbar.style.cssText = css;\n\t\t\tvar size = self.isY ? \"width:100%;\" : \"height:100%;\";\n\t\t\tself.indicate.style.cssText = size + \"position:absolute;background:rgba(0,0,0,0.3);-webkit-border-radius:3px;-moz-border-radius:3px;-o-border-radius:3px;\"\n\t\t\tself._update();\n\t\t\tself.hide(0);\n\t\t\tself._bindEvt();\n\t\t},\n\t\t_update: function(pos, duration, easing, callback) {\n\t\t\tvar self = this;\n\t\t\tvar pos = undefined === pos ? (self.isY ? self.xscroll.getScrollTop() : self.xscroll.getScrollLeft()) : pos;\n\t\t\tvar barInfo = self.computeScrollBar(pos);\n\t\t\tvar size = self.isY ? \"height\" : \"width\";\n\t\t\tself.indicate.style[size] = Math.round(barInfo.size) + \"px\";\n\t\t\tif (duration && easing) {\n\t\t\t\tself.scrollTo(barInfo.pos, duration, easing, callback);\n\t\t\t} else {\n\t\t\t\tself.moveTo(barInfo.pos);\n\t\t\t}\n\t\t},\n\t\t//compute the position and size of the scrollbar\n\t\tcomputeScrollBar: function(pos) {\n\t\t\tvar self = this;\n\t\t\tvar type = self.isY ? \"y\" : \"x\";\n\t\t\tvar spacing = self.userConfig.spacing;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar boundry = xscroll.boundry;\n\t\t\tvar userConfig = self.userConfig;\n\t\t\tvar pos = self.isY ? Math.round(pos) + boundry._xtop : Math.round(pos) + boundry._xleft;\n\t\t\tvar MIN_BAR_SCROLLED_SIZE = userConfig.MIN_BAR_SCROLLED_SIZE;\n\t\t\tvar MIN_BAR_SIZE = userConfig.MIN_BAR_SIZE;\n\t\t\tvar MAX_BOUNCE_DISTANCE = userConfig.MAX_BOUNCE_DISTANCE;\n\t\t\tself.containerSize = self.isY ? xscroll.containerHeight + boundry._xtop + boundry._xbottom : self.xscroll.containerWidth + boundry._xright + boundry._xleft;\n\t\t\tself.size = self.isY ? boundry.cfg.height : boundry.cfg.width;\n\t\t\tself.indicateSize = self.isY ? boundry.cfg.height - spacing * 2 : boundry.cfg.width - spacing * 2;\n\t\t\tvar indicateSize = self.indicateSize;\n\t\t\tvar containerSize = self.containerSize;\n\t\t\tvar barPos = indicateSize * pos / containerSize;\n\t\t\tvar barSize = Math.round(indicateSize * self.size / containerSize);\n\t\t\tvar overTop = self.isY ? xscroll.getBoundryOutTop() : xscroll.getBoundryOutLeft();\n\t\t\tvar overBottom = self.isY ? xscroll.getBoundryOutBottom() : xscroll.getBoundryOutRight();\n\t\t\tvar barShiftSize = MIN_BAR_SIZE - barSize > 0 ? MIN_BAR_SIZE - barSize : 0;\n\t\t\tbarSize = barSize < MIN_BAR_SIZE ? MIN_BAR_SIZE : barSize;\n\t\t\tbarPos = (indicateSize - barShiftSize) * pos / containerSize;\n\t\t\tif (overTop >= 0) {\n\t\t\t\tvar pct = overTop / MAX_BOUNCE_DISTANCE;\n\t\t\t\tpct = pct > 1 ? 1 : pct;\n\t\t\t\tbarPos = - pct * (barSize -  MIN_BAR_SCROLLED_SIZE)\n\t\t\t}\n\t\t\tif (overBottom >= 0) {\n\t\t\t\tvar pct = overBottom / MAX_BOUNCE_DISTANCE;\n\t\t\t\tpct = pct > 1 ? 1 : pct;\n\t\t\t\tbarPos = pct * (barSize - MIN_BAR_SCROLLED_SIZE) + indicateSize - barSize; \n\t\t\t}\n\t\t\tself.barPos = Math.round(barPos);\n\t\t\treturn {\n\t\t\t\tsize: Math.round(barSize),\n\t\t\t\tpos: self.barPos\n\t\t\t};\n\t\t},\n\t\tscrollTo: function(pos, duration, easing, callback) {\n\t\t\tvar self = this;\n\t\t\tself.show();\n\t\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\tvar config = {\n\t\t\t\tcss: {\n\t\t\t\t\ttransform: self.isY ? \"translateY(\" + pos + \"px)\" + translateZ : \"translateX(\" + pos + \"px)\" + translateZ\n\t\t\t\t},\n\t\t\t\tduration: duration,\n\t\t\t\teasing: easing,\n\t\t\t\tuseTransition: self.xscroll.userConfig.useTransition,\n\t\t\t\tend: callback\n\t\t\t};\n\t\t\tself.__timer = self.__timer || new Animate(self.indicate, config);\n\t\t\t//run\n\t\t\tself.__timer.stop();\n\t\t\tself.__timer.reset(config);\n\t\t\tself.__timer.run();\n\t\t},\n\t\tmoveTo: function(pos) {\n\t\t\tvar self = this;\n\t\t\tself.show();\n\t\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\tself.isY ? self.indicate.style[transform] = \"translateY(\" + pos + \"px) \" + translateZ : self.indicate.style[transform] = \"translateX(\" + pos + \"px) \" + translateZ\n\t\t\tself.indicate.style[transition] = \"\";\n\t\t},\n\t\t_scrollHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tself._update(e[self.scrollTopOrLeft]);\n\t\t\treturn self;\n\t\t},\n\t\tisBoundryOut: function() {\n\t\t\tvar self = this;\n\t\t\treturn !self.isY ? (self.xscroll.isBoundryOutLeft() || self.xscroll.isBoundryOutRight()) : (self.xscroll.isBoundryOutTop() || self.xscroll.isBoundryOutBottom());\n\t\t},\n\t\t_scrollEndHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tif (!self.isBoundryOut()) {\n\t\t\t\tself._update(e[self.scrollTopOrLeft]);\n\t\t\t\tself.hide();\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tif (self.__isEvtBind) return;\n\t\t\tself.__isEvtBind = true;\n\t\t\tself.xscroll.on(\"scroll\", self._scrollHandler, self);\n\t\t\tself.xscroll.on(\"scrollend\", self._scrollEndHandler, self);\n\t\t},\n\t\treset: function() {\n\t\t\tvar self = this;\n\t\t\tself.pos = 0;\n\t\t\tself._update();\n\t\t},\n\t\thide: function(duration, easing, delay) {\n\t\t\tvar self = this;\n\t\t\tvar duration = duration >= 0 ? duration : 300;\n\t\t\tvar easing = easing || \"ease-out\";\n\t\t\tvar delay = delay >= 0 ? delay : 100;\n\t\t\tself.scrollbar.style.opacity = 0;\n\t\t\tself.scrollbar.style[transition] = [\"opacity \", duration, \"ms \", \" ease-out \", delay, \"ms\"].join(\"\");\n\t\t},\n\t\tshow: function() {\n\t\t\tvar self = this;\n\t\t\tself.scrollbar.style.opacity = 1;\n\t\t\tself.scrollbar.style[transition] = \"\";\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = ScrollBar;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn ScrollBar;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\t//transform\n\tvar transform = Util.prefixStyle(\"transform\");\n\t// default render function for position:sticky elements\n\tvar defaultStickyRenderFunc = function(e) {\n\t  var stickyElement = e.stickyElement;\n\t  var curStickyElement = e.curStickyElement;\n\t  var xscroll = e.xscroll;\n\t  var _ = e._;\n\t  var infinite = xscroll.getPlugin(\"infinite\");\n\t  if (infinite) {\n\t    infinite.userConfig.renderHook.call(self, stickyElement, curStickyElement);\n\t    stickyElement.setAttribute(\"xs-guid\", curStickyElement.guid);\n\t    Util.addClass(stickyElement, curStickyElement.className);\n\t    for (var attrName in curStickyElement.style) {\n\t      if (attrName != \"display\" && attrName != \"position\") {\n\t        //copy styles\n\t        stickyElement.style[attrName] = attrName == _.height ? curStickyElement.style[attrName] + 'px' : curStickyElement.style[attrName];\n\t      }\n\t    }\n\t  } else {\n\t    var style = curStickyElement.getAttribute(\"style\");\n\t    stickyElement.innerHTML = curStickyElement.innerHTML;\n\t    stickyElement.className = curStickyElement.className;\n\t    style && stickyElement.setAttribute(\"style\", style);\n\t  }\n\t}\n\t\n\tvar Sticky = function(cfg) {\n\t  Sticky.superclass.constructor.call(this, cfg);\n\t  this.userConfig = Util.mix({\n\t    stickyRenderTo: undefined,\n\t    forceSticky: true,\n\t    prefix: \"xs-sticky-container\",\n\t    stickyRenderFunc: defaultStickyRenderFunc,\n\t    zoomType: \"y\"\n\t  }, cfg);\n\t  this.init();\n\t}\n\t\n\tUtil.extend(Sticky, Base, {\n\t  init: function() {\n\t    var self = this,\n\t      userConfig = self.userConfig,\n\t      xscroll = self.xscroll = userConfig.xscroll;\n\t    var isY = self.isY = !!(userConfig.zoomType == \"y\");\n\t    self._ = {\n\t      top: self.isY ? \"top\" : \"left\",\n\t      left: self.isY ? \"left\" : \"bottom\",\n\t      right: self.isY ? \"right\" : \"top\",\n\t      height: self.isY ? \"height\" : \"width\",\n\t      width: self.isY ? \"width\" : \"height\"\n\t    };\n\t    self.stickyRenderTo = Util.getNode(userConfig.stickyRenderTo);\n\t    self._handlers = [];\n\t    return self;\n\t  },\n\t  getStickiesPos: function() {\n\t    var self = this;\n\t    var xscroll = self.xscroll;\n\t    var isInfinite = self.isInfinite;\n\t    var isY = self.isY;\n\t    var _ = self._;\n\t    var stickiesPos = [];\n\t    var getPos = function(sticky) {\n\t      var pos = {};\n\t      if (isInfinite) {\n\t        pos[_.top] = isY ? sticky._top : sticky._left;\n\t        pos[_.height] = isY ? sticky._height : sticky._width;\n\t      } else {\n\t        pos[_.top] = self.isY ? Util.getOffsetTop(sticky) : Util.getOffsetLeft(sticky);\n\t        pos[_.height] = self.isY ? sticky.offsetHeight : sticky.offsetWidth;\n\t      }\n\t      return pos;\n\t    }\n\t    for (var i = 0; i < self.stickiesNum; i++) {\n\t      var pos = getPos(self.stickyElements[i]);\n\t      self._handlers[i] = self._handlers[i] || self.createStickyEl();\n\t      pos.el = self._handlers[i];\n\t      pos.isRender = false;\n\t      stickiesPos.push(pos);\n\t    }\n\t    return stickiesPos\n\t  },\n\t  getStickyElements: function() {\n\t    var self = this;\n\t    var xscroll = self.xscroll;\n\t    var userConfig = self.userConfig;\n\t    var isInfinite = self.isInfinite;\n\t    var infinite = xscroll.getPlugin(\"infinite\");\n\t    if (infinite) {\n\t      var stickyElements = [],\n\t        serializedData = infinite.__serializedData;\n\t      for (var i in serializedData) {\n\t        var rowData = serializedData[i];\n\t        if (rowData && rowData.style && \"sticky\" == rowData.style.position) {\n\t          stickyElements.push(rowData);\n\t        }\n\t      }\n\t      return stickyElements;\n\t    } else {\n\t      return Util.getNodes(xscroll.userConfig.stickyElements, xscroll.content);\n\t    }\n\t  },\n\t  render: function(force) {\n\t    var self = this;\n\t    var userConfig = self.userConfig;\n\t    var xscroll = self.xscroll;\n\t    self.isInfinite = !!xscroll.getPlugin(\"infinite\");\n\t    var _ = self._;\n\t    self.stickyElements = self.getStickyElements();\n\t    self.stickiesNum = self.stickyElements && self.stickyElements.length;\n\t    if (!self.stickiesNum) return;\n\t    if (!self.stickyRenderTo) {\n\t      self.stickyRenderTo = document.createElement('div');\n\t      xscroll.renderTo.appendChild(self.stickyRenderTo);\n\t    }\n\t    self.stickiesPos = self.getStickiesPos();\n\t    var stickyRenderTo = self.stickyRenderTo;\n\t    stickyRenderTo.style[_.top] = 0;\n\t    stickyRenderTo.style[_.left] = 0;\n\t    stickyRenderTo.style[_.right] = 0;\n\t    stickyRenderTo.style.position = xscroll.userConfig.useOriginScroll ? \"fixed\" : \"absolute\";\n\t    Util.addClass(self.stickyRenderTo, userConfig.prefix);\n\t    self.stickyHandler(force);\n\t    self._bindEvt();\n\t  },\n\t  createStickyEl: function() {\n\t    var self = this;\n\t    var el = document.createElement('div');\n\t    el.style.display = \"none\";\n\t    Util.addClass(el, \"xs-sticky-handler\");\n\t    self.stickyRenderTo.appendChild(el);\n\t    return el;\n\t  },\n\t  _bindEvt: function() {\n\t    var self = this,\n\t      xscroll = self.xscroll;\n\t    xscroll.on(\"scroll\", self.stickyHandler, self);\n\t  },\n\t  stickyHandler: function(force) {\n\t    var self = this;\n\t    var xscroll = self.xscroll;\n\t    var userConfig = self.userConfig;\n\t    var scrollTop = self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft();\n\t    var stickiesPos = self.stickiesPos;\n\t    var _ = self._;\n\t    var indexes = [];\n\t    for (var i = 0, l = stickiesPos.length; i < l; i++) {\n\t      var top = stickiesPos[i][_.top];\n\t      if (scrollTop > top) {\n\t        indexes.push(i);\n\t      }\n\t    }\n\t    if (!indexes.length) {\n\t      if (self.stickyElement) {\n\t        self.stickyElement.style.display = \"none\";\n\t      }\n\t      self.curStickyIndex = undefined;\n\t      return;\n\t    }\n\t\n\t    var curStickyIndex = Math.max.apply(null, indexes);\n\t    if (self.curStickyIndex != curStickyIndex || force) {\n\t      var prevStickyIndex = self.curStickyIndex;\n\t      self.curStickyIndex = curStickyIndex;\n\t      self.curStickyElement = self.stickyElements[curStickyIndex];\n\t      self.curStickyPos = stickiesPos[curStickyIndex];\n\t      self.stickyElement = self.curStickyPos.el;\n\t      for (var i = 0, l = stickiesPos.length; i < l; i++) {\n\t        stickiesPos[i].el.style.display = \"none\";\n\t      }\n\t      var eventsObj = {\n\t        stickyElement: self.stickyElement,\n\t        curStickyIndex: self.curStickyIndex,\n\t        prevStickyIndex: prevStickyIndex,\n\t        curStickyPos: self.curStickyPos,\n\t        isRender: self.curStickyPos.isRender\n\t      };\n\t      xscroll.trigger(\"beforestickychange\", eventsObj);\n\t      self._stickyRenderFunc(self);\n\t      xscroll.trigger(\"stickychange\", eventsObj);\n\t    }\n\t\n\t    var trans = 0;\n\t    if (self.stickiesPos[self.curStickyIndex + 1]) {\n\t      var cur = self.stickiesPos[self.curStickyIndex];\n\t      var next = self.stickiesPos[self.curStickyIndex + 1];\n\t      if (scrollTop + cur[_.height] > next[_.top] && scrollTop + cur[_.height] < next[_.top] + cur[_.height]) {\n\t        trans = cur[_.height] + scrollTop - next[_.top];\n\t      } else {\n\t        trans = 0;\n\t      }\n\t    }\n\t    self.stickyElement.style[transform] = self.isY ? \"translateY(-\" + (trans) + \"px) translateZ(0)\" : \"translateX(-\" + (trans) + \"px) translateZ(0)\";\n\t  },\n\t  _stickyRenderFunc: function(e) {\n\t    var self = this;\n\t    var _ = self._;\n\t    var stickyRenderFunc = self.userConfig.stickyRenderFunc;\n\t    var el = self.curStickyPos.el;\n\t    if (!self.curStickyPos.isRender) {\n\t      el.style[_.left] = 0;\n\t      el.style[_.right] = 0;\n\t      stickyRenderFunc && stickyRenderFunc.call(self, e);\n\t    }\n\t    el.style.display = \"block\";\n\t    self.curStickyPos.isRender = true;\n\t  },\n\t  destroy: function() {\n\t    var self = this;\n\t    self.stickyElements = undefined;\n\t    self.stickiesNum = undefined;\n\t    self.stickiesPos = undefined;\n\t    Util.remove(self.stickyElement);\n\t    self.stickyElement = undefined;\n\t  }\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t  module.exports = Sticky;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t  return Sticky;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\t// Returns a function that will be executed at most one time, no matter how\n\t// often you call it. Useful for lazy initialization.\n\tvar _once = function(func) {\n\t  var ran = false,\n\t    memo;\n\t  return function() {\n\t    if (ran) return memo;\n\t    ran = true;\n\t    memo = func.apply(this, arguments);\n\t    func = null;\n\t    return memo;\n\t  };\n\t};\n\t\n\t\n\t/**\n\t * @discription events\n\t * @mixin\n\t */\n\tvar Events = {\n\t  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n\t  // the callback to all events fired.\n\t  on: function(name, callback, context) {\n\t    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n\t    this._events || (this._events = {});\n\t    var events = this._events[name] || (this._events[name] = []);\n\t    events.push({\n\t      callback: callback,\n\t      context: context,\n\t      ctx: context || this\n\t    });\n\t    return this;\n\t  },\n\t\n\t\n\t  // Bind an event to only be triggered a single time. After the first time\n\t  // the callback is invoked, it will be removed.\n\t  once: function(name, callback, context) {\n\t    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n\t    var self = this;\n\t    var once = _once(function() {\n\t      self.off(name, once);\n\t      callback.apply(this, arguments);\n\t    });\n\t    once._callback = callback;\n\t    return this.on(name, once, context);\n\t  },\n\t\n\t  // Remove one or many callbacks. If `context` is null, removes all\n\t  // callbacks with that function. If `callback` is null, removes all\n\t  // callbacks for the event. If `name` is null, removes all bound\n\t  // callbacks for all events.\n\t  off: function(name, callback, context) {\n\t    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n\t\n\t    // Remove all callbacks for all events.\n\t    if (!name && !callback && !context) {\n\t      this._events = void 0;\n\t      return this;\n\t    }\n\t\n\t    var names = name ? [name] : Object.keys(this._events);\n\t    for (var i = 0, length = names.length; i < length; i++) {\n\t      name = names[i];\n\t\n\t      // Bail out if there are no events stored.\n\t      var events = this._events[name];\n\t      if (!events) continue;\n\t\n\t      // Remove all callbacks for this event.\n\t      if (!callback && !context) {\n\t        delete this._events[name];\n\t        continue;\n\t      }\n\t\n\t      // Find any remaining events.\n\t      var remaining = [];\n\t      for (var j = 0, k = events.length; j < k; j++) {\n\t        var event = events[j];\n\t        if (\n\t          callback && callback !== event.callback &&\n\t          callback !== event.callback._callback ||\n\t          context && context !== event.context\n\t        ) {\n\t          remaining.push(event);\n\t        }\n\t      }\n\t\n\t      // Replace events if there are any remaining.  Otherwise, clean up.\n\t      if (remaining.length) {\n\t        this._events[name] = remaining;\n\t      } else {\n\t        delete this._events[name];\n\t      }\n\t    }\n\t\n\t    return this;\n\t  },\n\t\n\t  // Trigger one or many events, firing all bound callbacks. Callbacks are\n\t  // passed the same arguments as `trigger` is, apart from the event name\n\t  // (unless you're listening on `\"all\"`, which will cause your callback to\n\t  // receive the true name of the event as the first argument).\n\t  trigger: function(name) {\n\t    if (!this._events) return this;\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    if (!eventsApi(this, 'trigger', name, args)) return this;\n\t    var events = this._events[name];\n\t    var allEvents = this._events.all;\n\t    if (events) triggerEvents(events, args);\n\t    if (allEvents) triggerEvents(allEvents, arguments);\n\t    return this;\n\t  },\n\t\n\t  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n\t  // listen to an event in another object ... keeping track of what it's\n\t  // listening to.\n\t  listenTo: function(obj, name, callback) {\n\t    var listeningTo = this._listeningTo || (this._listeningTo = {});\n\t    var id = obj._listenId || (obj._listenId = Util.guid('l'));\n\t    listeningTo[id] = obj;\n\t    if (!callback && typeof name === 'object') callback = this;\n\t    obj.on(name, callback, this);\n\t    return this;\n\t  },\n\t\n\t  listenToOnce: function(obj, name, callback) {\n\t    if (typeof name === 'object') {\n\t      for (var event in name) this.listenToOnce(obj, event, name[event]);\n\t      return this;\n\t    }\n\t    var cb = _once(function() {\n\t      this.stopListening(obj, name, cb);\n\t      callback.apply(this, arguments);\n\t    });\n\t    cb._callback = callback;\n\t    return this.listenTo(obj, name, cb);\n\t  },\n\t\n\t  // Tell this object to stop listening to either specific events ... or\n\t  // to every object it's currently listening to.\n\t  stopListening: function(obj, name, callback) {\n\t    var listeningTo = this._listeningTo;\n\t    if (!listeningTo) return this;\n\t    var remove = !name && !callback;\n\t    if (!callback && typeof name === 'object') callback = this;\n\t    if (obj)(listeningTo = {})[obj._listenId] = obj;\n\t    for (var id in listeningTo) {\n\t      obj = listeningTo[id];\n\t      obj.off(name, callback, this);\n\t      if (remove || Util.isEmpty(obj._events)) delete this._listeningTo[id];\n\t    }\n\t    return this;\n\t  }\n\t\n\t};\n\t\n\t// Regular expression used to split event strings.\n\tvar eventSplitter = /\\s+/;\n\t\n\t// Implement fancy features of the Events API such as multiple event\n\t// names `\"change blur\"` and jQuery-style event maps `{change: action}`\n\t// in terms of the existing API.\n\tvar eventsApi = function(obj, action, name, rest) {\n\t  if (!name) return true;\n\t\n\t  // Handle event maps.\n\t  if (typeof name === 'object') {\n\t    for (var key in name) {\n\t      obj[action].apply(obj, [key, name[key]].concat(rest));\n\t    }\n\t    return false;\n\t  }\n\t\n\t  // Handle space separated event names.\n\t  if (eventSplitter.test(name)) {\n\t    var names = name.split(eventSplitter);\n\t    for (var i = 0, length = names.length; i < length; i++) {\n\t      obj[action].apply(obj, [names[i]].concat(rest));\n\t    }\n\t    return false;\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\t// A difficult-to-believe, but optimized internal dispatch function for\n\t// triggering events. Tries to keep the usual cases speedy (most internal\n\tvar triggerEvents = function(events, args) {\n\t  var ev, i = -1,\n\t    l = events.length,\n\t    a1 = args[0],\n\t    a2 = args[1],\n\t    a3 = args[2];\n\t  switch (args.length) {\n\t    case 0:\n\t      while (++i < l)(ev = events[i]).callback.call(ev.ctx);\n\t      return;\n\t    case 1:\n\t      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1);\n\t      return;\n\t    case 2:\n\t      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);\n\t      return;\n\t    case 3:\n\t      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\t      return;\n\t    default:\n\t      while (++i < l)(ev = events[i]).callback.apply(ev.ctx, args);\n\t      return;\n\t  }\n\t};\n\t\n\t// Aliases for backwards compatibility.\n\tEvents.bind = Events.on;\n\tEvents.unbind = Events.off;\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t  module.exports = Events;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t  return Events;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t    Base = __webpack_require__(2),\n\t    Core = __webpack_require__(8),\n\t    Animate = __webpack_require__(3);\n\t\n\tvar transformOrigin = Util.prefixStyle(\"transformOrigin\");\n\t/** \n\t * @constructor\n\t * @param {object} cfg config for scroll\n\t * @extends XScroll\n\t * @example\n\t * var xscroll = new OriginScroll({\n\t *    renderTo:\"#scroll\"\n\t * });\n\t * xscroll.render();\n\t */\n\tfunction OriginScroll(cfg) {\n\t    OriginScroll.superclass.constructor.call(this, cfg);\n\t}\n\t\n\tUtil.extend(OriginScroll, Core, {\n\t    init: function() {\n\t        var self = this;\n\t        OriginScroll.superclass.init.call(this);\n\t        self.resetSize();\n\t    },\n\t    /**\n\t     * get scroll top value\n\t     * @memberof OriginScroll\n\t     * @return {number} scrollTop\n\t     */\n\t    getScrollTop: function() {\n\t        return this.renderTo.scrollTop;\n\t    },\n\t    /**\n\t     * get scroll left value\n\t     * @memberof OriginScroll\n\t     * @return {number} scrollLeft\n\t     */\n\t    getScrollLeft: function() {\n\t        return this.renderTo.scrollLeft;\n\t    },\n\t    /**\n\t     * vertical scroll absolute to the destination\n\t     * @memberof SimuScroll\n\t     * @param scrollTop {number} scrollTop\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollTop: function(y, duration, easing, callback) {\n\t        var self = this;\n\t        var y = Math.round(y);\n\t        if (self.userConfig.lockY) return;\n\t        var duration = duration || 0;\n\t        var easing = easing || \"quadratic\";\n\t        var config = {\n\t            css: {\n\t                scrollTop: y\n\t            },\n\t            duration: duration,\n\t            easing: easing,\n\t            run: function(e) {\n\t                //trigger scroll event\n\t                self.trigger(\"scroll\", {\n\t                    scrollTop: self.getScrollTop(),\n\t                    scrollLeft: self.getScrollLeft()\n\t                });\n\t            },\n\t            useTransition: false, //scrollTop \n\t            end: callback\n\t        };\n\t        self.__timers.y = self.__timers.y || new Animate(self.renderTo, config);\n\t        //run\n\t        self.__timers.y.stop();\n\t        self.__timers.y.reset(config);\n\t        self.__timers.y.run();\n\t    },\n\t    /**\n\t     * horizontal scroll absolute to the destination\n\t     * @memberof SimuScroll\n\t     * @param scrollLeft {number} scrollLeft\n\t     * @param duration {number} duration for animte\n\t     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t     **/\n\t    scrollLeft: function(x, duration, easing, callback) {\n\t        var self = this;\n\t        var x = Math.round(x);\n\t        if (self.userConfig.lockX) return;\n\t        var duration = duration || 0;\n\t        var easing = easing || \"quadratic\";\n\t        var config = {\n\t            css: {\n\t                scrollLeft: x\n\t            },\n\t            duration: duration,\n\t            easing: easing,\n\t            run: function(e) {\n\t                //trigger scroll event\n\t                self.trigger(\"scroll\", {\n\t                    scrollTop: self.getScrollTop(),\n\t                    scrollLeft: self.getScrollLeft()\n\t                });\n\t            },\n\t            useTransition: false, //scrollTop \n\t            end: callback\n\t        };\n\t        self.__timers.x = self.__timers.x || new Animate(self.renderTo, config);\n\t        //run\n\t        self.__timers.x.stop();\n\t        self.__timers.x.reset(config);\n\t        self.__timers.x.run();\n\t    },\n\t    _bindEvt: function() {\n\t        OriginScroll.superclass._bindEvt.call(this);\n\t        var self = this;\n\t        if (self.__isEvtBind) return;\n\t        self.__isEvtBind = true;\n\t        self.renderTo.addEventListener(\"scroll\", function(e) {\n\t            self.trigger(\"scroll\", {\n\t                type: \"scroll\",\n\t                scrollTop: self.getScrollTop(),\n\t                scrollLeft: self.getScrollLeft()\n\t            })\n\t        }, false)\n\t    }\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t    module.exports = OriginScroll;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t    return OriginScroll;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t\tBase = __webpack_require__(2);\n\t\n\tvar transform = Util.prefixStyle(\"transform\");\n\tvar transition = Util.prefixStyle(\"transition\");\n\t\n\t/**\n\t * An infinity dom-recycled list plugin for xscroll.\n\t * @constructor\n\t * @param {object} cfg\n\t * @param {string} cfg.transition recomposition cell with a transition\n\t * @param {string} cfg.infiniteElements dom-selector for reused elements\n\t * @param {function} cfg.renderHook render function for cell by per col or per row duration scrolling\n\t * @extends {Base}\n\t */\n\tvar Infinite = function(cfg) {\n\t\tInfinite.superclass.constructor.call(this, cfg);\n\t\tthis.userConfig = Util.mix({\n\t\t\ttransition: 'all 0.5s ease'\n\t\t}, cfg);\n\t}\n\t\n\tUtil.extend(Infinite, Base, {\n\t\t/**\n\t\t * a pluginId\n\t\t * @memberOf Infinite\n\t\t * @type {string}\n\t\t */\n\t\tpluginId: \"infinite\",\n\t\t/**\n\t\t * store the visible elements inside of view.\n\t\t * @memberOf Infinite\n\t\t * @type {object}\n\t\t */\n\t\tvisibleElements: {},\n\t\t/**\n\t\t * store all elements data.\n\t\t * @memberOf Infinite\n\t\t * @type {object}\n\t\t */\n\t\tsections: {},\n\t\t/**\n\t\t * plugin initializer\n\t\t * @memberOf Infinite\n\t\t * @override Base\n\t\t * @return {Infinite}\n\t\t */\n\t\tpluginInitializer: function(xscroll) {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = xscroll;\n\t\t\tself.isY = !!(xscroll.userConfig.zoomType == \"y\");\n\t\t\tself._ = {\n\t\t\t\t_top:self.isY ? \"_top\" : \"_left\",\n\t\t\t\t_height:self.isY ? \"_height\" : \"_width\",\n\t\t\t\ttop:self.isY ? \"top\" : \"left\",\n\t\t\t\theight:self.isY ? \"height\" : \"width\",\n\t\t\t\twidth:self.isY ? \"width\" : \"height\",\n\t\t\t\ty:self.isY ? \"y\" : \"x\",\n\t\t\t\ttranslate:self.isY ? \"translateY\" : \"translateX\",\n\t\t\t\tcontainerHeight:self.isY ? \"containerHeight\" : \"containerWidth\",\n\t\t\t\tscrollTop:self.isY ? \"scrollTop\" : \"scrollLeft\",\n\t\t\t}\n\t\t\tself._initInfinite();\n\t\t\txscroll.on(\"afterrender\", function() {\n\t\t\t\tself.render();\n\t\t\t\tself._bindEvt();\n\t\t\t});\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * detroy the plugin\n\t\t * @memberOf Infinite\n\t\t * @override Base\n\t\t * @return {Infinite}\n\t\t */\n\t\tpluginDestructor: function() {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\tself.infiniteElements[i].style[_.top] = \"auto\";\n\t\t\t\tself.infiniteElements[i].style[transform] = \"none\";\n\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t}\n\t\t\tself.xscroll && self.xscroll.off(\"scroll\", self._updateByScroll, self);\n\t\t\tself.xscroll && self.xscroll.off(\"tap panstart pan panend\", self._cellEventsHandler, self);\n\t\t\treturn self;\n\t\t},\n\t\t_initInfinite: function() {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar _ = self._;\n\t\t\tself.sections = {};\n\t\t\tself.infiniteElements = xscroll.renderTo.querySelectorAll(self.userConfig.infiniteElements);\n\t\t\tself.infiniteLength = self.infiniteElements.length;\n\t\t\tself.infiniteElementsCache = (function() {\n\t\t\t\tvar tmp = []\n\t\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\t\ttmp.push({});\n\t\t\t\t\tself.infiniteElements[i].style.position = \"absolute\";\n\t\t\t\t\tself.infiniteElements[i].style[_.top] = 0;\n\t\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t\t\tself.infiniteElements[i].style.display = \"block\";\n\t\t\t\t\tUtil.addClass(self.infiniteElements[i], \"_xs_infinite_elements_\");\n\t\t\t\t}\n\t\t\t\treturn tmp;\n\t\t\t})();\n\t\t\tself.elementsPos = {};\n\t\t\treturn self;\n\t\t},\n\t\t_renderUnRecycledEl: function() {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tvar translateZ = self.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\tfor (var i in self.__serializedData) {\n\t\t\t\tvar unrecycledEl = self.__serializedData[i];\n\t\t\t\tif (self.__serializedData[i]['recycled'] === false) {\n\t\t\t\t\tvar el = unrecycledEl.id && document.getElementById(unrecycledEl.id.replace(\"#\", \"\")) || document.createElement(\"div\");\n\t\t\t\t\tvar randomId = Util.guid(\"xs-row-\");\n\t\t\t\t\tel.id = unrecycledEl.id || randomId;\n\t\t\t\t\tunrecycledEl.id = el.id;\n\t\t\t\t\tself.xscroll.content.appendChild(el);\n\t\t\t\t\tfor (var attrName in unrecycledEl.style) {\n\t\t\t\t\t\tif (attrName != _.height && attrName != \"display\" && attrName != \"position\") {\n\t\t\t\t\t\t\tel.style[attrName] = unrecycledEl.style[attrName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tel.style[_.top] = 0;\n\t\t\t\t\tel.style.position = \"absolute\";\n\t\t\t\t\tel.style.display = \"block\";\n\t\t\t\t\tel.style[_.height] = unrecycledEl[_._height] + \"px\";\n\t\t\t\t\tel.style[transform] = _.translate + \"(\" + unrecycledEl[_._top] + \"px) \" + translateZ;\n\t\t\t\t\tUtil.addClass(el, unrecycledEl.className);\n\t\t\t\t\tself.userConfig.renderHook.call(self, el, unrecycledEl);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * render or update the scroll contents\n\t\t * @memberOf Infinite\n\t\t * @return {Infinite}\n\t\t */\n\t\trender: function() {\n\t\t\tvar self = this;\n\t\t\tvar _  = self._;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar offset = self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft();\n\t\t\tself.visibleElements = self.getVisibleElements(offset);\n\t\t\tself.__serializedData = self._computeDomPositions();\n\t\t\txscroll.sticky && xscroll.sticky.render(true); //force render\n\t\t\txscroll.fixed && xscroll.fixed.render();\n\t\t\tvar size = xscroll[_.height];\n\t\t\tvar containerSize = self._containerSize;\n\t\t\tif (containerSize < size) {\n\t\t\t\tcontainerSize = size;\n\t\t\t}\n\t\t\txscroll[_.containerHeight] = containerSize;\n\t\t\txscroll.container.style[_.height] = containerSize + \"px\";\n\t\t\txscroll.content.style[_.height] = containerSize + \"px\";\n\t\t\tself._renderUnRecycledEl();\n\t\t\tself._updateByScroll();\n\t\t\tself._updateByRender(offset);\n\t\t\tself.xscroll.boundryCheck();\n\t\t\treturn self;\n\t\t},\n\t\t_getChangedRows: function(newElementsPos) {\n\t\t\tvar self = this;\n\t\t\tvar changedRows = {};\n\t\t\tfor (var i in self.elementsPos) {\n\t\t\t\tif (!newElementsPos.hasOwnProperty(i)) {\n\t\t\t\t\tchangedRows[i] = \"delete\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in newElementsPos) {\n\t\t\t\tif (newElementsPos[i].recycled && !self.elementsPos.hasOwnProperty(i)) {\n\t\t\t\t\tchangedRows[i] = \"add\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.elementsPos = newElementsPos;\n\t\t\treturn changedRows;\n\t\t},\n\t\t_updateByScroll: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar _ = self._;\n\t\t\tvar _pos = e && e[_.scrollTop];\n\t\t\tvar pos = _pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : _pos;\n\t\t\tvar elementsPos = self.getVisibleElements(pos);\n\t\t\tvar changedRows = self.changedRows = self._getChangedRows(elementsPos);\n\t\t\ttry{\n\t\t\t\tfor (var i in changedRows) {\n\t\t\t\t\tif (changedRows[i] == \"delete\") {\n\t\t\t\t\t\tself._pushEl(i);\n\t\t\t\t\t}\n\t\t\t\t\tif (changedRows[i] == \"add\") {\n\t\t\t\t\t\tvar elObj = self._popEl(elementsPos[i][self.guid]);\n\t\t\t\t\t\tvar index = elObj.index;\n\t\t\t\t\t\tvar el = elObj.el;\n\t\t\t\t\t\tif (el) {\n\t\t\t\t\t\t\tself.infiniteElementsCache[index].guid = elementsPos[i].guid;\n\t\t\t\t\t\t\tself.__serializedData[elementsPos[i].guid].__infiniteIndex = index;\n\t\t\t\t\t\t\tself._renderData(el, elementsPos[i]);\n\t\t\t\t\t\t\tself._renderStyle(el, elementsPos[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}catch(e){\n\t\t\t\tconsole.warn('Not enough infiniteElements setted!');\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_updateByRender: function(pos) {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar pos = pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : pos;\n\t\t\tvar prevElementsPos = self.visibleElements;\n\t\t\tvar newElementsPos = self.getVisibleElements(pos);\n\t\t\tvar prevEl, newEl;\n\t\t\t//repaint\n\t\t\tfor (var i in newElementsPos) {\n\t\t\t\tnewEl = newElementsPos[i];\n\t\t\t\tfor (var j in prevElementsPos) {\n\t\t\t\t\tprevEl = prevElementsPos[j];\n\t\t\t\t\tif (prevEl.guid === newEl.guid) {\n\t\t\t\t\t\tif (newEl.style != prevEl.style || newEl[_._top] != prevEl[_._top] || newEl[_._height] != prevEl[_._height]) {\n\t\t\t\t\t\t\tself._renderStyle(self.infiniteElements[newEl.__infiniteIndex], newEl, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (JSON.stringify(newEl.data) != JSON.stringify(prevEl.data)) {\n\t\t\t\t\t\t\tself._renderData(self.infiniteElements[newEl.__infiniteIndex], newEl);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// paint\n\t\t\t\t\t\tif (self.__serializedData[newEl.guid].recycled && self.__serializedData[newEl.guid].__infiniteIndex === undefined) {\n\t\t\t\t\t\t\tvar elObj = self._popEl();\n\t\t\t\t\t\t\tself.__serializedData[newEl.guid].__infiniteIndex = elObj.index;\n\t\t\t\t\t\t\tself._renderData(elObj.el, newEl);\n\t\t\t\t\t\t\tself._renderStyle(elObj.el, newEl);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.visibleElements = newElementsPos;\n\t\t},\n\t\t/**\n\t\t * get all element posInfo such as top,height,template,html\n\t\t * @return {Array}\n\t\t **/\n\t\t_computeDomPositions: function() {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tvar pos = 0,\n\t\t\t\tsize = 0,\n\t\t\t\tsections = self.sections,\n\t\t\t\tsection;\n\t\t\tvar data = [];\n\t\t\tvar serializedData = {};\n\t\t\tfor (var i in sections) {\n\t\t\t\tfor (var j = 0, len = sections[i].length; j < len; j++) {\n\t\t\t\t\tsection = sections[i][j];\n\t\t\t\t\tsection.sectionId = i;\n\t\t\t\t\tsection.index = j;\n\t\t\t\t\tdata.push(section);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t//f = v/itemSize*1000 < 60 => v = 0.06 * itemSize\n\t\t\tself.userConfig.maxSpeed = 0.06 * 50;\n\t\t\tfor (var i = 0, l = data.length; i < l; i++) {\n\t\t\t\tvar item = data[i];\n\t\t\t\tsize = item.style && item.style[_.height] >= 0 && item.style.position != \"fixed\" ? item.style[_.height] : 0;\n\t\t\t\titem.guid = item.guid || Util.guid();\n\t\t\t\titem[_._top] = pos;\n\t\t\t\titem[_._height] = size;\n\t\t\t\titem.recycled = item.recycled === false ? false : true;\n\t\t\t\tpos += size;\n\t\t\t\tserializedData[item.guid] = item;\n\t\t\t}\n\t\t\tself._containerSize = pos;\n\t\t\treturn serializedData;\n\t\t},\n\t\t/**\n\t\t * get all elements inside of the view.\n\t\t * @memberOf Infinite\n\t\t * @param {number} pos scrollLeft or scrollTop\n\t\t * @return {object} visibleElements\n\t\t */\n\t\tgetVisibleElements: function(pos) {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar _ = self._;\n\t\t\tvar pos = pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : pos;\n\t\t\tvar threshold = self.userConfig.threshold >= 0 ? self.userConfig.threshold : xscroll[_.height] / 3;\n\t\t\tvar tmp = {},\n\t\t\t\titem;\n\t\t\tvar data = self.__serializedData;\n\t\t\tfor (var i in data) {\n\t\t\t\titem = data[i];\n\t\t\t\tif (item[_._top] >= pos - threshold && item[_._top] <= pos + xscroll[_.height] + threshold) {\n\t\t\t\t\ttmp[item.guid] = item;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn JSON.parse(JSON.stringify(tmp));\n\t\t},\n\t\t_popEl: function() {\n\t\t\tvar self = this;\n\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\tif (!self.infiniteElementsCache[i]._visible) {\n\t\t\t\t\tself.infiniteElementsCache[i]._visible = true;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tel: self.infiniteElements[i]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_pushEl: function(guid) {\n\t\t\tvar self = this;\n\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\tif (self.infiniteElementsCache[i].guid == guid) {\n\t\t\t\t\tself.infiniteElementsCache[i]._visible = false;\n\t\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t\t\tself.infiniteElementsCache[i].guid = null;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_renderData: function(el, elementObj) {\n\t\t\tvar self = this;\n\t\t\tif (!el || !elementObj || elementObj.style.position == \"fixed\") return;\n\t\t\tself.userConfig.renderHook.call(self, el, elementObj);\n\t\t},\n\t\t_renderStyle: function(el, elementObj, useTransition) {\n\t\t\tvar self = this;\n\t\t\tvar _ = self._;\n\t\t\tif (!el) return;\n\t\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t\t//update style\n\t\t\tfor (var attrName in elementObj.style) {\n\t\t\t\tif (attrName != _.height && attrName != \"display\" && attrName != \"position\") {\n\t\t\t\t\tel.style[attrName] = elementObj.style[attrName];\n\t\t\t\t}\n\t\t\t}\n\t\t\tel.setAttribute(\"xs-index\", elementObj.index);\n\t\t\tel.setAttribute(\"xs-sectionid\", elementObj.sectionId);\n\t\t\tel.setAttribute(\"xs-guid\", elementObj.guid);\n\t\t\tel.style.visibility = \"visible\";\n\t\t\tel.style[_.height] = elementObj[_._height] + \"px\";\n\t\t\tel.style[transform] = _.translate + \"(\" + elementObj[_._top] + \"px) \" + translateZ;\n\t\t\tel.style[transition] = useTransition ? self.userConfig.transition : \"none\";\n\t\t},\n\t\tgetCell: function(e) {\n\t\t\tvar self = this,\n\t\t\t\tcell;\n\t\t\tvar el = Util.findParentEl(e.target, \"._xs_infinite_elements_\", self.xscroll.renderTo);\n\t\t\tif(!el){\n\t\t\t\tel = Util.findParentEl(e.target, \".xs-sticky-handler\", self.xscroll.renderTo);\n\t\t\t}\n\t\t\tvar guid = el && el.getAttribute(\"xs-guid\");\n\t\t\tif (undefined === guid) return;\n\t\t\treturn {\n\t\t\t\tdata:self.__serializedData[guid],\n\t\t\t\tel:el\n\t\t\t};\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tif (self._isEvtBinded) return;\n\t\t\tself._isEvtBinded = true;\n\t\t\tself.xscroll.renderTo.addEventListener(\"webkitTransitionEnd\", function(e) {\n\t\t\t\tif (e.target.className.match(/xs-row/)) {\n\t\t\t\t\te.target.style.webkitTransition = \"\";\n\t\t\t\t}\n\t\t\t});\n\t\t\tself.xscroll.on(\"scroll\", self._updateByScroll, self);\n\t\t\tself.xscroll.on(\"tap panstart pan panend\", self._cellEventsHandler, self);\n\t\t\treturn self;\n\t\t},\n\t\t_cellEventsHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar cell = self.getCell(e);\n\t\t\te.cell = cell.data;\n\t\t\te.cellEl = cell.el;\n\t\t\te.cell && self[e.type].call(self, e);\n\t\t},\n\t\t/**\n\t\t * tap event\n\t\t * @memberOf Infinite\n\t\t * @param {object} e events data include cell object\n\t\t * @event\n\t\t */\n\t\ttap: function(e) {\n\t\t\tthis.trigger(\"tap\", e);\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * panstart event\n\t\t * @memberOf Infinite\n\t\t * @param {object} e events data include cell object\n\t\t * @event\n\t\t */\n\t\tpanstart: function(e) {\n\t\t\tthis.trigger(\"panstart\", e);\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * pan event\n\t\t * @memberOf Infinite\n\t\t * @param {object} e events data include cell object\n\t\t * @event\n\t\t */\n\t\tpan: function(e) {\n\t\t\tthis.trigger(\"pan\", e);\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * panend event\n\t\t * @memberOf Infinite\n\t\t * @param {object} e events data include cell object\n\t\t * @event\n\t\t */\n\t\tpanend: function(e) {\n\t\t\tthis.trigger(\"panend\", e);\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * insert data before a position\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId of the target cell\n\t\t * @param {number} index index of the target cell\n\t\t * @param {object} data data to insert\n\t\t * @return {Infinite}\n\t\t */\n\t\tinsertBefore: function(sectionId, index, data) {\n\t\t\tvar self = this;\n\t\t\tif (sectionId === undefined || index === undefined || data === undefined) return self;\n\t\t\tif (!self.sections[sectionId]) {\n\t\t\t\tself.sections[sectionId] = [];\n\t\t\t}\n\t\t\tself.sections[sectionId].splice(index, 0, data);\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * insert data after a position\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId of the target cell\n\t\t * @param {number} index index of the target cell\n\t\t * @param {object} data data to insert\n\t\t * @return {Infinite}\n\t\t */\n\t\tinsertAfter: function(sectionId, index, data) {\n\t\t\tvar self = this;\n\t\t\tif (sectionId === undefined || index === undefined || data === undefined) return self;\n\t\t\tif (!self.sections[sectionId]) {\n\t\t\t\tself.sections[sectionId] = [];\n\t\t\t}\n\t\t\tself.sections[sectionId].splice(Number(index) + 1, 0, data);\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * append data after a section\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId for the append cell\n\t\t * @param {object} data data to append\n\t\t * @return {Infinite}\n\t\t */\n\t\tappend: function(sectionId, data) {\n\t\t\tvar self = this;\n\t\t\tif (!self.sections[sectionId]) {\n\t\t\t\tself.sections[sectionId] = [];\n\t\t\t}\n\t\t\tself.sections[sectionId] = self.sections[sectionId].concat(data);\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * remove some data by sectionId,from,number\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId for the append cell\n\t\t * @param {number} from removed index from\n\t\t * @param {number} number removed data number\n\t\t * @return {Infinite}\n\t\t */\n\t\tremove: function(sectionId, from, number) {\n\t\t\tvar self = this;\n\t\t\tvar number = number || 1;\n\t\t\tif (undefined === sectionId || !self.sections[sectionId]) return self;\n\t\t\t//remove a section\n\t\t\tif (undefined === from) {\n\t\t\t\tself.sections[sectionId] = null;\n\t\t\t\treturn self;\n\t\t\t}\n\t\t\t//remove some data in section\n\t\t\tif (self.sections[sectionId] && self.sections[sectionId][from]) {\n\t\t\t\tself.sections[sectionId].splice(from, number);\n\t\t\t\treturn self;\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * replace some data by sectionId and index\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId to replace\n\t\t * @param {number} index removed index from\n\t\t * @param {object} data new data to replace\n\t\t * @return {Infinite}\n\t\t */\n\t\treplace: function(sectionId, index, data) {\n\t\t\tvar self = this;\n\t\t\tif (undefined === sectionId || !self.sections[sectionId]) return self;\n\t\t\tself.sections[sectionId][index] = data;\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * get data by sectionId and index\n\t\t * @memberOf Infinite\n\t\t * @param {string} sectionId sectionId\n\t\t * @param {number} index index in the section\n\t\t * @return {object} data data\n\t\t */\n\t\tget: function(sectionId, index) {\n\t\t\tif (undefined === sectionId) return;\n\t\t\tif (undefined === index) return this.sections[sectionId];\n\t\t\treturn this.sections[sectionId][index];\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = Infinite;\n\t}\n\t/** ignored by jsdoc **/\n\telse if (window.XScroll && window.XScroll.Plugins) {\n\t\treturn XScroll.Plugins.Infinite = Infinite;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\tvar clsPrefix;\n\tvar containerCls;\n\tvar content = \"Pull Down To Refresh\";\n\tvar loadingContent = \"Loading...\";\n\t/**\n\t * A pulldown to refresh plugin for xscroll.\n\t * @constructor\n\t * @param {object} cfg\n\t * @param {number} cfg.height\n\t * @param {string} cfg.content default html for pulldown\n\t * @param {string} cfg.downContent html for pulldown when scrollTop is smaller than cfg.height\n\t * @param {string} cfg.upContent html for pulldown when scrollTop is larger than cfg.height\n\t * @param {string} cfg.loadingContent html for pulldown when released\n\t * @param {string} cfg.clsPrefix  class prefix which default value is \"xs-plugin-pulldown-\"\n\t * @extends {Base}\n\t */\n\tvar PullDown = function(cfg) {\n\t\tPullDown.superclass.constructor.call(this, cfg);\n\t\tthis.userConfig = Util.mix({\n\t\t\tcontent: content,\n\t\t\theight: 60,\n\t\t\tautoRefresh: true,\n\t\t\tdownContent: \"Pull Down To Refresh\",\n\t\t\tupContent: \"Release To Refresh\",\n\t\t\tloadingContent: loadingContent,\n\t\t\tclsPrefix: \"xs-plugin-pulldown-\"\n\t\t}, cfg);\n\t}\n\tUtil.extend(PullDown, Base, {\n\t\t/**\n\t\t * a pluginId\n\t\t * @memberOf PullDown\n\t\t * @type {string}\n\t\t */\n\t\tpluginId: \"pulldown\",\n\t\t/**\n\t\t * plugin initializer\n\t\t * @memberOf PullDown\n\t\t * @override Base\n\t\t * @return {PullDown}\n\t\t */\n\t\tpluginInitializer: function(xscroll) {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = xscroll.render();\n\t\t\tclsPrefix = self.userConfig.clsPrefix;\n\t\t\tself.render();\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * detroy the plugin\n\t\t * @memberOf PullDown\n\t\t * @override Base\n\t\t * @return {PullDown}\n\t\t */\n\t\tpluginDestructor: function() {\n\t\t\tvar self = this;\n\t\t\tUtil.remove(self.pulldown);\n\t\t\tself.xscroll.off(\"panstart\", self._panStartHandler, self);\n\t\t\tself.xscroll.off(\"pan\", self._panHandler, self);\n\t\t\tself.xscroll.off(\"panend\", self._panEndHandler, self);\n\t\t\tself.__isRender = false;\n\t\t\tself._evtBinded = false;\n\t\t},\n\t\t/**\n\t\t * render pulldown plugin\n\t\t * @memberOf PullDown\n\t\t * @return {PullDown}\n\t\t */\n\t\trender: function() {\n\t\t\tvar self = this;\n\t\t\tif (self.__isRender) return;\n\t\t\tself.__isRender = true;\n\t\t\tvar containerCls = clsPrefix + \"container\";\n\t\t\tvar height = self.userConfig.height || 60;\n\t\t\tvar pulldown = self.pulldown = document.createElement(\"div\");\n\t\t\tpulldown.className = containerCls;\n\t\t\tpulldown.style.position = \"absolute\";\n\t\t\tpulldown.style.width = \"100%\";\n\t\t\tpulldown.style.height = height + \"px\";\n\t\t\tpulldown.style.lineHeight = height + \"px\";\n\t\t\tpulldown.style.top = -height + \"px\";\n\t\t\tpulldown.style.textAlign = \"center\";\n\t\t\tself.xscroll.container.appendChild(pulldown);\n\t\t\tself.status = 'up';\n\t\t\tUtil.addClass(pulldown, clsPrefix + self.status);\n\t\t\tpulldown.innerHTML = self.userConfig[self.status + \"Content\"] || self.userConfig.content;\n\t\t\tself._bindEvt();\n\t\t\treturn self;\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tif (self._evtBinded) return;\n\t\t\tself._evtBinded = true;\n\t\t\tvar pulldown = self.pulldown;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\txscroll.on(\"pan\", self._panHandler, self);\n\t\t\txscroll.on(\"panstart\", self._panStartHandler, self);\n\t\t\txscroll.on(\"panend\", self._panEndHandler, self);\n\t\t},\n\t\t_changeStatus: function(status) {\n\t\t\tvar prevVal = this.status;\n\t\t\tthis.status = status;\n\t\t\tUtil.removeClass(this.pulldown, clsPrefix + prevVal)\n\t\t\tUtil.addClass(this.pulldown, clsPrefix + status);\n\t\t\tif (this.userConfig[status + \"Content\"]) {\n\t\t\t\tthis.pulldown.innerHTML = this.userConfig[status + \"Content\"];\n\t\t\t}\n\t\t\tif (prevVal != status) {\n\t\t\t\tthis.trigger(\"statuschange\", {\n\t\t\t\t\tprevVal: prevVal,\n\t\t\t\t\tnewVal: status\n\t\t\t\t});\n\t\t\t\tif (status == \"loading\") {\n\t\t\t\t\tthis.trigger(\"loading\");\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * reset the pulldown plugin\n\t\t * @memberOf PullDown\n\t\t * @param {function} callback\n\t\t * @return {PullDown}\n\t\t */\n\t\treset: function(callback) {\n\t\t\tthis.xscroll.boundry.resetTop()\n\t\t\tthis.xscroll.boundryCheckY(callback);\n\t\t\tthis._expanded = false;\n\t\t\treturn this;\n\t\t},\n\t\t_panStartHandler: function(e) {\n\t\t\tclearTimeout(this.loadingItv);\n\t\t},\n\t\t_panHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar scrollTop = self.xscroll.getScrollTop();\n\t\t\tif (scrollTop > 0) return;\n\t\t\tself._changeStatus(Math.abs(scrollTop) < self.userConfig.height ? \"down\" : \"up\");\n\t\t},\n\t\t_panEndHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar height = self.userConfig.height || 60;\n\t\t\tvar scrollTop = xscroll.getScrollTop();\n\t\t\tif (scrollTop < -height) {\n\t\t\t\t//prevent default bounce\n\t\t\t\te.preventDefault();\n\t\t\t\txscroll.boundry.resetTop();\n\t\t\t\txscroll.boundry.expandTop(height);\n\t\t\t\txscroll.boundryCheckY(function() {\n\t\t\t\t\tself._changeStatus(\"loading\");\n\t\t\t\t});\n\t\t\t\tif (self.userConfig.autoRefresh) {\n\t\t\t\t\tclearTimeout(self.loadingItv);\n\t\t\t\t\tself.loadingItv = setTimeout(function() {\n\t\t\t\t\t\txscroll.boundry.resetTop();\n\t\t\t\t\t\txscroll.boundryCheckY(function() {\n\t\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t\t})\n\t\t\t\t\t}, 800);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = PullDown;\n\t}\n\t/** ignored by jsdoc **/\n\telse if (window.XScroll && window.XScroll.Plugins) {\n\t\treturn XScroll.Plugins.PullDown = PullDown;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1);\n\tvar Base = __webpack_require__(2);\n\tvar clsPrefix;\n\tvar containerCls;\n\tvar loadingContent = \"Loading...\";\n\tvar upContent = \"Pull Up To Refresh\";\n\tvar downContent = \"Release To Refresh\";\n\tvar PULL_UP_HEIGHT = 60;\n\tvar HEIGHT = 40;\n\t/**\n\t * A pullup to load plugin for xscroll.\n\t * @constructor\n\t * @param {object} cfg\n\t * @param {number} cfg.height\n\t * @param {string} cfg.downContent\n\t * @param {string} cfg.upContent\n\t * @param {string} cfg.loadingContent\n\t * @param {string} cfg.clsPrefix  class prefix which default value is \"xs-plugin-pullup-\"\n\t * @param {number} cfg.bufferHeight preload data before scrolling to the bottom of the boundry\n\t * @extends {Base}\n\t */\n\tvar PullUp = function(cfg) {\n\t\tPullUp.superclass.constructor.call(this);\n\t\tthis.userConfig = Util.mix({\n\t\t\tupContent: upContent,\n\t\t\tdownContent: downContent,\n\t\t\tpullUpHeight: PULL_UP_HEIGHT,\n\t\t\theight: HEIGHT,\n\t\t\tloadingContent: loadingContent,\n\t\t\tbufferHeight: 0,\n\t\t\tclsPrefix: \"xs-plugin-pullup-\"\n\t\t}, cfg);\n\t}\n\tUtil.extend(PullUp, Base, {\n\t\t/**\n\t\t * a pluginId\n\t\t * @memberOf PullUp\n\t\t * @type {string}\n\t\t */\n\t\tpluginId: \"pullup\",\n\t\t/**\n\t\t * plugin initializer\n\t\t * @memberOf PullUp\n\t\t * @override Base\n\t\t * @return {PullUp}\n\t\t */\n\t\tpluginInitializer: function(xscroll) {\n\t\t\tvar self = this;\n\t\t\tself.xscroll = xscroll.render();\n\t\t\tclsPrefix = self.userConfig.clsPrefix;\n\t\t\tself.render();\n\t\t\treturn self;\n\t\t},\n\t\t/**\n\t\t * detroy the plugin\n\t\t * @memberOf PullUp\n\t\t * @override Base\n\t\t * @return {PullUp}\n\t\t */\n\t\tpluginDestructor: function() {\n\t\t\tvar self = this;\n\t\t\tUtil.remove(self.pullup);\t\t\n\t\t\tself.xscroll.off(\"scrollend\", self._scrollEndHandler, self);\n\t\t\tself.xscroll.off(\"scroll\", self._scrollHandler, self);\n\t\t\tself.xscroll.off(\"pan\", self._panHandler, self);\n\t\t\tself.xscroll.boundry.resetBottom();\n\t\t\tself.__isRender = false;\n\t\t\tself._evtBinded = false;\n\t\t},\n\t\t/**\n\t\t * render pullup plugin\n\t\t * @memberOf PullUp\n\t\t * @return {PullUp}\n\t\t */\n\t\trender: function() {\n\t\t\tvar self = this;\n\t\t\tif (self.__isRender) return;\n\t\t\tself.__isRender = true;\n\t\t\tvar containerCls = clsPrefix + \"container\";\n\t\t\tvar height = self.userConfig.height;\n\t\t\tvar pullup = self.pullup = document.createElement(\"div\");\n\t\t\tpullup.className = containerCls;\n\t\t\tpullup.style.position = \"absolute\";\n\t\t\tpullup.style.width = \"100%\";\n\t\t\tpullup.style.height = height + \"px\";\n\t\t\tpullup.style.bottom = -height + \"px\";\n\t\t\tself.xscroll.container.appendChild(pullup);\n\t\t\tself.xscroll.boundry.expandBottom(self.userConfig.height);\n\t\t\tself.status = 'up';\n\t\t\tUtil.addClass(pullup, clsPrefix + self.status);\n\t\t\tpullup.innerHTML = self.userConfig[self.status + \"Content\"] || self.userConfig.content;\n\t\t\tself._bindEvt();\n\t\t\treturn self;\n\t\t},\n\t\t_bindEvt: function() {\n\t\t\tvar self = this;\n\t\t\tif (self._evtBinded) return;\n\t\t\tself._evtBinded = true;\n\t\t\tvar pullup = self.pullup;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\txscroll.on(\"pan\", self._panHandler, self);\n\t\t\t//load width a buffer\n\t\t\tif (self.userConfig.bufferHeight > 0) {\n\t\t\t\txscroll.on(\"scroll\", self._scrollHandler, self);\n\t\t\t}\n\t\t\t//bounce bottom\n\t\t\txscroll.on(\"scrollend\", self._scrollEndHandler, self);\n\t\t\treturn self;\n\t\t},\n\t\t_scrollEndHandler: function(e) {\n\t\t\tvar self = this,\n\t\t\t\txscroll = self.xscroll,\n\t\t\t\tscrollTop = xscroll.getScrollTop();\n\t\t\tif (scrollTop == xscroll.containerHeight - xscroll.height + self.userConfig.height) {\n\t\t\t\tself._changeStatus(\"loading\");\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_scrollHandler: function(e) {\n\t\t\tvar self = this,\n\t\t\t\txscroll = self.xscroll;\n\t\t\tif (!self.isLoading && Math.abs(e.scrollTop) + xscroll.height + self.userConfig.height + self.userConfig.bufferHeight >= xscroll.containerHeight + xscroll.boundry._xtop + xscroll.boundry._xbottom) {\n\t\t\t\tself._changeStatus(\"loading\");\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_panHandler: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tvar offsetTop = -xscroll.getScrollTop();\n\t\t\tif (offsetTop < xscroll.height - xscroll.containerHeight - self.userConfig.pullUpHeight) {\n\t\t\t\tself._changeStatus(\"down\")\n\t\t\t} else {\n\t\t\t\tself._changeStatus(\"up\");\n\t\t\t}\n\t\t\treturn self;\n\t\t},\n\t\t_changeStatus: function(status) {\n\t\t\tif (status != \"loading\" && this.isLoading) return;\n\t\t\tvar prevVal = this.status;\n\t\t\tthis.status = status;\n\t\t\tUtil.removeClass(this.pullup, clsPrefix + prevVal)\n\t\t\tUtil.addClass(this.pullup, clsPrefix + status);\n\t\t\tthis.pullup.innerHTML = this.userConfig[status + \"Content\"];\n\t\t\tif (prevVal != status) {\n\t\t\t\tthis.trigger(\"statuschange\", {\n\t\t\t\t\tprevVal: prevVal,\n\t\t\t\t\tnewVal: status\n\t\t\t\t});\n\t\t\t\tif (status == \"loading\") {\n\t\t\t\t\tthis.isLoading = true;\n\t\t\t\t\tthis.trigger(\"loading\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\t/**\n\t\t * notify pullup plugin to complete state after a remote data request\n\t\t * @memberOf PullUp\n\t\t * @return {PullUp}\n\t\t */\n\t\tcomplete: function() {\n\t\t\tvar self = this;\n\t\t\tvar xscroll = self.xscroll;\n\t\t\tself.isLoading = false;\n\t\t\tself._changeStatus(\"up\");\n\t\t\treturn self;\n\t\t}\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = PullUp;\n\t}\n\t/** ignored by jsdoc **/\n\telse if (window.XScroll && window.XScroll.Plugins) {\n\t\treturn XScroll.Plugins.PullUp = PullUp;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t  Base = __webpack_require__(2),\n\t  Core = __webpack_require__(8),\n\t  Animate = __webpack_require__(3),\n\t  Hammer = __webpack_require__(6),\n\t  ScrollBar = __webpack_require__(22),\n\t  Controller = __webpack_require__(20);\n\t//reduced boundry pan distance\n\tvar PAN_RATE = 1 - 0.618;\n\t//constant for scrolling acceleration\n\tvar SCROLL_ACCELERATION = 0.0005;\n\t//constant for outside of boundry acceleration\n\tvar BOUNDRY_ACCELERATION = 0.03;\n\t//transform-origin\n\tvar transformOrigin = Util.prefixStyle(\"transformOrigin\");\n\t//transform\n\tvar transform = Util.prefixStyle(\"transform\");\n\t/** \n\t * @constructor\n\t * @param {object} cfg config for scroll\n\t * @param {number} cfg.SCROLL_ACCELERATION  acceleration for scroll, min value make the scrolling smoothly\n\t * @param {number} cfg.BOUNDRY_CHECK_DURATION duration for boundry bounce\n\t * @param {number} cfg.BOUNDRY_CHECK_EASING easing for boundry bounce\n\t * @param {number} cfg.BOUNDRY_CHECK_ACCELERATION acceleration for boundry bounce\n\t * @param {boolean} cfg.lockX just like overflow-x:hidden\n\t * @param {boolean} cfg.lockY just like overflow-y:hidden\n\t * @param {boolean} cfg.scrollbarX config if the scrollbar-x is visible\n\t * @param {boolean} cfg.scrollbarY config if the scrollbar-y is visible\n\t * @param {boolean} cfg.useTransition config if use css3 transition or raf for scroll animation\n\t * @param {boolean} cfg.bounce config if use has the bounce effect when scrolling outside of the boundry\n\t * @param {boolean} cfg.boundryCheck config if scrolling inside of the boundry\n\t * @param {boolean} cfg.preventDefault prevent touchstart\n\t * @param {boolean} cfg.preventTouchMove prevent touchmove\n\t * @param {string|HTMLElement}  cfg.container config for scroller's container which default value is \".xs-container\"\n\t * @param {string|HTMLElement}  cfg.content config for scroller's content which default value is \".xs-content\"\n\t * @param {object}  cfg.indicatorInsets  config scrollbars position {top: number, left: number, bottom: number, right: number}\n\t * @param {string}  cfg.stickyElements config for sticky-positioned elements\n\t * @param {string}  cfg.fixedElements config for fixed-positioned elements\n\t * @param {string}  cfg.touchAction config for touchAction of the scroller\n\t * @extends XScroll\n\t * @example\n\t * var xscroll = new SimuScroll({\n\t *    renderTo:\"#scroll\",\n\t *    lockX:false,\n\t *    scrollbarX:true\n\t * });\n\t * xscroll.render();\n\t */\n\tfunction SimuScroll(cfg) {\n\t  SimuScroll.superclass.constructor.call(this, cfg);\n\t}\n\t\n\tUtil.extend(SimuScroll, Core, {\n\t  /** \n\t   * @memberof SimuScroll\n\t   * @override\n\t   */\n\t  init: function() {\n\t    var self = this;\n\t    var defaultCfg = {\n\t      preventDefault: true,\n\t      preventTouchMove: true\n\t    };\n\t    SimuScroll.superclass.init.call(this);\n\t    self.userConfig = Util.mix(defaultCfg, self.userConfig);\n\t    self.SCROLL_ACCELERATION = self.userConfig.SCROLL_ACCELERATION || SCROLL_ACCELERATION;\n\t    self.BOUNDRY_ACCELERATION = self.userConfig.BOUNDRY_ACCELERATION || BOUNDRY_ACCELERATION;\n\t    self._initContainer();\n\t    self.resetSize();\n\t    //set overflow behaviors\n\t    self._setOverflowBehavior();\n\t    self.defaltConfig = {\n\t      lockY: self.userConfig.lockY,\n\t      lockX: self.userConfig.lockX\n\t    }\n\t    return self;\n\t  },\n\t  destroy: function() {\n\t    var self = this;\n\t    SimuScroll.superclass.destroy.call(this);\n\t    self.renderTo.style.overflow = \"\";\n\t    self.renderTo.style.touchAction = \"\";\n\t    self.container.style.transform = \"\";\n\t    self.container.style.transformOrigin = \"\";\n\t    self.content.style.transform = \"\";\n\t    self.content.style.transformOrigin = \"\";\n\t    self.off(\"touchstart mousedown\", self._ontouchstart);\n\t    self.off(\"touchmove\", self._ontouchmove);\n\t    self.destroyScrollBars();\n\t  },\n\t  /**\n\t   * set overflow behavior\n\t   * @return {boolean} [description]\n\t   */\n\t  _setOverflowBehavior: function() {\n\t    var self = this;\n\t    var renderTo = self.renderTo;\n\t    var computeStyle = getComputedStyle(renderTo);\n\t    self.userConfig.lockX = undefined === self.userConfig.lockX ? ((computeStyle['overflow-x'] == \"hidden\" || self.width == self.containerWidth) ? true : false) : self.userConfig.lockX;\n\t    self.userConfig.lockY = undefined === self.userConfig.lockY ? ((computeStyle['overflow-y'] == \"hidden\" || self.height == self.containerHeight) ? true : false) : self.userConfig.lockY;\n\t    self.userConfig.scrollbarX = undefined === self.userConfig.scrollbarX ? (self.userConfig.lockX ? false : true) : self.userConfig.scrollbarX;\n\t    self.userConfig.scrollbarY = undefined === self.userConfig.scrollbarY ? (self.userConfig.lockY ? false : true) : self.userConfig.scrollbarY;\n\t    return self;\n\t  },\n\t  /**\n\t   * reset lockX or lockY config to the default value\n\t   */\n\t  _resetLockConfig: function() {\n\t    var self = this;\n\t    self.userConfig.lockX = self.defaltConfig.lockX;\n\t    self.userConfig.lockY = self.defaltConfig.lockY;\n\t    return self;\n\t  },\n\t  /**\n\t   * init container\n\t   * @override\n\t   * @return {SimuScroll}\n\t   */\n\t  _initContainer: function() {\n\t    var self = this;\n\t    SimuScroll.superclass._initContainer.call(self);\n\t    if (self.__isContainerInited || !self.container || !self.content) return;\n\t    self.container.style[transformOrigin] = \"0 0\";\n\t    self.content.style[transformOrigin] = \"0 0\";\n\t    self.translate(0, 0);\n\t    self.__isContainerInited = true;\n\t    return self;\n\t  },\n\t  /**\n\t   * get scroll top value\n\t   * @memberof SimuScroll\n\t   * @return {number} scrollTop\n\t   */\n\t  getScrollTop: function() {\n\t    var transY = window.getComputedStyle(this.container)[transform].match(/[-\\d\\.*\\d*]+/g);\n\t    return transY ? Math.round(transY[5]) === 0 ? 0 : -Math.round(transY[5]) : 0;\n\t  },\n\t  /**\n\t   * get scroll left value\n\t   * @memberof SimuScroll\n\t   * @return {number} scrollLeft\n\t   */\n\t  getScrollLeft: function() {\n\t    var transX = window.getComputedStyle(this.content)[transform].match(/[-\\d\\.*\\d*]+/g);\n\t    return transX ? Math.round(transX[4]) === 0 ? 0 : -Math.round(transX[4]) : 0;\n\t  },\n\t  /**\n\t   * horizontal scroll absolute to the destination\n\t   * @memberof SimuScroll\n\t   * @param scrollLeft {number} scrollLeft\n\t   * @param duration {number} duration for animte\n\t   * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t   **/\n\t  scrollLeft: function(x, duration, easing, callback) {\n\t    if (this.userConfig.lockX) return;\n\t    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t    this.x = (undefined === x || isNaN(x) || 0 === x) ? 0 : -Math.round(x);\n\t    this._animate(\"x\", \"translateX(\" + this.x + \"px) scale(\" + this.scale + \")\" + translateZ, duration, easing, callback);\n\t    return this;\n\t  },\n\t  /**\n\t   * vertical scroll absolute to the destination\n\t   * @memberof SimuScroll\n\t   * @param scrollTop {number} scrollTop\n\t   * @param duration {number} duration for animte\n\t   * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n\t   **/\n\t  scrollTop: function(y, duration, easing, callback) {\n\t    if (this.userConfig.lockY) return;\n\t    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t    this.y = (undefined === y || isNaN(y) || 0 === y) ? 0 : -Math.round(y);\n\t    this._animate(\"y\", \"translateY(\" + this.y + \"px) \" + translateZ, duration, easing, callback);\n\t    return this;\n\t  },\n\t  /**\n\t   * translate the scroller to a new destination includes x , y , scale\n\t   * @memberof SimuScroll\n\t   * @param x {number} x\n\t   * @param y {number} y\n\t   * @param scale {number} scale\n\t   **/\n\t  translate: function(x, y, scale) {\n\t    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t    this.x = x || this.x || 0;\n\t    this.y = y || this.y || 0;\n\t    this.scale = scale || this.scale || 1;\n\t    this.content.style[transform] = \"translate(\" + this.x + \"px,0px) scale(\" + this.scale + \") \" + translateZ;\n\t    this.container.style[transform] = \"translate(0px,\" + this.y + \"px) \" + translateZ;\n\t    return this;\n\t  },\n\t  _animate: function(type, transform, duration, easing, callback) {\n\t    var self = this;\n\t    var duration = duration || 0;\n\t    var easing = easing || \"quadratic\";\n\t    var el = type == \"y\" ? self.container : self.content;\n\t    var config = {\n\t      css: {\n\t        transform: transform\n\t      },\n\t      duration: duration,\n\t      easing: easing,\n\t      run: function(e) {\n\t        /**\n\t         * @event {@link SimuScroll#\"scroll\"}\n\t         */\n\t        self.trigger(\"scroll\", {\n\t          scrollTop: self.getScrollTop(),\n\t          scrollLeft: self.getScrollLeft(),\n\t          type: \"scroll\"\n\t        });\n\t      },\n\t      useTransition: self.userConfig.useTransition,\n\t      end: function(e) {\n\t        callback && callback();\n\t        if ((self[\"_bounce\" + type] === 0 || self[\"_bounce\" + type] === undefined) && easing != \"linear\") {\n\t          self['isScrolling' + type.toUpperCase()] = false;\n\t          self['isRealScrolling' + type.toUpperCase()] = false;\n\t          self.trigger(\"scrollend\", {\n\t            type: \"scrollend\",\n\t            scrollTop: self.getScrollTop(),\n\t            scrollLeft: self.getScrollLeft(),\n\t            zoomType: type,\n\t            duration: duration,\n\t            easing: easing\n\t          });\n\t        }\n\t      }\n\t    };\n\t    var timer = self.__timers[type] = self.__timers[type] || new Animate(el, config);\n\t    timer.stop();\n\t    timer.reset(config);\n\t    timer.run();\n\t    self.trigger(\"scrollanimate\", {\n\t      type: \"scrollanimate\",\n\t      scrollTop: -self.y,\n\t      scrollLeft: -self.x,\n\t      duration: duration,\n\t      easing: easing,\n\t      zoomType: type\n\t    })\n\t    return this;\n\t  },\n\t  _ontap: function(e) {\n\t    var self = this;\n\t    self.boundryCheck();\n\t    self._unPreventHref(e);\n\t    if (!self.isRealScrollingX && !self.isRealScrollingY) {\n\t      self._triggerClick(e);\n\t    }\n\t    self._preventHref(e);\n\t    self.isRealScrollingY = false;\n\t    self.isRealScrollingY = false;\n\t  },\n\t  _bindEvt: function() {\n\t    SimuScroll.superclass._bindEvt.call(this);\n\t    var self = this;\n\t    if (self.__isEvtBind) return;\n\t    self.__isEvtBind = true;\n\t    var pinch = new Hammer.Pinch();\n\t    self.mc.add(pinch);\n\t    self.on(\"touchstart mousedown\", self._ontouchstart, self);\n\t    self.on(\"touchmove\", self._ontouchmove, self);\n\t    self.on(\"tap\", self._ontap, self);\n\t    self.on(\"panstart\", self._onpanstart, self);\n\t    self.on(\"pan\", self._onpan, self);\n\t    self.on(\"panend\", self._onpanend, self);\n\t    //window resize\n\t    window.addEventListener(\"resize\", function(e) {\n\t      setTimeout(function() {\n\t        self.resetSize();\n\t        self.boundryCheck(0);\n\t        self.render();\n\t      }, 100);\n\t    }, self);\n\t\n\t    return this;\n\t  },\n\t  _ontouchstart: function(e) {\n\t    var self = this;\n\t    if (!(/(SELECT|INPUT|TEXTAREA)/i).test(e.target.tagName) && self.userConfig.preventDefault) {\n\t      e.preventDefault();\n\t    }\n\t    self.stop();\n\t  },\n\t  _ontouchmove: function(e) {\n\t    this.userConfig.preventTouchMove && e.preventDefault();\n\t  },\n\t  _onpanstart: function(e) {\n\t    this.userConfig.preventTouchMove && e.preventDefault();\n\t    var self = this;\n\t    var scrollLeft = self.getScrollLeft();\n\t    var scrollTop = self.getScrollTop();\n\t    self.stop();\n\t    self.translate(-scrollLeft, -scrollTop);\n\t    var threshold = self.mc.get(\"pan\").options.threshold;\n\t    self.thresholdY = e.direction == \"8\" ? threshold : e.direction == \"16\" ? -threshold : 0;\n\t    self.thresholdX = e.direction == \"2\" ? threshold : e.direction == \"4\" ? -threshold : 0;\n\t    return self;\n\t  },\n\t  _onpan: function(e) {\n\t    this.userConfig.preventTouchMove && e.preventDefault();\n\t    var self = this;\n\t    var boundry = self.boundry;\n\t    var userConfig = self.userConfig;\n\t    var boundryCheck = userConfig.boundryCheck;\n\t    var bounce = userConfig.bounce;\n\t    var scrollTop = self.__topstart || (self.__topstart = -self.getScrollTop());\n\t    var scrollLeft = self.__leftstart || (self.__leftstart = -self.getScrollLeft());\n\t    var y = userConfig.lockY ? Number(scrollTop) : Number(scrollTop) + (e.deltaY + self.thresholdY);\n\t    var x = userConfig.lockX ? Number(scrollLeft) : Number(scrollLeft) + (e.deltaX + self.thresholdX);\n\t    var containerWidth = self.containerWidth;\n\t    var containerHeight = self.containerHeight;\n\t    if (boundryCheck) {\n\t      //over top\n\t      y = y > boundry.top ? bounce ? (y - boundry.top) * PAN_RATE + boundry.top : boundry.top : y;\n\t      //over bottom\n\t      y = y < boundry.bottom - containerHeight ? bounce ? y + (boundry.bottom - containerHeight - y) * PAN_RATE : boundry.bottom - containerHeight : y;\n\t      //over left\n\t      x = x > boundry.left ? bounce ? (x - boundry.left) * PAN_RATE + boundry.left : boundry.left : x;\n\t      //over right\n\t      x = x < boundry.right - containerWidth ? bounce ? x + (boundry.right - containerWidth - x) * PAN_RATE : boundry.right - containerWidth : x;\n\t    }\n\t    //move to x,y\n\t    self.translate(x, y);\n\t    //pan trigger the opposite direction\n\t    self.directionX = e.type == 'panleft' ? 'right' : e.type == 'panright' ? 'left' : '';\n\t    self.directionY = e.type == 'panup' ? 'down' : e.type == 'pandown' ? 'up' : '';\n\t    self.trigger(\"scroll\", {\n\t      scrollTop: -y,\n\t      scrollLeft: -x,\n\t      triggerType: \"pan\",\n\t      type: \"scroll\"\n\t    });\n\t    return self;\n\t  },\n\t  _onpanend: function(e) {\n\t    var self = this;\n\t    var userConfig = self.userConfig;\n\t    var transX = self.computeScroll(\"x\", e.velocityX);\n\t    var transY = self.computeScroll(\"y\", e.velocityY);\n\t    var scrollLeft = transX ? transX.pos : 0;\n\t    var scrollTop = transY ? transY.pos : 0;\n\t    var duration;\n\t    if (transX && transY && transX.status == \"inside\" && transY.status == \"inside\" && transX.duration && transY.duration) {\n\t      //ensure the same duration\n\t      duration = Math.max(transX.duration, transY.duration);\n\t    }\n\t    transX && self.scrollLeft(scrollLeft, duration || transX.duration, transX.easing, function(e) {\n\t      self.boundryCheckX();\n\t    });\n\t    transY && self.scrollTop(scrollTop, duration || transY.duration, transY.easing, function(e) {\n\t      self.boundryCheckY();\n\t    });\n\t    //judge the direction\n\t    self.directionX = e.velocityX < 0 ? \"left\" : \"right\";\n\t    self.directionY = e.velocityY < 0 ? \"up\" : \"down\";\n\t    //clear start\n\t    self.__topstart = null;\n\t    self.__leftstart = null;\n\t    return self;\n\t  },\n\t  /**\n\t   * judge the scroller is out of boundry horizontally and vertically\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOut: function() {\n\t    return this.isBoundryOutLeft() || this.isBoundryOutRight() || this.isBoundryOutTop() || this.isBoundryOutBottom();\n\t  },\n\t  /**\n\t   * judge if the scroller is outsideof left\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOutLeft: function() {\n\t    return this.getBoundryOutLeft() > 0 ? true : false;\n\t  },\n\t  /**\n\t   * judge if the scroller is outsideof right\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOutRight: function() {\n\t    return this.getBoundryOutRight() > 0 ? true : false;\n\t  },\n\t  /**\n\t   * judge if the scroller is outsideof top\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOutTop: function() {\n\t    return this.getBoundryOutTop() > 0 ? true : false;\n\t  },\n\t  /**\n\t   * judge if the scroller is outsideof bottom\n\t   * @memberof SimuScroll\n\t   * @return {boolean} isBoundryOut\n\t   **/\n\t  isBoundryOutBottom: function() {\n\t    return this.getBoundryOutBottom() > 0 ? true : false;\n\t  },\n\t  /**\n\t   * get the offset value outsideof top\n\t   * @memberof SimuScroll\n\t   * @return {number} offset\n\t   **/\n\t  getBoundryOutTop: function() {\n\t    return -this.boundry.top - this.getScrollTop();\n\t  },\n\t  /**\n\t   * get the offset value outsideof left\n\t   * @memberof SimuScroll\n\t   * @return {number} offset\n\t   **/\n\t  getBoundryOutLeft: function() {\n\t    return -this.boundry.left - this.getScrollLeft();\n\t  },\n\t  /**\n\t   * get the offset value outsideof bottom\n\t   * @memberof SimuScroll\n\t   * @return {number} offset\n\t   **/\n\t  getBoundryOutBottom: function() {\n\t    return this.boundry.bottom - this.containerHeight + this.getScrollTop();\n\t  },\n\t  /**\n\t   * get the offset value outsideof right\n\t   * @memberof SimuScroll\n\t   * @return {number} offset\n\t   **/\n\t  getBoundryOutRight: function() {\n\t    return this.boundry.right - this.containerWidth + this.getScrollLeft();\n\t  },\n\t  /**\n\t   * compute scroll transition by zoomType and velocity\n\t   * @memberof SimuScroll\n\t   * @param {string} zoomType zoomType of scrolling\n\t   * @param {number} velocity velocity after panend\n\t   * @example\n\t   * var info = xscroll.computeScroll(\"x\",2);\n\t   * // return {pos:90,easing:\"easing\",status:\"inside\",duration:500}\n\t   * @return {Object}\n\t   **/\n\t  computeScroll: function(type, v) {\n\t    var self = this;\n\t    var userConfig = self.userConfig;\n\t    var boundry = self.boundry;\n\t    var pos = type == \"x\" ? self.getScrollLeft() : self.getScrollTop();\n\t    var boundryStart = type == \"x\" ? boundry.left : boundry.top;\n\t    var boundryEnd = type == \"x\" ? boundry.right : boundry.bottom;\n\t    var innerSize = type == \"x\" ? self.containerWidth : self.containerHeight;\n\t    var maxSpeed = userConfig.maxSpeed || 2;\n\t    var boundryCheck = userConfig.boundryCheck;\n\t    var bounce = userConfig.bounce;\n\t    var transition = {};\n\t    var status = \"inside\";\n\t    if (boundryCheck) {\n\t      if (type == \"x\" && (self.isBoundryOutLeft() || self.isBoundryOutRight())) {\n\t        self.boundryCheckX();\n\t        return;\n\t      } else if (type == \"y\" && (self.isBoundryOutTop() || self.isBoundryOutBottom())) {\n\t        self.boundryCheckY();\n\t        return;\n\t      }\n\t    }\n\t    if (type == \"x\" && self.userConfig.lockX) return;\n\t    if (type == \"y\" && self.userConfig.lockY) return;\n\t    v = v > maxSpeed ? maxSpeed : v < -maxSpeed ? -maxSpeed : v;\n\t    var a = self.SCROLL_ACCELERATION * (v / (Math.abs(v) || 1));\n\t    var a2 = self.BOUNDRY_ACCELERATION;\n\t    var t = isNaN(v / a) ? 0 : v / a;\n\t    var s = Number(pos) + t * v / 2;\n\t    //over top boundry check bounce\n\t    if (s < -boundryStart && boundryCheck) {\n\t      var _s = -boundryStart - pos;\n\t      var _t = (Math.sqrt(-2 * a * _s + v * v) + v) / a;\n\t      var v0 = v - a * _t;\n\t      var _t2 = Math.abs(v0 / a2);\n\t      var s2 = v0 / 2 * _t2;\n\t      t = _t + _t2;\n\t      s = bounce ? -boundryStart + s2 : -boundryStart;\n\t      status = \"outside\";\n\t    } else if (s > innerSize - boundryEnd && boundryCheck) {\n\t      var _s = (boundryEnd - innerSize) + pos;\n\t      var _t = (Math.sqrt(-2 * a * _s + v * v) - v) / a;\n\t      var v0 = v - a * _t;\n\t      var _t2 = Math.abs(v0 / a2);\n\t      var s2 = v0 / 2 * _t2;\n\t      t = _t + _t2;\n\t      s = bounce ? innerSize - boundryEnd + s2 : innerSize - boundryEnd;\n\t      status = \"outside\";\n\t    }\n\t    if (isNaN(s) || isNaN(t)) return;\n\t    transition.pos = s;\n\t    transition.duration = t;\n\t    transition.easing = Math.abs(v) > 2 ? \"circular\" : \"quadratic\";\n\t    transition.status = status;\n\t    var Type = type.toUpperCase();\n\t    self['isScrolling' + Type] = true;\n\t    self['isRealScrolling' + Type] = true;\n\t    return transition;\n\t  },\n\t  /**\n\t   * bounce to the boundry horizontal\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  boundryCheckX: function(duration, easing, callback) {\n\t    var self = this;\n\t    if (!self.userConfig.boundryCheck) return;\n\t    if (typeof arguments[0] == \"function\") {\n\t      callback = arguments[0];\n\t      duration = self.userConfig.BOUNDRY_CHECK_DURATION;\n\t      easing = self.userConfig.BOUNDRY_CHECK_EASING;\n\t    } else {\n\t      duration = duration === 0 ? 0 : self.userConfig.BOUNDRY_CHECK_DURATION,\n\t        easing = easing || self.userConfig.BOUNDRY_CHECK_EASING;\n\t    }\n\t    if (!self.userConfig.bounce || self.userConfig.lockX) return;\n\t    var boundry = self.boundry;\n\t    if (self.isBoundryOutLeft()) {\n\t      self.scrollLeft(-boundry.left, duration, easing, callback);\n\t    } else if (self.isBoundryOutRight()) {\n\t      self.scrollLeft(self.containerWidth - boundry.right, duration, easing, callback);\n\t    }\n\t    return self;\n\t  },\n\t  /**\n\t   * bounce to the boundry vertical\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  boundryCheckY: function(duration, easing, callback) {\n\t    var self = this;\n\t    if (!self.userConfig.boundryCheck) return;\n\t    if (typeof arguments[0] == \"function\") {\n\t      callback = arguments[0];\n\t      duration = self.userConfig.BOUNDRY_CHECK_DURATION;\n\t      easing = self.userConfig.BOUNDRY_CHECK_EASING;\n\t    } else {\n\t      duration = duration === 0 ? 0 : self.userConfig.BOUNDRY_CHECK_DURATION,\n\t        easing = easing || self.userConfig.BOUNDRY_CHECK_EASING;\n\t    }\n\t    if (!self.userConfig.boundryCheck || self.userConfig.lockY) return;\n\t    var boundry = self.boundry;\n\t    if (self.isBoundryOutTop()) {\n\t      self.scrollTop(-boundry.top, duration, easing, callback);\n\t    } else if (self.isBoundryOutBottom()) {\n\t      self.scrollTop(self.containerHeight - boundry.bottom, duration, easing, callback);\n\t    }\n\t    return self;\n\t  },\n\t  /**\n\t   * bounce to the boundry vertical and horizontal\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  boundryCheck: function(duration, easing, callback) {\n\t    this.boundryCheckX(duration, easing, callback);\n\t    this.boundryCheckY(duration, easing, callback);\n\t    return this;\n\t  },\n\t  /**\n\t   * stop scrolling immediatelly\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  stop: function() {\n\t    var self = this;\n\t    self.__timers.x && self.__timers.x.stop();\n\t    self.__timers.y && self.__timers.y.stop();\n\t    if (self.isScrollingX || self.isScrollingY) {\n\t      var scrollTop = self.getScrollTop(),\n\t        scrollLeft = self.getScrollLeft();\n\t      self.trigger(\"scrollend\", {\n\t        scrollTop: scrollTop,\n\t        scrollLeft: scrollLeft\n\t      });\n\t      self.trigger(\"stop\", {\n\t        scrollTop: scrollTop,\n\t        scrollLeft: scrollLeft\n\t      })\n\t      self.isScrollingX = false;\n\t      self.isScrollingY = false;\n\t    }\n\t    return self;\n\t  },\n\t  /**\n\t   * render scroll\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   **/\n\t  render: function() {\n\t    var self = this;\n\t    SimuScroll.superclass.render.call(this);\n\t    //fixed for scrollbars\n\t    if (getComputedStyle(self.renderTo).position == \"static\") {\n\t      self.renderTo.style.position = \"relative\";\n\t    }\n\t    self.renderTo.style.overflow = \"hidden\";\n\t    self.initScrollBars();\n\t    self.initController();\n\t    return self;\n\t  },\n\t  /**\n\t   * init scrollbars\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   */\n\t  initScrollBars: function() {\n\t    var self = this;\n\t    if (!self.userConfig.boundryCheck) return;\n\t    var indicatorInsets = self.userConfig.indicatorInsets;\n\t    if (self.userConfig.scrollbarX) {\n\t      self.scrollbarX = self.scrollbarX || new ScrollBar({\n\t        xscroll: self,\n\t        type: \"x\",\n\t        spacing: indicatorInsets.spacing\n\t      });\n\t      self.scrollbarX.render();\n\t      self.scrollbarX._update();\n\t      self.scrollbarX.hide();\n\t    }\n\t    if (self.userConfig.scrollbarY) {\n\t      self.scrollbarY = self.scrollbarY || new ScrollBar({\n\t        xscroll: self,\n\t        type: \"y\",\n\t        spacing: indicatorInsets.spacing\n\t      });\n\t      self.scrollbarY.render();\n\t      self.scrollbarY._update();\n\t      self.scrollbarY.hide();\n\t    }\n\t    return self;\n\t  },\n\t  /**\n\t   * destroy scrollbars\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   */\n\t  destroyScrollBars: function() {\n\t    this.scrollbarX && this.scrollbarX.destroy();\n\t    this.scrollbarY && this.scrollbarY.destroy();\n\t    return this;\n\t  },\n\t  /**\n\t   * init controller for multi-scrollers\n\t   * @memberof SimuScroll\n\t   * @return {SimuScroll}\n\t   */\n\t  initController: function() {\n\t    var self = this;\n\t    self.controller = self.controller || new Controller({\n\t      xscroll: self\n\t    });\n\t    return self;\n\t  },\n\t  _unPreventHref: function(e) {\n\t    var target = Util.findParentEl(e.target,'a',this.renderTo);\n\t    if(!target) return;\n\t    if (target.tagName.toLowerCase() == \"a\") {\n\t      var href = target.getAttribute(\"data-xs-href\");\n\t      if (href) {\n\t        target.setAttribute(\"href\", href);\n\t      }\n\t    }\n\t  },\n\t  _preventHref: function(e) {\n\t    var target = Util.findParentEl(e.target,'a',this.renderTo);\n\t    if(!target) return;\n\t    if (target.tagName.toLowerCase() == \"a\") {\n\t      var href = target.getAttribute(\"href\");\n\t      href && target.setAttribute(\"href\", \"javascript:void(0)\");\n\t      href && target.setAttribute(\"data-xs-href\", href);\n\t    }\n\t  },\n\t  _triggerClick: function(e) {\n\t    var target = e.target;\n\t    if (!(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName)) {\n\t      var ev = document.createEvent('MouseEvents');\n\t      ev.initMouseEvent('click', true, true, e.view, 1,\n\t        target.screenX, target.screenY, target.clientX, target.clientY,\n\t        e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,\n\t        0, null);\n\t      target.dispatchEvent(ev);\n\t    }\n\t  }\n\t});\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t  module.exports = SimuScroll;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t  return SimuScroll;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = function(require, exports, module) {\n\t\"use strict\";\n\tvar Util = __webpack_require__(1),\n\t\tBase = __webpack_require__(2),\n\t\tTimer = __webpack_require__(10),\n\t\tAnimate = __webpack_require__(3),\n\t\tHammer = __webpack_require__(6),\n\t\tSimuScroll = __webpack_require__(29),\n\t\tOriginScroll = __webpack_require__(25);\n\tvar XScroll = function(cfg) {\n\t\t\tvar _ = cfg && cfg.useOriginScroll ? OriginScroll : SimuScroll;\n\t\t\treturn new _(cfg);\n\t\t}\n\t/**\n\t * Util\n\t * @namespace Util\n\t * @type {Object}\n\t */\n\tXScroll.Util = Util;\n\t/**\n\t * Base\n\t * @namespace Base\n\t * @type {Base}\n\t */\n\tXScroll.Base = Base;\n\t/**\n\t * Timer\n\t * @namespace Timer\n\t * @type {Timer}\n\t */\n\tXScroll.Timer = Timer;\n\t/**\n\t * Animate\n\t * @namespace Animate\n\t * @type {Animate}\n\t */\n\tXScroll.Animate = Animate;\n\t/**\n\t * Hammer\n\t * @namespace Hammer\n\t * @type {Hammer}\n\t */\n\tXScroll.Hammer = Hammer;\n\t/**\n\t * plugins\n\t * @namespace Plugins\n\t * @type {Object}\n\t */\n\tXScroll.Plugins = {};\n\t\n\tif (typeof module == 'object' && module.exports) {\n\t\tmodule.exports = XScroll;\n\t}\n\t/** ignored by jsdoc **/\n\telse {\n\t\treturn window.XScroll = XScroll;\n\t}\n\t}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_31__;\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_32__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// react-xscroll.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 08ca850a72b0fde7077e","import ReactXScroll from 'components/react-xscroll';\nimport ReactXScrollCtrl from 'components/react-xscroll-ctrl';\nmodule.exports = {\n  ReactXScroll,\n  ReactXScrollCtrl\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","define(function(require, exports, module) {\n\"use strict\";\nvar SUBSTITUTE_REG = /\\\\?\\{([^{}]+)\\}/g,\n\tEMPTY = '';\n\nvar RE_TRIM = /^[\\s\\xa0]+|[\\s\\xa0]+$/g,\n\ttrim = String.prototype.trim;\n\nvar _trim = trim ?\n\tfunction(str) {\n\t\treturn str == null ? EMPTY : trim.call(str);\n\t} : function(str) {\n\t\treturn str == null ? EMPTY : (str + '').replace(RE_TRIM, EMPTY);\n\t};\n\nfunction upperCase() {\n\treturn arguments[1].toUpperCase();\n}\n\nfunction Empty() {}\n\nfunction createObject(proto, constructor) {\n\tvar newProto;\n\tif (Object.create) {\n\t\tnewProto = Object.create(proto);\n\t} else {\n\t\tEmpty.prototype = proto;\n\t\tnewProto = new Empty();\n\t}\n\tnewProto.constructor = constructor;\n\treturn newProto;\n}\n\nfunction getNodes(node, rootNode) {\n\tif (!node) return;\n\tif (node.nodeType) return [node];\n\tvar rootNode = rootNode && rootNode.nodeType ? rootNode : document;\n\tif (node && typeof node === \"string\") {\n\t\treturn rootNode.querySelectorAll(node);\n\t}\n\treturn;\n}\n\n// Useful for temporary DOM ids.\nvar idCounter = 0;\n\nvar getOffsetTop = function(el) {\n\tvar offset = el.offsetTop;\n\tif (el.offsetParent != null) offset += getOffsetTop(el.offsetParent);\n\treturn offset;\n};\nvar getOffsetLeft = function(el) {\n\tvar offset = el.offsetLeft;\n\tif (el.offsetParent != null) offset += getOffsetLeft(el.offsetParent);\n\treturn offset;\n};\n\nvar Util = {\n\t// Is a given variable an object?\n\tisObject: function(obj) {\n\t\treturn obj === Object(obj);\n\t},\n\tisArray: Array.isArray || function(obj) {\n\t\treturn toString.call(obj) == '[object Array]';\n\t},\n\t// Is a given array, string, or object empty?\n\t// An \"empty\" object has no enumerable own-properties.\n\tisEmpty: function(obj) {\n\t\tif (obj == null) return true;\n\t\tif (this.isArray(obj) || this.isString(obj)) return obj.length === 0;\n\t\tfor (var key in obj)\n\t\t\tif (this.has(obj, key)) return false;\n\t\treturn true;\n\t},\n\tmix: function(to, from, deep) {\n\t\tfor (var i in from) {\n\t\t\tto[i] = from[i];\n\t\t}\n\t\treturn to;\n\t},\n\textend: function(r, s, px, sx) {\n\t\tif (!s || !r) {\n\t\t\treturn r;\n\t\t}\n\t\tvar sp = s.prototype,\n\t\t\trp;\n\t\t// add prototype chain\n\t\trp = createObject(sp, r);\n\t\tr.prototype = this.mix(rp, r.prototype);\n\t\tr.superclass = createObject(sp, s);\n\t\t// add prototype overrides\n\t\tif (px) {\n\t\t\tthis.mix(rp, px);\n\t\t}\n\t\t// add object overrides\n\t\tif (sx) {\n\t\t\tthis.mix(r, sx);\n\t\t}\n\t\treturn r;\n\t},\n\t/**\n\t * test whether a string start with a specified substring\n\t * @param {String} str the whole string\n\t * @param {String} prefix a specified substring\n\t * @return {Boolean} whether str start with prefix\n\t * @member util\n\t */\n\tstartsWith: function(str, prefix) {\n\t\treturn str.lastIndexOf(prefix, 0) === 0;\n\t},\n\n\t/**\n\t * test whether a string end with a specified substring\n\t * @param {String} str the whole string\n\t * @param {String} suffix a specified substring\n\t * @return {Boolean} whether str end with suffix\n\t * @member util\n\t */\n\tendsWith: function(str, suffix) {\n\t\tvar ind = str.length - suffix.length;\n\t\treturn ind >= 0 && str.indexOf(suffix, ind) === ind;\n\t},\n\t/**\n\t * Removes the whitespace from the beginning and end of a string.\n\t * @method\n\t * @member util\n\t */\n\ttrim: _trim,\n\t/**\n\t * Substitutes keywords in a string using an object/array.\n\t * Removes undef keywords and ignores escaped keywords.\n\t * @param {String} str template string\n\t * @param {Object} o json data\n\t * @member util\n\t * @param {RegExp} [regexp] to match a piece of template string\n\t */\n\tsubstitute: function(str, o, regexp) {\n\t\tif (typeof str !== 'string' || !o) {\n\t\t\treturn str;\n\t\t}\n\n\t\treturn str.replace(regexp || SUBSTITUTE_REG, function(match, name) {\n\t\t\tif (match.charAt(0) === '\\\\') {\n\t\t\t\treturn match.slice(1);\n\t\t\t}\n\t\t\treturn (o[name] === undefined) ? EMPTY : o[name];\n\t\t});\n\t},\n\t/**\n\t * vendors\n\t * @return { String } webkit|moz|ms|o\n\t * @memberOf Util\n\t */\n\tvendor: (function() {\n\t\tvar el = document.createElement('div').style;\n\t\tvar vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],\n\t\t\ttransform,\n\t\t\ti = 0,\n\t\t\tl = vendors.length;\n\t\tfor (; i < l; i++) {\n\t\t\ttransform = vendors[i] + 'ransform';\n\t\t\tif (transform in el) return vendors[i].substr(0, vendors[i].length - 1);\n\t\t}\n\t\treturn false;\n\t})(),\n\t/**\n\t *  add vendor to attribute\n\t *  @memberOf Util\n\t *  @param {String} attrName name of attribute\n\t *  @return { String }\n\t **/\n\tprefixStyle: function(attrName) {\n\t\tif (this.vendor === false) return false;\n\t\tif (this.vendor === '') return attrName;\n\t\treturn this.vendor + attrName.charAt(0).toUpperCase() + attrName.substr(1);\n\t},\n\t/**\n\t * judge if has class\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t * @param  {String}  className\n\t * @return {Boolean}\n\t */\n\thasClass: function(el, className) {\n\t\treturn el && el.className && className && el.className.indexOf(className) != -1;\n\t},\n\t/**\n\t * add className for the element\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t * @param  {String}  className\n\t */\n\taddClass: function(el, className) {\n\t\tif (el && className && !this.hasClass(el, className)) {\n\t\t\tel.className += \" \" + className;\n\t\t}\n\t},\n\t/**\n\t * remove className for the element\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t * @param  {String}  className\n\t */\n\tremoveClass: function(el, className) {\n\t\tif (el && el.className && className) {\n\t\t\tel.className = el.className.replace(className, \"\");\n\t\t}\n\t},\n\t/**\n\t * remove an element\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t */\n\tremove: function(el) {\n\t\tif (!el || !el.parentNode) return;\n\t\tel.parentNode.removeChild(el);\n\t},\n\t/**\n\t * get offset top\n\t * @memberOf Util\n\t * @param  {HTMLElement}   el\n\t * @return {Number} offsetTop\n\t */\n\tgetOffsetTop: getOffsetTop,\n\t/**\n\t * get offset left\n\t * @memberOf Util\n\t * @param  {HTMLElement}  el\n\t * @return {Number} offsetLeft\n\t */\n\tgetOffsetLeft: getOffsetLeft,\n\t/**\n\t * get offset left\n\t * @memberOf Util\n\t * @param  {HTMLElement} el\n\t * @param  {String} selector\n\t * @param  {HTMLElement} rootNode\n\t * @return {HTMLElement} parent element\n\t */\n\tfindParentEl: function(el, selector, rootNode) {\n\t\tvar rs = null,\n\t\t\tparent = null;\n\t\tvar type = /^#/.test(selector) ? \"id\" : /^\\./.test(selector) ? \"class\" : \"tag\";\n\t\tvar sel = selector.replace(/\\.|#/g, \"\");\n\t\tif (rootNode && typeof rootNode === \"string\") {\n\t\t\trootNode = document.querySelector(rootNode);\n\t\t}\n\t\trootNode = rootNode || document.body;\n\t\tif (!el || !selector) return;\n\t\tif (type == \"class\" && el.className && el.className.match(sel)) {\n\t\t\treturn el;\n\t\t} else if (type == \"id\" && el.id && _trim(el.id) == sel) {\n\t\t\treturn el;\n\t\t} else if (type == \"tag\" && el.tagName.toLowerCase() == sel) {\n\t\t\treturn el;\n\t\t}\n\t\twhile (!rs) {\n\t\t\tif (parent == rootNode) break;\n\t\t\tparent = el.parentNode;\n\t\t\tif (!parent) break;\n\t\t\tif ((type == \"class\" && parent.className && parent.className.match(sel)) || (type == \"id\" && parent.id && _trim(parent.id) == sel) || (type == \"tag\" && parent.tagName && parent.tagName.toLowerCase() == sel)) {\n\t\t\t\trs = parent\n\t\t\t\treturn rs;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tel = parent;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t},\n\t/**\n\t * Generate a unique integer id (unique within the entire client session).\n\t * @param  {String} prefix\n\t * @return {String} guid\n\t */\n\tguid: function(prefix) {\n\t\tvar id = ++idCounter + '';\n\t\treturn prefix ? prefix + id : id;\n\t},\n\t/**\n\t * judge if is an android os\n\t * @return {Boolean} [description]\n\t */\n\tisAndroid: function() {\n\t\treturn /Android /.test(window.navigator.appVersion);\n\t},\n\t/**\n\t * judge if is an android device with low  performance\n\t * @return {Boolean}\n\t */\n\tisBadAndroid: function() {\n\t\treturn /Android /.test(window.navigator.appVersion) && !(/Chrome\\/\\d/.test(window.navigator.appVersion))\n\t},\n\tpx2Num: function(px) {\n\t\treturn Number(px.replace(/px/, ''));\n\t},\n\tgetNodes: getNodes,\n\tgetNode: function(node, rootNode) {\n\t\tvar nodes = getNodes(node, rootNode);\n\t\treturn nodes && nodes[0];\n\t},\n\tstringifyStyle: function(style) {\n\t\tvar styleStr = \"\";\n\t\tfor (var i in style) {\n\t\t\tstyleStr += [i, \":\", style[i], \";\"].join(\"\");\n\t\t}\n\t\treturn styleStr;\n\t}\n}\n\n// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\nvar names = ['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'];\nfor (var i = 0; i < names.length; i++) {\n\tUtil['is' + names[i]] = function(obj) {\n\t\treturn toString.call(obj) == '[object ' + names[i] + ']';\n\t};\n}\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Util;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Util;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/util.js\n// module id = 1\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util');\nvar Events = require('./events');\n/** \n      @constructor \n      @mixes Events\n      */\nvar Base = function() {}\n\nUtil.mix(Base.prototype, Events);\n\nUtil.mix(Base.prototype, {\n\t/**\n\t * @memberof Base\n\t * @param  {object} plugin plug a plugin\n\t */\n\tplug: function(plugin) {\n\t\tvar self = this;\n\t\tif (!plugin || !plugin.pluginId) return;\n\t\tif (!self.__plugins) {\n\t\t\tself.__plugins = [];\n\t\t}\n\t\tvar __plugin = self.getPlugin(plugin.pluginId);\n\t\t__plugin && self.unplug(plugin.pluginId);\n\t\tplugin.pluginInitializer(self);\n\t\tself.__plugins.push(plugin);\n\t\treturn self;\n\t},\n\t/**\n\t * @memberof Base\n\t * @param  {object|string} plugin unplug a plugin by pluginId or plugin instance\n\t */\n\tunplug: function(plugin) {\n\t\tvar self = this;\n\t\tif (!plugin || !self.__plugins) return;\n\t\tvar _plugin = typeof plugin == \"string\" ? self.getPlugin(plugin) : plugin;\n\t\t_plugin.pluginDestructor(self);\n\t\tfor (var i = 0, l = self.__plugins.length;i < l;i++) {\n\t\t\tif (self.__plugins[i] == _plugin) {\n\t\t\t\treturn self.__plugins.splice(i, 1);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * @memberof Base\n\t * @param  {object|string} plugin get plugin by pluginId\n\t */\n\tgetPlugin: function(pluginId) {\n\t\tvar self = this;\n\t\tvar plugins = [];\n\t\tif(!self.__plugins) return;\n\t\tfor (var i = 0, l = self.__plugins.length;i < l;i++) {\n\t\t\tif (self.__plugins[i] && self.__plugins[i].pluginId == pluginId) {\n\t\t\t\tplugins.push(self.__plugins[i])\n\t\t\t}\n\t\t}\n\t\treturn plugins.length > 1 ? plugins : plugins[0] || null;\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Base;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Base;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/base.js\n// module id = 2\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util');\nvar Timer = require('./timer');\nvar Easing = require('./easing');\nvar Base = require('./base');\n//transform\nvar vendorTransform = Util.prefixStyle(\"transform\");\n//transition webkitTransition MozTransition OTransition msTtransition\nvar vendorTransition = Util.prefixStyle(\"transition\");\n\nvar vendorTransitionDuration = Util.prefixStyle(\"transitionDuration\");\n\nvar vendorTransformOrigin = Util.prefixStyle(\"transformOrigin\");\n\nvar vendorTransitionEnd = Util.vendor ? Util.prefixStyle(\"transitionEnd\") : \"transitionend\";\n\nvar vendorTransformStr = Util.vendor ? [\"-\", Util.vendor, \"-transform\"].join(\"\") : \"transform\";\n\nvar translateTpl = 'translateX({translateX}px) translateY({translateY}px) translateZ(0)';\n//limit attrs\nvar animAttrs = {\n\t'transform': true,\n\t'opacity': true,\n\t'scrollTop': true,\n\t'scrollLeft': true\n};\n\nfunction myParse(v) {\n\treturn Math.round(parseFloat(v) * 1e5) / 1e5;\n}\n\nfunction defaultDecompose() {\n\treturn {\n\t\ttranslateX: 0,\n\t\ttranslateY: 0,\n\t\trotate: 0,\n\t\tskewX: 0,\n\t\tskewY: 0,\n\t\tscaleX: 1,\n\t\tscaleY: 1\n\t};\n}\n\nfunction toMatrixArray(matrix) {\n\tmatrix = matrix.split(/,/);\n\tmatrix = Array.prototype.map.call(matrix, function(v) {\n\t\treturn myParse(v);\n\t});\n\treturn matrix;\n}\n\nfunction decomposeMatrix(matrix) {\n\tmatrix = toMatrixArray(matrix);\n\tvar scaleX, scaleY, skew,\n\t\tA = matrix[0],\n\t\tB = matrix[1],\n\t\tC = matrix[2],\n\t\tD = matrix[3];\n\n\t// Make sure matrix is not singular\n\tif (A * D - B * C) {\n\t\tscaleX = Math.sqrt(A * A + B * B);\n\t\tskew = (A * C + B * D) / (A * D - C * B);\n\t\tscaleY = (A * D - B * C) / scaleX;\n\t\t// step (6)\n\t\tif (A * D < B * C) {\n\t\t\tskew = -skew;\n\t\t\tscaleX = -scaleX;\n\t\t}\n\t\t// matrix is singular and cannot be interpolated\n\t} else {\n\t\t// In this case the elem shouldn't be rendered, hence scale == 0\n\t\tscaleX = scaleY = skew = 0;\n\t}\n\n\t// The recomposition order is very important\n\t// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971\n\treturn {\n\t\ttranslateX: myParse(matrix[4]),\n\t\ttranslateY: myParse(matrix[5]),\n\t\trotate: myParse(Math.atan2(B, A) * 180 / Math.PI),\n\t\tskewX: myParse(Math.atan(skew) * 180 / Math.PI),\n\t\tskewY: 0,\n\t\tscaleX: myParse(scaleX),\n\t\tscaleY: myParse(scaleY)\n\t};\n}\n\nfunction getTransformInfo(transform) {\n\ttransform = transform.split(')');\n\tvar trim = Util.trim,\n\t\ti = -1,\n\t\tl = transform.length - 1,\n\t\tsplit, prop, val,\n\t\tret = defaultDecompose();\n\n\t// Loop through the transform properties, parse and multiply them\n\twhile (++i < l) {\n\t\tsplit = transform[i].split('(');\n\t\tprop = trim(split[0]);\n\t\tval = split[1];\n\t\tswitch (prop) {\n\t\t\tcase 'translateX':\n\t\t\tcase 'translateY':\n\t\t\tcase 'scaleX':\n\t\t\tcase 'scaleY':\n\t\t\t\tret[prop] = myParse(val);\n\t\t\t\tbreak;\n\t\t\tcase 'translate':\n\t\t\tcase 'translate3d':\n\t\t\t\tval = val.split(',');\n\t\t\t\tret.translateX = myParse(val[0]);\n\t\t\t\tret.translateY = myParse(val[1] || 0);\n\t\t\t\tbreak;\n\t\t\tcase 'scale':\n\t\t\t\tval = val.split(',');\n\t\t\t\tret.scaleX = myParse(val[0]);\n\t\t\t\tret.scaleY = myParse(val[1] || val[0]);\n\t\t\t\tbreak;\n\t\t\tcase 'matrix':\n\t\t\t\treturn decomposeMatrix(val);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n/**\n * animate function\n * @constructor\n * @param {HTMLElement} el element to animate\n * @param {Object} config config for animate\n * @param {Object} config.css\n * @param {Number} config.duration\n * @param {String} config.easing\n * @extends {Base}\n */\nfunction Animate(el, cfg) {\n\tif (!el || !cfg || !cfg.css) return;\n\tvar self = this;\n\tself.cfg = cfg;\n\tself.el = el;\n\tvar duration = cfg.duration || 0,\n\t\teasing = cfg.easing || \"ease\",\n\t\tdelay = cfg.delay || 0;\n\t//trigger run\n\tif (cfg.run) {\n\t\t//frame animate\n\t\tself.timer = self.timer || new Timer({\n\t\t\tduration: Math.round(duration),\n\t\t\teasing: easing,\n\t\t});\n\t\tself.timer.on(\"run\", cfg.run);\n\t}\n\tself._bindEvt();\n\treturn self;\n}\n\nfunction computeTransform(prevTransform, destTransform) {\n\tvar transform = getTransformInfo(prevTransform);\n\tvar dest = getTransformInfo(destTransform);\n\tvar trans = {};\n\tfor (var i in dest) {\n\t\ttrans[i] = {\n\t\t\tprevVal: transform[i],\n\t\t\tnewVal: dest[i]\n\t\t}\n\t}\n\treturn trans;\n}\n\n//for scroll only\nfunction setStyle(el, styleName, prevVal, newVal, percent) {\n\tprevVal = isNaN(Number(prevVal)) ? 0 : Number(prevVal);\n\tvar curVal = ((newVal - prevVal) * percent + prevVal);\n\tcss(el, styleName, curVal);\n}\n\nfunction css(el, styleName, val) {\n\tswitch (styleName) {\n\t\tcase \"scrollTop\":\n\t\tcase \"scrollLeft\":\n\t\t\tel[styleName] = val;\n\t\t\tbreak;\n\t\tcase \"transform\":\n\t\t\tel.style[vendorTransform] = val;\n\t\tcase \"opacity\":\n\t\t\tel.style[styleName] = val;\n\t\t\tbreak;\n\n\t}\n}\n\nUtil.extend(Animate, Base, {\n\t/**\n\t * to start the animation\n\t * @memberof Animate\n\t * @return {Animate}\n\t */\n\trun: function() {\n\t\tvar self = this;\n\t\tvar cfg = self.cfg,\n\t\t\tel = self.el,\n\t\t\tduration = cfg.duration || 0,\n\t\t\teasing = cfg.easing || \"ease\",\n\t\t\tdelay = cfg.delay || 0;\n\t\tself.__isTransitionEnd = false;\n\t\tclearTimeout(self.__itv)\n\t\tself.timer && self.timer.run();\n\t\tif (duration <= Timer.MIN_DURATION) {\n\t\t\tfor (var i in cfg.css) {\n\t\t\t\tcss(el, i, cfg.css[i]);\n\t\t\t}\n\t\t\tself.stop()\n\t\t\tself.__handlers.stop.call(self);\n\t\t\treturn;\n\t\t}\n\n\t\tif(Util.isBadAndroid()){\n\t\t\t//use frame animate on bad android device\n\t\t\tcfg.useTransition = false;\n\t\t}\n\n\t\tif (cfg.useTransition) {\n\t\t\t//transition\n\t\t\tel.style[vendorTransition] = Util.substitute('all {duration}ms {easing} {delay}ms', {\n\t\t\t\tduration: Math.round(duration),\n\t\t\t\teasing: Easing.format(easing),\n\t\t\t\tdelay: delay\n\t\t\t});\n\t\t\tfor (var i in cfg.css) {\n\t\t\t\t//set css\n\t\t\t\tcss(el, i, cfg.css[i]);\n\t\t\t}\n\t\t\tself.__itv = setTimeout(function() {\n\t\t\t\tif (!self.__isTransitionEnd) {\n\t\t\t\t\tself.__isTransitionEnd = true;\n\t\t\t\t\tself.trigger(\"transitionend\");\n\t\t\t\t}\n\t\t\t}, Number(duration) + 60);\n\t\t} else {\n\t\t\tself.computeStyle = self.computeStyle || window.getComputedStyle(el);\n\t\t\t//transform\n\t\t\tif (cfg.css.transform && self.timer) {\n\t\t\t\tvar transmap = self.transmap = computeTransform(self.computeStyle[vendorTransform], cfg.css.transform);\n\t\t\t\tself.timer.off(\"run\", self.__handlers.transRun);\n\t\t\t\tself.timer.on(\"run\", self.__handlers.transRun, self);\n\t\t\t\tself.timer.off(\"end\",self.__handlers.transRun);\n\t\t\t\tself.timer.on(\"end\", self.__handlers.transRun, self);\n\t\t\t}\n\t\t}\n\t\treturn self;\n\t},\n\t_transitionEndHandler: function(e) {\n\t\tvar self = this;\n\t\tself.stop();\n\t\tself.__handlers.stop.call(self);\n\t},\n\t__handlers: {\n\t\ttransRun: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar transmap = self.transmap;\n\t\t\tvar el = self.el;\n\t\t\tvar newTrans = {};\n\t\t\tfor (var i in transmap) {\n\t\t\t\tnewTrans[i] = (transmap[i].newVal - transmap[i].prevVal) * e.percent + transmap[i].prevVal\n\t\t\t}\n\t\t\tvar ret = Util.substitute(translateTpl + ' ' +\n\t\t\t\t'scale({scaleX},{scaleY})', newTrans);\n\t\t\tel.style[vendorTransform] = ret;\n\t\t},\n\t\tstop: function(e) {\n\t\t\tvar self = this;\n\t\t\tvar cfg = self.cfg;\n\t\t\tcfg.end && cfg.end({\n\t\t\t\tpercent: 1\n\t\t\t});\n\t\t}\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tvar cfg = self.cfg;\n\t\tvar el = self.el;\n\t\tself.el.addEventListener(vendorTransitionEnd, function(e) {\n\t\t\tself.__isTransitionEnd = true;\n\t\t\tif (e.target !== e.currentTarget) return;\n\t\t\tself.trigger(\"transitionend\", e);\n\t\t})\n\t\tself.on(\"transitionend\", self._transitionEndHandler, self);\n\t\tvar cssRun = function(e) {\n\t\t\tself.computeStyle = self.computeStyle || window.getComputedStyle(el);\n\t\t\tfor (var i in cfg.css) {\n\t\t\t\tif (!/transform/.test(i)) {\n\t\t\t\t\tsetStyle(self.el, i, self.computeStyle[i], cfg.css[i], e.percent);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tself.timer && self.timer.on(\"run\", cssRun);\n\t\tself.timer && self.timer.on(\"stop\", self.__handlers.stop, self);\n\t},\n\t/**\n\t * to stop the animation\n\t * @memberof Animate\n\t * @return {Animate}\n\t */\n\tstop: function() {\n\t\tvar self = this;\n\t\tif (self.cfg.useTransition && self.cfg.duration > Timer.MIN_DURATION) {\n\t\t\tvar computeStyle = window.getComputedStyle(this.el);\n\t\t\tfor (var i in self.cfg.css) {\n\t\t\t\tif (animAttrs[i]) {\n\t\t\t\t\tvar value = /transform/.test(i) ? computeStyle[vendorTransform] : computeStyle[i];\n\t\t\t\t\tcss(self.el, i, Util.substitute(translateTpl + ' ' + 'scale({scaleX},{scaleY})', getTransformInfo(value)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tself.el.style[vendorTransition] = \"none\";\n\t\t}\n\t\tself.timer && self.timer.stop() && self.timer.reset();\n\t\tself.computeStyle = null;\n\t\treturn self;\n\t},\n\t/**\n\t * to reset the animation to a new state\n\t * @memberof Animate\n\t * @param {object} cfg cfg for new animation\n\t * @return {Animate}\n\t */\n\treset: function(cfg) {\n\t\tvar self = this;\n\t\tself.computeStyle = null;\n\t\tUtil.mix(self.cfg, cfg);\n\t\tthis.timer && self.timer.reset({\n\t\t\tduration: Math.round(self.cfg.duration),\n\t\t\teasing: self.cfg.easing\n\t\t});\n\t\treturn self;\n\t}\n});\n\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Animate;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Animate;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/animate.js\n// module id = 3\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 4\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 5\n// module chunks = 0","define(function(require, exports, module) {\n/*! Hammer.JS - v2.0.4 - 2014-09-28\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2014 Jorik Tangelder;\n * Licensed under the MIT license */\n  'use strict';\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = document.createElement('div');\n\nvar TYPE_FUNCTION = 'function';\n\nvar round = Math.round;\nvar abs = Math.abs;\nvar now = Date.now;\n\n/**\n * set a timeout with a given scope\n * @param {Function} fn\n * @param {Number} timeout\n * @param {Object} context\n * @returns {number}\n */\nfunction setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n}\n\n/**\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\nfunction invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n        each(arg, context[fn], context);\n        return true;\n    }\n    return false;\n}\n\n/**\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n        return;\n    }\n\n    if (obj.forEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n        i = 0;\n        while (i < obj.length) {\n            iterator.call(context, obj[i], i, obj);\n            i++;\n        }\n    } else {\n        for (i in obj) {\n            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n        }\n    }\n}\n\n/**\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge]\n * @returns {Object} dest\n */\nfunction extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n    while (i < keys.length) {\n        if (!merge || (merge && dest[keys[i]] === undefined)) {\n            dest[keys[i]] = src[keys[i]];\n        }\n        i++;\n    }\n    return dest;\n}\n\n/**\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\nfunction merge(dest, src) {\n    return extend(dest, src, true);\n}\n\n/**\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\nfunction inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n        extend(childP, properties);\n    }\n}\n\n/**\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n    return function boundFn() {\n        return fn.apply(context, arguments);\n    };\n}\n\n/**\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\nfunction boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n        return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n    return val;\n}\n\n/**\n * use the val2 when val1 is undefined\n * @param {*} val1\n * @param {*} val2\n * @returns {*}\n */\nfunction ifUndefined(val1, val2) {\n    return (val1 === undefined) ? val2 : val1;\n}\n\n/**\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction addEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.addEventListener(type, handler, false);\n    });\n}\n\n/**\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\nfunction removeEventListeners(target, types, handler) {\n    each(splitStr(types), function(type) {\n        target.removeEventListener(type, handler, false);\n    });\n}\n\n/**\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n    while (node) {\n        if (node == parent) {\n            return true;\n        }\n        node = node.parentNode;\n    }\n    return false;\n}\n\n/**\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n    return str.indexOf(find) > -1;\n}\n\n/**\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n    return str.trim().split(/\\s+/g);\n}\n\n/**\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n        return src.indexOf(find);\n    } else {\n        var i = 0;\n        while (i < src.length) {\n            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {\n                return i;\n            }\n            i++;\n        }\n        return -1;\n    }\n}\n\n/**\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\nfunction uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n        var val = key ? src[i][key] : src[i];\n        if (inArray(values, val) < 0) {\n            results.push(src[i]);\n        }\n        values[i] = val;\n        i++;\n    }\n\n    if (sort) {\n        if (!key) {\n            results = results.sort();\n        } else {\n            results = results.sort(function sortUniqueArray(a, b) {\n                return a[key] > b[key];\n            });\n        }\n    }\n\n    return results;\n}\n\n/**\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\nfunction prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n\n    var i = 0;\n    while (i < VENDOR_PREFIXES.length) {\n        prefix = VENDOR_PREFIXES[i];\n        prop = (prefix) ? prefix + camelProp : property;\n\n        if (prop in obj) {\n            return prop;\n        }\n        i++;\n    }\n    return undefined;\n}\n\n/**\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n    return _uniqueId++;\n}\n\n/**\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n    var doc = element.ownerDocument;\n    return (doc.defaultView || doc.parentWindow);\n}\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n\nvar SUPPORT_TOUCH = ('ontouchstart' in window);\nvar SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\n\nvar COMPUTE_INTERVAL = 25;\n\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\n\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\n\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\nfunction Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget;\n\n    // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n    this.domHandler = function(ev) {\n        if (boolOrFn(manager.options.enable, [manager])) {\n            self.handler(ev);\n        }\n    };\n\n    this.init();\n\n}\n\nInput.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function() { },\n\n    /**\n     * bind the events\n     */\n    init: function() {\n        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function() {\n        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n};\n\n/**\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\nfunction createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n        Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n        Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n        Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n        Type = MouseInput;\n    } else {\n        Type = TouchMouseInput;\n    }\n    return new (Type)(manager, inputHandler);\n}\n\n/**\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\nfunction inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));\n    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));\n\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n    if (isFirst) {\n        manager.session = {};\n    }\n\n    // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n    input.eventType = eventType;\n\n    // compute scale, rotation etc\n    computeInputData(manager, input);\n\n    // emit secret event\n    manager.emit('hammer.input', input);\n\n    manager.recognize(input);\n    manager.session.prevInput = input;\n}\n\n/**\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\nfunction computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length;\n\n    // store the first input to calculate the distance and direction\n    if (!session.firstInput) {\n        session.firstInput = simpleCloneInputData(input);\n    }\n\n    // to compute scale and rotation we need to store the multiple touches\n    if (pointersLength > 1 && !session.firstMultiple) {\n        session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n        session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n\n    computeIntervalInputData(session, input);\n\n    // find the correct target\n    var target = manager.element;\n    if (hasParent(input.srcEvent.target, target)) {\n        target = input.srcEvent.target;\n    }\n    input.target = target;\n}\n\nfunction computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n        prevDelta = session.prevDelta = {\n            x: prevInput.deltaX || 0,\n            y: prevInput.deltaY || 0\n        };\n\n        offset = session.offsetDelta = {\n            x: center.x,\n            y: center.y\n        };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\nfunction computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity, velocityX, velocityY, direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n        var deltaX = last.deltaX - input.deltaX;\n        var deltaY = last.deltaY - input.deltaY;\n        var v = getVelocity(deltaTime, deltaX, deltaY);\n        velocityX = v.x;\n        velocityY = v.y;\n        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n        direction = getDirection(deltaX, deltaY);\n\n        session.lastInterval = input;\n    } else {\n        // use latest velocity info if it doesn't overtake a minimum period\n        velocity = last.velocity;\n        velocityX = last.velocityX;\n        velocityY = last.velocityY;\n        direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n}\n\n/**\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\nfunction simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n    while (i < input.pointers.length) {\n        pointers[i] = {\n            clientX: round(input.pointers[i].clientX),\n            clientY: round(input.pointers[i].clientY)\n        };\n        i++;\n    }\n\n    return {\n        timeStamp: now(),\n        pointers: pointers,\n        center: getCenter(pointers),\n        deltaX: input.deltaX,\n        deltaY: input.deltaY\n    };\n}\n\n/**\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\nfunction getCenter(pointers) {\n    var pointersLength = pointers.length;\n\n    // no need to loop when only one touch\n    if (pointersLength === 1) {\n        return {\n            x: round(pointers[0].clientX),\n            y: round(pointers[0].clientY)\n        };\n    }\n\n    var x = 0, y = 0, i = 0;\n    while (i < pointersLength) {\n        x += pointers[i].clientX;\n        y += pointers[i].clientY;\n        i++;\n    }\n\n    return {\n        x: round(x / pointersLength),\n        y: round(y / pointersLength)\n    };\n}\n\n/**\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n    return {\n        x: x / deltaTime || 0,\n        y: y / deltaTime || 0\n    };\n}\n\n/**\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\nfunction getDirection(x, y) {\n    if (x === y) {\n        return DIRECTION_NONE;\n    }\n    \n    if (abs(x) >= abs(y)) {\n        return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\n/**\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\nfunction getDistance(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n\n    return Math.sqrt((x * x) + (y * y));\n}\n\n/**\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\nfunction getAngle(p1, p2, props) {\n    if (!props) {\n        props = PROPS_XY;\n    }\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\nfunction getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) - getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\nfunction getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\nvar MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n};\n\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n\n/**\n * Mouse events input\n * @constructor\n * @extends Input\n */\nfunction MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n\n    this.allow = true; // used by Input.TouchMouse to disable mouse events\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n}\n\ninherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n        var eventType = MOUSE_INPUT_MAP[ev.type];\n\n        // on start we want to have the left mouse button down\n        if (eventType & INPUT_START && ev.button === 0) {\n            this.pressed = true;\n        }\n\n        if (eventType & INPUT_MOVE && ev.which !== 1) {\n            eventType = INPUT_END;\n        }\n\n        // mouse must be down, and mouse events are allowed (see the TouchMouse input)\n        if (!this.pressed || !this.allow) {\n            return;\n        }\n\n        if (eventType & INPUT_END) {\n            this.pressed = false;\n        }\n\n        this.callback(this.manager, eventType, {\n            pointers: [ev],\n            changedPointers: [ev],\n            pointerType: INPUT_TYPE_MOUSE,\n            srcEvent: ev\n        });\n    }\n});\n\nvar POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n};\n\n// in IE10 the pointer types is defined as an enum\nvar IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n};\n\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';\n\n// IE10 has prefixed support, and case-sensitive\nif (window.MSPointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n\n/**\n * Pointer events input\n * @constructor\n * @extends Input\n */\nfunction PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n\n    Input.apply(this, arguments);\n\n    this.store = (this.manager.session.pointerEvents = []);\n}\n\ninherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n        var store = this.store;\n        var removePointer = false;\n\n        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n\n        var isTouch = (pointerType == INPUT_TYPE_TOUCH);\n\n        // get index of the event in the store\n        var storeIndex = inArray(store, ev.pointerId, 'pointerId');\n\n        // start and mouse must be down\n        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n            if (storeIndex < 0) {\n                store.push(ev);\n                storeIndex = store.length - 1;\n            }\n        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n            removePointer = true;\n        }\n\n        // it not found, so the pointer hasn't been down (so it's probably a hover)\n        if (storeIndex < 0) {\n            return;\n        }\n\n        // update the event in the store\n        store[storeIndex] = ev;\n\n        this.callback(this.manager, eventType, {\n            pointers: store,\n            changedPointers: [ev],\n            pointerType: pointerType,\n            srcEvent: ev\n        });\n\n        if (removePointer) {\n            // remove from the store\n            store.splice(storeIndex, 1);\n        }\n    }\n});\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Touch events input\n * @constructor\n * @extends Input\n */\nfunction SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n\n    Input.apply(this, arguments);\n}\n\ninherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];\n\n        // should we handle the touch events?\n        if (type === INPUT_START) {\n            this.started = true;\n        }\n\n        if (!this.started) {\n            return;\n        }\n\n        var touches = normalizeSingleTouches.call(this, ev, type);\n\n        // when done, reset the started state\n        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n            this.started = false;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n        all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n}\n\nvar TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n};\n\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n\n/**\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\nfunction TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n\n    Input.apply(this, arguments);\n}\n\ninherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n        var type = TOUCH_INPUT_MAP[ev.type];\n        var touches = getTouches.call(this, ev, type);\n        if (!touches) {\n            return;\n        }\n\n        this.callback(this.manager, type, {\n            pointers: touches[0],\n            changedPointers: touches[1],\n            pointerType: INPUT_TYPE_TOUCH,\n            srcEvent: ev\n        });\n    }\n});\n\n/**\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]\n */\nfunction getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds;\n\n    // when there is only one touch, the process can be simplified\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n        targetIds[allTouches[0].identifier] = true;\n        return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target;\n\n    // get target touches from touches\n    targetTouches = allTouches.filter(function(touch) {\n        return hasParent(touch.target, target);\n    });\n\n    // collect touches\n    if (type === INPUT_START) {\n        i = 0;\n        while (i < targetTouches.length) {\n            targetIds[targetTouches[i].identifier] = true;\n            i++;\n        }\n    }\n\n    // filter changed touches to only contain touches that exist in the collected target ids\n    i = 0;\n    while (i < changedTouches.length) {\n        if (targetIds[changedTouches[i].identifier]) {\n            changedTargetTouches.push(changedTouches[i]);\n        }\n\n        // cleanup removed touches\n        if (type & (INPUT_END | INPUT_CANCEL)) {\n            delete targetIds[changedTouches[i].identifier];\n        }\n        i++;\n    }\n\n    if (!changedTargetTouches.length) {\n        return;\n    }\n\n    return [\n        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),\n        changedTargetTouches\n    ];\n}\n\n/**\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\nfunction TouchMouseInput() {\n    Input.apply(this, arguments);\n\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n}\n\ninherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),\n            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);\n\n        // when we're in a touch event, so  block all upcoming mouse events\n        // most mobile browser also emit mouseevents, right after touchstart\n        if (isTouch) {\n            this.mouse.allow = false;\n        } else if (isMouse && !this.mouse.allow) {\n            return;\n        }\n\n        // reset the allowMouse when we're done\n        if (inputEvent & (INPUT_END | INPUT_CANCEL)) {\n            this.mouse.allow = true;\n        }\n\n        this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n        this.touch.destroy();\n        this.mouse.destroy();\n    }\n});\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\n\n// magical touchAction value\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\n\n/**\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\nfunction TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n}\n\nTouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function(value) {\n        // find out the touch-action by the event handlers\n        if (value == TOUCH_ACTION_COMPUTE) {\n            value = this.compute();\n        }\n\n        if (NATIVE_TOUCH_ACTION) {\n            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n        }\n        this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function() {\n        this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function() {\n        var actions = [];\n        each(this.manager.recognizers, function(recognizer) {\n            if (boolOrFn(recognizer.options.enable, [recognizer])) {\n                actions = actions.concat(recognizer.getTouchAction());\n            }\n        });\n        return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function(input) {\n        // not needed with native support for the touchAction property\n        if (NATIVE_TOUCH_ACTION) {\n            return;\n        }\n\n        var srcEvent = input.srcEvent;\n        var direction = input.offsetDirection;\n\n        // if the touch action did prevented once this session\n        if (this.manager.session.prevented) {\n            srcEvent.preventDefault();\n            return;\n        }\n\n        var actions = this.actions;\n        var hasNone = inStr(actions, TOUCH_ACTION_NONE);\n        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n\n        if (hasNone ||\n            (hasPanY && direction & DIRECTION_HORIZONTAL) ||\n            (hasPanX && direction & DIRECTION_VERTICAL)) {\n            return this.preventSrc(srcEvent);\n        }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function(srcEvent) {\n        this.manager.session.prevented = true;\n        srcEvent.preventDefault();\n    }\n};\n\n/**\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\nfunction cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n        return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n\n    // pan-x and pan-y can be combined\n    if (hasPanX && hasPanY) {\n        return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;\n    }\n\n    // pan-x OR pan-y\n    if (hasPanX || hasPanY) {\n        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    }\n\n    // manipulation\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n        return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n}\n\n/**\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\nfunction Recognizer(options) {\n    this.id = uniqueId();\n\n    this.manager = null;\n    this.options = merge(options || {}, this.defaults);\n\n    // default is enable true\n    this.options.enable = ifUndefined(this.options.enable, true);\n\n    this.state = STATE_POSSIBLE;\n\n    this.simultaneous = {};\n    this.requireFail = [];\n}\n\nRecognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function(options) {\n        extend(this.options, options);\n\n        // also update the touchAction, in case something changed about the directions/enabled state\n        this.manager && this.manager.touchAction.update();\n        return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n            return this;\n        }\n\n        var simultaneous = this.simultaneous;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (!simultaneous[otherRecognizer.id]) {\n            simultaneous[otherRecognizer.id] = otherRecognizer;\n            otherRecognizer.recognizeWith(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        delete this.simultaneous[otherRecognizer.id];\n        return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n            return this;\n        }\n\n        var requireFail = this.requireFail;\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        if (inArray(requireFail, otherRecognizer) === -1) {\n            requireFail.push(otherRecognizer);\n            otherRecognizer.requireFailure(this);\n        }\n        return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function(otherRecognizer) {\n        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n            return this;\n        }\n\n        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n        var index = inArray(this.requireFail, otherRecognizer);\n        if (index > -1) {\n            this.requireFail.splice(index, 1);\n        }\n        return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function() {\n        return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function(otherRecognizer) {\n        return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function(input) {\n        var self = this;\n        var state = this.state;\n\n        function emit(withState) {\n            self.manager.emit(self.options.event + (withState ? stateStr(state) : ''), input);\n        }\n\n        // 'panstart' and 'panmove'\n        if (state < STATE_ENDED) {\n            emit(true);\n        }\n\n        emit(); // simple 'eventName' events\n\n        // panend and pancancel\n        if (state >= STATE_ENDED) {\n            emit(true);\n        }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function(input) {\n        if (this.canEmit()) {\n            return this.emit(input);\n        }\n        // it's failing anyway\n        this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function() {\n        var i = 0;\n        while (i < this.requireFail.length) {\n            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        // make a new copy of the inputData\n        // so we can change the inputData without messing up the other recognizers\n        var inputDataClone = extend({}, inputData);\n\n        // is is enabled and allow recognizing?\n        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n            this.reset();\n            this.state = STATE_FAILED;\n            return;\n        }\n\n        // reset when we've reached the end\n        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n            this.state = STATE_POSSIBLE;\n        }\n\n        this.state = this.process(inputDataClone);\n\n        // the recognizer has recognized a gesture\n        // so trigger an event\n        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n            this.tryEmit(inputDataClone);\n        }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function(inputData) { }, // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function() { },\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function() { }\n};\n\n/**\n * get a usable string, used as event postfix\n * @param {Const} state\n * @returns {String} state\n */\nfunction stateStr(state) {\n    if (state & STATE_CANCELLED) {\n        return 'cancel';\n    } else if (state & STATE_ENDED) {\n        return 'end';\n    } else if (state & STATE_CHANGED) {\n        return 'move';\n    } else if (state & STATE_BEGAN) {\n        return 'start';\n    }\n    return '';\n}\n\n/**\n * direction cons to string\n * @param {Const} direction\n * @returns {String}\n */\nfunction directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n        return 'down';\n    } else if (direction == DIRECTION_UP) {\n        return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n        return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n        return 'right';\n    }\n    return '';\n}\n\n/**\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n    if (manager) {\n        return manager.get(otherRecognizer);\n    }\n    return otherRecognizer;\n}\n\n/**\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\nfunction AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n}\n\ninherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n        /**\n         * @type {Number}\n         * @default 1\n         */\n        pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function(input) {\n        var optionPointers = this.options.pointers;\n        return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function(input) {\n        var state = this.state;\n        var eventType = input.eventType;\n\n        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n        var isValid = this.attrTest(input);\n\n        // on cancel input and we've recognized before, return STATE_CANCELLED\n        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n            return state | STATE_CANCELLED;\n        } else if (isRecognized || isValid) {\n            if (eventType & INPUT_END) {\n                return state | STATE_ENDED;\n            } else if (!(state & STATE_BEGAN)) {\n                return STATE_BEGAN;\n            }\n            return state | STATE_CHANGED;\n        }\n        return STATE_FAILED;\n    }\n});\n\n/**\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n\n    this.pX = null;\n    this.pY = null;\n}\n\ninherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n        event: 'pan',\n        threshold: 10,\n        pointers: 1,\n        direction: DIRECTION_ALL\n    },\n\n    getTouchAction: function() {\n        var direction = this.options.direction;\n        var actions = [];\n        if (direction & DIRECTION_HORIZONTAL) {\n            actions.push(TOUCH_ACTION_PAN_Y);\n        }\n        if (direction & DIRECTION_VERTICAL) {\n            actions.push(TOUCH_ACTION_PAN_X);\n        }\n        return actions;\n    },\n\n    directionTest: function(input) {\n        var options = this.options;\n        var hasMoved = true;\n        var distance = input.distance;\n        var direction = input.direction;\n        var x = input.deltaX;\n        var y = input.deltaY;\n\n        // lock to axis?\n        if (!(direction & options.direction)) {\n            if (options.direction & DIRECTION_HORIZONTAL) {\n                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n                hasMoved = x != this.pX;\n                distance = Math.abs(input.deltaX);\n            } else {\n                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n                hasMoved = y != this.pY;\n                distance = Math.abs(input.deltaY);\n            }\n        }\n        input.direction = direction;\n        return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n\n    attrTest: function(input) {\n        return AttrRecognizer.prototype.attrTest.call(this, input) &&\n            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));\n    },\n\n    emit: function(input) {\n        this.pX = input.deltaX;\n        this.pY = input.deltaY;\n\n        var direction = directionStr(input.direction);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this._super.emit.call(this, input);\n    },\n    reset:function(){\n        \n    }\n});\n\n/**\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\nfunction PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'pinch',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n\n    emit: function(input) {\n        this._super.emit.call(this, input);\n        if (input.scale !== 1) {\n            var inOut = input.scale < 1 ? 'in' : 'out';\n            this.manager.emit(this.options.event + inOut, input);\n        }\n    }\n});\n\n/**\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\nfunction PressRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    this._timer = null;\n    this._input = null;\n}\n\ninherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n        event: 'press',\n        pointers: 1,\n        time: 500, // minimal time of the pointer to be pressed\n        threshold: 5 // a minimal movement is ok, but keep it low\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_AUTO];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTime = input.deltaTime > options.time;\n\n        this._input = input;\n\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {\n            this.reset();\n        } else if (input.eventType & INPUT_START) {\n            this.reset();\n            this._timer = setTimeoutContext(function() {\n                this.state = STATE_RECOGNIZED;\n                this.tryEmit();\n            }, options.time, this);\n        } else if (input.eventType & INPUT_END) {\n            return STATE_RECOGNIZED;\n        }\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function(input) {\n        if (this.state !== STATE_RECOGNIZED) {\n            return;\n        }\n\n        if (input && (input.eventType & INPUT_END)) {\n            this.manager.emit(this.options.event + 'up', input);\n        } else {\n            this._input.timeStamp = now();\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n        event: 'rotate',\n        threshold: 0,\n        pointers: 2\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_NONE];\n    },\n\n    attrTest: function(input) {\n        return this._super.attrTest.call(this, input) &&\n            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n});\n\n/**\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\nfunction SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n}\n\ninherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n        event: 'swipe',\n        threshold: 10,\n        velocity: 0.65,\n        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n        pointers: 1\n    },\n\n    getTouchAction: function() {\n        return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n\n    attrTest: function(input) {\n        var direction = this.options.direction;\n        var velocity;\n\n        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n            velocity = input.velocity;\n        } else if (direction & DIRECTION_HORIZONTAL) {\n            velocity = input.velocityX;\n        } else if (direction & DIRECTION_VERTICAL) {\n            velocity = input.velocityY;\n        }\n\n        return this._super.attrTest.call(this, input) &&\n            direction & input.direction &&\n            input.distance > this.options.threshold &&\n            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n\n    emit: function(input) {\n        var direction = directionStr(input.direction);\n        if (direction) {\n            this.manager.emit(this.options.event + direction, input);\n        }\n\n        this.manager.emit(this.options.event, input);\n    }\n});\n\n/**\n * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\nfunction TapRecognizer() {\n    Recognizer.apply(this, arguments);\n\n    // previous time and center,\n    // used for tap counting\n    this.pTime = false;\n    this.pCenter = false;\n\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n}\n\ninherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n        event: 'tap',\n        pointers: 1,\n        taps: 1,\n        interval: 300, // max time between the multi-tap taps\n        time: 250, // max time of the pointer to be down (like finger on the screen)\n        threshold: 10, // a minimal movement is ok, but keep it low\n        posThreshold: 10 // a multi-tap can be a bit off the initial position\n    },\n\n    getTouchAction: function() {\n        return [TOUCH_ACTION_MANIPULATION];\n    },\n\n    process: function(input) {\n        var options = this.options;\n        var validPointers = input.pointers.length === options.pointers;\n        var validMovement = input.distance < options.threshold;\n        var validTouchTime = input.deltaTime < options.time;\n        this.reset();\n\n        if ((input.eventType & INPUT_START) && (this.count === 0)) {\n            return this.failTimeout();\n        }\n        // we only allow little movement\n        // and we've reached an end event, so a tap is possible\n        if (validMovement && validTouchTime && validPointers) {\n            if (input.eventType != INPUT_END) {\n                return this.failTimeout();\n            }\n\n            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;\n            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n\n            this.pTime = input.timeStamp;\n            this.pCenter = input.center;\n            if (!validMultiTap || !validInterval) {\n                this.count = 1;\n            } else {\n                this.count += 1;\n            }\n\n            this._input = input;\n\n            // if tap count matches we have recognized it,\n            // else it has began recognizing...\n            var tapCount = this.count % options.taps;\n            if (tapCount === 0) {\n                // no failing requirements, immediately trigger the tap event\n                // or wait as long as the multitap interval to trigger\n                if (!this.hasRequireFailures()) {\n                    return STATE_RECOGNIZED;\n                } else {\n                    this._timer = setTimeoutContext(function() {\n                        this.state = STATE_RECOGNIZED;\n                        this.tryEmit();\n                    }, options.interval, this);\n                    return STATE_BEGAN;\n                }\n            }\n        }\n        return STATE_FAILED;\n    },\n\n    failTimeout: function() {\n        this._timer = setTimeoutContext(function() {\n            this.state = STATE_FAILED;\n        }, this.options.interval, this);\n        return STATE_FAILED;\n    },\n\n    reset: function() {\n        clearTimeout(this._timer);\n    },\n\n    emit: function() {\n        if (this.state == STATE_RECOGNIZED ) {\n            this._input.tapCount = this.count;\n            this.manager.emit(this.options.event, this._input);\n        }\n    }\n});\n\n/**\n * Simple way to create an manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n}\n\n/**\n * @const {string}\n */\nHammer.VERSION = '2.0.4';\n\n/**\n * default settings\n * @namespace\n */\nHammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [\n        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n        [RotateRecognizer, { enable: false }],\n        [PinchRecognizer, { enable: false }, ['rotate']],\n        [SwipeRecognizer,{ direction: DIRECTION_HORIZONTAL }],\n        [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ['swipe']],\n        [TapRecognizer],\n        [TapRecognizer, { event: 'doubletap', taps: 2 }, ['tap']],\n        [PressRecognizer]\n    ],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n        /**\n         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userSelect: 'none',\n\n        /**\n         * Disable the Windows Phone grippers when pressing an element.\n         * @type {String}\n         * @default 'none'\n         */\n        touchSelect: 'none',\n\n        /**\n         * Disables the default callout shown when you touch and hold a touch target.\n         * On iOS, when you touch and hold a touch target such as a link, Safari displays\n         * a callout containing information about the link. This property allows you to disable that callout.\n         * @type {String}\n         * @default 'none'\n         */\n        touchCallout: 'none',\n\n        /**\n         * Specifies whether zooming is enabled. Used by IE10>\n         * @type {String}\n         * @default 'none'\n         */\n        contentZooming: 'none',\n\n        /**\n         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n         * @type {String}\n         * @default 'none'\n         */\n        userDrag: 'none',\n\n        /**\n         * Overrides the highlight color shown when the user taps a link or a JavaScript\n         * clickable element in iOS. This property obeys the alpha value, if specified.\n         * @type {String}\n         * @default 'rgba(0,0,0,0)'\n         */\n        tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n};\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n\n/**\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\nfunction Manager(element, options) {\n    options = options || {};\n\n    this.options = merge(options, Hammer.defaults);\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n\n    toggleCssProps(this, true);\n\n    each(options.recognizers, function(item) {\n        var recognizer = this.add(new (item[0])(item[1]));\n        item[2] && recognizer.recognizeWith(item[2]);\n        item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n}\n\nManager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function(options) {\n        extend(this.options, options);\n\n        // Options that need a little more setup\n        if (options.touchAction) {\n            this.touchAction.update();\n        }\n        if (options.inputTarget) {\n            // Clean up existing event listeners and reinitialize\n            this.input.destroy();\n            this.input.target = options.inputTarget;\n            this.input.init();\n        }\n        return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function(force) {\n        this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function(inputData) {\n        var session = this.session;\n        if (session.stopped) {\n            return;\n        }\n\n        // run the touch-action polyfill\n        this.touchAction.preventDefaults(inputData);\n\n        var recognizer;\n        var recognizers = this.recognizers;\n\n        // this holds the recognizer that is being recognized.\n        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n        // if no recognizer is detecting a thing, it is set to `null`\n        var curRecognizer = session.curRecognizer;\n\n        // reset when the last recognizer is recognized\n        // or when we're in a new session\n        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {\n            curRecognizer = session.curRecognizer = null;\n        }\n\n        var i = 0;\n        while (i < recognizers.length) {\n            recognizer = recognizers[i];\n\n            // find out if we are allowed try to recognize the input for this one.\n            // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n            //      that is being recognized.\n            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n            //      this can be setup with the `recognizeWith()` method on the recognizer.\n            if (session.stopped !== FORCED_STOP && ( // 1\n                    !curRecognizer || recognizer == curRecognizer || // 2\n                    recognizer.canRecognizeWith(curRecognizer))) { // 3\n                recognizer.recognize(inputData);\n            } else {\n                recognizer.reset();\n            }\n\n            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n            // current active recognizer. but only if we don't already have an active recognizer\n            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n                curRecognizer = session.curRecognizer = recognizer;\n            }\n            i++;\n        }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function(recognizer) {\n        if (recognizer instanceof Recognizer) {\n            return recognizer;\n        }\n\n        var recognizers = this.recognizers;\n        for (var i = 0; i < recognizers.length; i++) {\n            if (recognizers[i].options.event == recognizer) {\n                return recognizers[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'add', this)) {\n            return this;\n        }\n\n        // remove existing\n        var existing = this.get(recognizer.options.event);\n        if (existing) {\n            this.remove(existing);\n        }\n\n        this.recognizers.push(recognizer);\n        recognizer.manager = this;\n\n        this.touchAction.update();\n        return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function(recognizer) {\n        if (invokeArrayArg(recognizer, 'remove', this)) {\n            return this;\n        }\n\n        var recognizers = this.recognizers;\n        recognizer = this.get(recognizer);\n        recognizers.splice(inArray(recognizers, recognizer), 1);\n\n        this.touchAction.update();\n        return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function(events, handler) {\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            handlers[event] = handlers[event] || [];\n            handlers[event].push(handler);\n        });\n        return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function(events, handler) {\n        var handlers = this.handlers;\n        each(splitStr(events), function(event) {\n            if (!handler) {\n                delete handlers[event];\n            } else {\n                handlers[event].splice(inArray(handlers[event], handler), 1);\n            }\n        });\n        return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function(event, data) {\n        // we also want to trigger dom events\n        if (this.options.domEvents) {\n            triggerDomEvent(event, data);\n        }\n\n        // no handlers, so skip it all\n        var handlers = this.handlers[event] && this.handlers[event].slice();\n        if (!handlers || !handlers.length) {\n            return;\n        }\n\n        data.type = event;\n        data.preventDefault = function() {\n            data.srcEvent.preventDefault();\n        };\n\n        var i = 0;\n        while (i < handlers.length) {\n            handlers[i](data);\n            i++;\n        }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function() {\n        this.element && toggleCssProps(this, false);\n\n        this.handlers = {};\n        this.session = {};\n        this.input.destroy();\n        this.element = null;\n    }\n};\n\n/**\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\nfunction toggleCssProps(manager, add) {\n    var element = manager.element;\n    each(manager.options.cssProps, function(value, name) {\n        element.style[prefixed(element.style, name)] = add ? value : '';\n    });\n}\n\n/**\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\nfunction triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n}\n\nextend(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n});\n\nif (typeof module == 'object' && module.exports) {\n    module.exports = Hammer;\n}\n/** ignored by jsdoc **/\nelse {\n    return Hammer;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/hammer.js\n// module id = 6\n// module chunks = 0","import './style.scss';\nimport './style.plug.pulldown.scss';\nimport './style.plug.pullup.scss';\n\nimport XScroll from 'xscroll/build/cmd/xscroll';\nimport XScrollPullUp from 'xscroll/build/cmd/plugins/pullup';\nimport XScrollPullDown from 'xscroll/build/cmd/plugins/pulldown';\nimport XScrollInfinite from 'xscroll/build/cmd/plugins/infinite';\nimport classNames from 'classnames';\n\nimport $ from 'n-zepto'\n\n\nlet instanceMap = {};\n\nclass ReactXScroll extends React.Component{\n  static propTypes = {\n    cssClass:React.PropTypes.string,\n    delegateHandle:React.PropTypes.string,\n    xscrollOptions:React.PropTypes.object,\n    pulldownOptions:React.PropTypes.object,\n    pullupOptions:React.PropTypes.object,\n    infiniteOptions:React.PropTypes.object,\n    onRefresh:React.PropTypes.func,\n    onInfinite:React.PropTypes.func,\n  };\n\n  static defaultProps = {\n    cssClass:'wrapper',\n    delegateHandle:'',\n    xscrollOptions:{},\n    pulldownOptions:{},\n    pullupOptions:{},\n    infiniteOptions:{},\n    onRefresh:null,\n    onInfinite:null\n  };\n\n  static createIscroll(inOptions){\n    return new XScroll(inOptions);\n  }\n\n  static createPullUpPlugin(inScrollInstance,inOptions){\n    var pullup = new XScrollPullUp(inOptions);\n    inScrollInstance.plug(pullup);\n    return pullup;\n  }\n\n  static createPullDownPlugin(inScrollInstance,inOptions){\n    var pulldown = new XScrollPullDown(inOptions);\n    inScrollInstance.plug(pulldown);\n    return pulldown;\n  }\n\n  static createInfinitePlugin(inScrollInstance,inOptions){\n    var infinite = new XScrollInfinite(inOptions);\n    inScrollInstance.plug(infinite);\n    return infinite;\n  }\n\n  static getInstance(inHandle){\n    return instanceMap[inHandle];\n  }\n  constructor(inProps){\n    super(inProps);\n    instanceMap[inProps.delegateHandle] = this;\n  }\n\n  componentDidMount(){\n    var self = this;\n    var xscroll = this._xscroll = ReactXScroll.createIscroll(this.props.xscrollOptions);\n    var infinite = this._infinite = ReactXScroll.createInfinitePlugin(this._xscroll,this.props.infiniteOptions);\n    var pullup = this._pullup = ReactXScroll.createPullUpPlugin(this._xscroll,this.props.pullupOptions);\n    var pulldown = this._pulldown = ReactXScroll.createPullDownPlugin(this._xscroll,this.props.pulldownOptions);\n\n    pullup.on('loading',function(){\n      self.props.onInfinite(self);\n    });\n\n    pulldown.on('loading',function(e){\n      self.props.onRefresh(self);\n    })\n\n    this.props.onInfinite(this);\n    xscroll.render();\n  }\n\n  invoke(inName){\n    var args = [].slice.call(arguments, 1);\n    return this._xscroll[inName].apply(this._xscroll, args);\n  }\n\n  render(){\n    return (\n      <div data-delegate-handle={this.props.delegateHandle} className={classNames('react-xscroll-wrapper',this.props.cssClass)}>\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\n\nexport default ReactXScroll;\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/react-xscroll.js","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util'),\n    Base = require('./base'),\n    Animate = require('./animate'),\n    Boundry = require('./boundry'),\n    Hammer = require('./hammer'),\n    Sticky = require('./components/sticky'),\n    Fixed = require('./components/fixed');\n// boundry checked bounce effect\nvar BOUNDRY_CHECK_DURATION = 500;\nvar BOUNDRY_CHECK_EASING = \"ease\";\nvar BOUNDRY_CHECK_ACCELERATION = 0.1;\n/** \n * @constructor\n * @param {object} cfg config for scroll\n * @param {number} cfg.SCROLL_ACCELERATION  acceleration for scroll, min value make the scrolling smoothly\n * @param {number} cfg.BOUNDRY_CHECK_DURATION duration for boundry bounce\n * @param {number} cfg.BOUNDRY_CHECK_EASING easing for boundry bounce\n * @param {number} cfg.BOUNDRY_CHECK_ACCELERATION acceleration for boundry bounce\n * @param {boolean} cfg.lockX just like overflow-x:hidden\n * @param {boolean} cfg.lockY just like overflow-y:hidden\n * @param {boolean} cfg.scrollbarX config if the scrollbar-x is visible\n * @param {boolean} cfg.scrollbarY config if the scrollbar-y is visible\n * @param {boolean} cfg.useTransition config if use css3 transition or raf for scroll animation\n * @param {boolean} cfg.useOriginScroll config if use simulate or origin scroll\n * @param {boolean} cfg.bounce config if use has the bounce effect when scrolling outside of the boundry\n * @param {boolean} cfg.boundryCheck config if scrolling inside of the boundry\n * @param {boolean} cfg.preventDefault prevent touchstart\n * @param {boolean} cfg.preventTouchMove prevent touchmove\n * @param {string|HTMLElement}  cfg.container config for scroller's container which default value is \".xs-container\"\n * @param {string|HTMLElement}  cfg.content config for scroller's content which default value is \".xs-content\"\n * @param {object}  cfg.indicatorInsets  config scrollbars position {top: number, left: number, bottom: number, right: number}\n * @param {string}  cfg.stickyElements config for sticky-positioned elements\n * @param {string}  cfg.fixedElements config for fixed-positioned elements\n * @param {string}  cfg.touchAction config for touchAction of the scroller\n * @extends XScroll\n * @example\n * var xscroll = new XScroll({\n *    renderTo:\"#scroll\",\n *    lockX:false,\n *    scrollbarX:true\n * });\n * xscroll.render();\n */\nfunction XScroll(cfg) {\n    XScroll.superclass.constructor.call(this);\n    this.userConfig = cfg;\n    this.init();\n}\n\nUtil.extend(XScroll, Base, {\n    /**\n     * version\n     * @memberof XScroll\n     * @type {string}\n     */\n    version: \"3.0.13\",\n    /**\n     * init scroll\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    init: function() {\n        var self = this;\n        var defaultCfg = {\n            preventDefault: true,\n            bounce: true,\n            boundryCheck: true,\n            useTransition: true,\n            gpuAcceleration: true,\n            BOUNDRY_CHECK_EASING: BOUNDRY_CHECK_EASING,\n            BOUNDRY_CHECK_DURATION: BOUNDRY_CHECK_DURATION,\n            BOUNDRY_CHECK_ACCELERATION: BOUNDRY_CHECK_ACCELERATION,\n            useOriginScroll: false,\n            zoomType: \"y\",\n            indicatorInsets: {\n                top: 3,\n                bottom: 3,\n                left: 3,\n                right: 3,\n                width: 3,\n                spacing: 5\n            },\n            container: \".xs-container\",\n            content: \".xs-content\",\n            stickyElements: \".xs-sticky\",\n            fixedElements: \".xs-fixed\",\n            touchAction: \"auto\"\n        };\n        //generate guid\n        self.guid = Util.guid();\n        self.renderTo = Util.getNode(self.userConfig.renderTo);\n        //timer for animtion\n        self.__timers = {};\n        //config attributes on element\n        var elCfg = JSON.parse(self.renderTo.getAttribute('xs-cfg'));\n        var userConfig = self.userConfig = Util.mix(Util.mix(defaultCfg, elCfg), self.userConfig);\n        self.container = Util.getNode(userConfig.container,self.renderTo);\n        self.content = Util.getNode(userConfig.content,self.renderTo);\n        self.boundry = new Boundry();\n        self.boundry.refresh();\n        return self;\n    },\n    /**\n     * destroy scroll\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    destroy: function() {\n        var self = this;\n        self.mc && self.mc.destroy();\n        self.sticky && self.sticky.destroy();\n        self.fixed && self.fixed.destroy();\n    },\n    _initContainer: function() {},\n    /**\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    enableGPUAcceleration: function() {\n        this.userConfig.gpuAcceleration = true;\n        return this;\n    },\n    /**\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    disableGPUAcceleration: function() {\n        this.userConfig.gpuAcceleration = false;\n        return this;\n    },\n    /**\n     * get scroll offset\n     * @memberof XScroll\n     * @return {Object} {scrollTop:scrollTop,scrollLeft:scrollLeft}\n     */\n    getScrollPos: function() {\n        var self = this;\n        return {\n            scrollLeft: self.getScrollLeft(),\n            scrollTop: self.getScrollTop()\n        }\n    },\n    /**\n     * get scroll top value\n     * @memberof XScroll\n     * @return {number} scrollTop\n     */\n    getScrollTop: function() {},\n    /**\n     * get scroll left value\n     * @memberof XScroll\n     * @return {number} scrollLeft\n     */\n    getScrollLeft: function() {},\n    /**\n     * scroll absolute to the destination\n     * @memberof XScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollTo: function(scrollLeft, scrollTop, duration, easing, callback) {\n        var self = this;\n        var scrollLeft = (undefined === scrollLeft || isNaN(scrollLeft)) ? -self.getScrollLeft() : scrollLeft;\n        var scrollTop = (undefined === scrollTop || isNaN(scrollTop)) ? -self.getScrollTop() : scrollTop;\n        self.scrollLeft(scrollLeft, duration, easing, callback);\n        self.scrollTop(scrollTop, duration, easing, callback);\n    },\n    /**\n     * scroll relative to the destination\n     * @memberof XScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollBy: function(scrollLeft, scrollTop, duration, easing, callback) {\n        this.scrollByX(scrollLeft, duration, easing, callback);\n        this.scrollByY(scrollTop, duration, easing, callback);\n    },\n    /**\n     * horizontal scroll relative to the destination\n     * @memberof XScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollLeftBy: function(scrollLeft, duration, easing, callback) {\n        this.scrollLeft(Number(scrollLeft) + Number(this.getScrollLeft()), duration, easing, callback);\n    },\n    /**\n     * vertical scroll relative to the destination\n     * @memberof XScroll\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollTopBy: function(scrollTop, duration, easing, callback) {\n        this.scrollTop(Number(scrollTop) + Number(this.getScrollTop()), duration, easing, callback);\n    },\n    /**\n     * horizontal scroll absolute to the destination\n     * @memberof XScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollLeft: function(scrollLeft, duration, easing, callback) {},\n    /**\n     * vertical scroll absolute to the destination\n     * @memberof XScroll\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollTop: function(scrollTop, duration, easing, callback) {},\n    /**\n     * reset the boundry size\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    resetSize: function() {\n        var self = this;\n        if(!self.container || !self.content) return;\n        var userConfig = self.userConfig;\n        var renderToStyle = getComputedStyle(self.renderTo);\n        var width = self.width = (userConfig.width || self.renderTo.offsetWidth) - Util.px2Num(renderToStyle['padding-left']) - Util.px2Num(renderToStyle['padding-right']);\n        var height = self.height = (userConfig.height || self.renderTo.offsetHeight) - Util.px2Num(renderToStyle['padding-top']) - Util.px2Num(renderToStyle['padding-bottom']);;\n        var containerWidth = userConfig.containerWidth || self.content.offsetWidth;\n        var containerHeight = userConfig.containerHeight || self.content.offsetHeight;\n        self.containerWidth = containerWidth < self.width ? self.width : containerWidth;\n        self.containerHeight = containerHeight < self.height ? self.height : containerHeight;\n        self.boundry.refresh({\n            width: self.width,\n            height: self.height\n        });\n        return self;\n    },\n    /**\n     * render scroll\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    render: function() {\n        var self = this;\n        self.resetSize();\n        //init stickies\n        self.initSticky();\n        //init fixed elements\n        self.initFixed();\n\n        self.trigger(\"afterrender\", {\n            type: \"afterrender\"\n        });\n        self._bindEvt();\n        //update touch-action \n        self.initTouchAction();\n        return self;\n    },\n    /**\n     * init touch action\n     * @memberof XScroll\n     * @return {XScroll}\n     */\n    initTouchAction: function() {\n        var self = this;\n        self.mc.set({\n            touchAction: self.userConfig.touchAction\n        });\n        return self;\n    },\n    initFixed: function() {\n        var self = this,\n            userConfig = self.userConfig;\n        self.fixed = self.fixed || new Fixed({\n            fixedElements:userConfig.fixedElements,\n            xscroll:self,\n            fixedRenderTo:userConfig.fixedRenderTo\n        });\n        self.fixed.render();\n        self.resetSize();\n        return self;\n    },\n    initSticky:function(){\n        var self = this,userConfig = self.userConfig;\n        var sticky = self.sticky = self.sticky || new Sticky({\n            xscroll:self,\n            zoomType:userConfig.zoomType,\n            stickyRenderTo:userConfig.stickyRenderTo\n        });\n        sticky.render();\n    },\n    /**\n     * bounce to the boundry vertical and horizontal\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    boundryCheck: function() {\n        return this;\n    },\n    /**\n     * bounce to the boundry horizontal\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    boundryCheckX: function() {\n        return this;\n    },\n    /**\n     * bounce to the boundry vertical\n     * @memberof XScroll\n     * @return {XScroll}\n     **/\n    boundryCheckY: function() {\n        return this;\n    },\n    _bindEvt: function() {\n        var self = this;\n        if (self.___isEvtBind) return;\n        self.___isEvtBind = true;\n        var mc = self.mc = new Hammer.Manager(self.renderTo);\n        var tap = new Hammer.Tap();\n        var pan = new Hammer.Pan();\n        var pinch = new Hammer.Pinch();\n        mc.add([tap, pan]);\n        //trigger all events \n        self.mc.on(\"panstart pan panend pancancel pinchstart pinchmove pinchend pinchcancel pinchin pinchout\", function(e) {\n            self.trigger(e.type, e);\n        });\n        //trigger touch events\n        var touchEvents = ['touchstart', 'touchmove', 'touchend', 'touchcancel','mousedown'];\n        for (var i = 0, l = touchEvents.length; i < l; i++) {\n            self.renderTo.addEventListener(touchEvents[i], function(e) {\n                self.trigger(e.type, e);\n            });\n        }\n        self.mc.on(\"tap\", function(e) {\n            if (e.tapCount == 1) {\n                e.type = \"tap\";\n                self.trigger(e.type, e);\n            } else if (e.tapCount == 2) {\n                e.type = \"doubletap\";\n                self.trigger(\"doubletap\", e);\n            }\n        });\n        return self;\n    },\n    _resetLockConfig: function() {},\n    stop: function() {}\n});\n\nif (typeof module == 'object' && module.exports) {\n    module.exports = XScroll;\n}\n/** ignored by jsdoc **/\nelse {\n    return XScroll;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/core.js\n// module id = 8\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\n//easing\nvar Easing = {\n\t\"linear\": [0, 0, 1, 1],\n\t\"ease\": [.25, .1, .25, 1],\n\t\"ease-in\":[.42,0,1,1],\n\t\"ease-out\": [0, 0, .58, 1],\n\t\"ease-in-out\": [.42, 0, .58, 1],\n\t\"quadratic\": [0.33, 0.66, 0.66, 1],\n\t\"circular\": [0.1, 0.57, 0.1, 1],\n\t\"bounce\": [.71, 1.35, .47, 1.41],\n\tformat: function(easing) {\n\t\tif (!easing) return;\n\t\tif (typeof easing === \"string\" && this[easing]) {\n\t\t\treturn this[easing] instanceof Array ? [\" cubic-bezier(\", this[easing], \") \"].join(\"\") : this[easing];\n\t\t}\n\t\tif (easing instanceof Array) {\n\t\t\treturn [\" cubic-bezier(\", easing, \") \"].join(\"\");\n\t\t}\n\t\treturn easing;\n\t}\n}\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Easing;\n}\n/** ignored by jsdoc **/\n else {\n\treturn Easing;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/easing.js\n// module id = 9\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util');\nvar Base = require('./base');\nvar Easing = require('./easing');\n\nvar RAF = window.requestAnimationFrame ||\n\twindow.webkitRequestAnimationFrame ||\n\twindow.mozRequestAnimationFrame ||\n\twindow.oRequestAnimationFrame ||\n\twindow.msRequestAnimationFrame ||\n\tfunction(callback) {\n\t\twindow.setTimeout(callback, 1000 / 60);\n\t};\n\nvar vendors = ['webkit', 'moz', 'ms', 'o'];\nvar cancelRAF = window.cancelAnimationFrame;\nfor (var i = 0; i < vendors.length; i++) {\n\tif (window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame']) {\n\t\tcancelRAF = window[vendors[i] + 'CancelAnimationFrame'] || window[vendors[i] + 'CancelRequestAnimationFrame'];\n\t}\n}\ncancelRAF = cancelRAF || window.clearTimeout;\n\nfunction Bezier(x1, y1, x2, y2, epsilon) {\n\tvar curveX = function(t) {\n\t\tvar v = 1 - t;\n\t\treturn 3 * v * v * t * x1 + 3 * v * t * t * x2 + t * t * t;\n\t};\n\n\tvar curveY = function(t) {\n\t\tvar v = 1 - t;\n\t\treturn 3 * v * v * t * y1 + 3 * v * t * t * y2 + t * t * t;\n\t};\n\n\tvar derivativeCurveX = function(t) {\n\t\tvar v = 1 - t;\n\t\treturn 3 * (2 * (t - 1) * t + v * v) * x1 + 3 * (-t * t * t + 2 * v * t) * x2;\n\t};\n\n\treturn function(t) {\n\n\t\tvar x = t,\n\t\t\tt0, t1, t2, x2, d2, i;\n\n\t\t// First try a few iterations of Newton's method -- normally very fast.\n\t\tfor (t2 = x, i = 0; i < 8; i++) {\n\t\t\tx2 = curveX(t2) - x;\n\t\t\tif (Math.abs(x2) < epsilon) return curveY(t2);\n\t\t\td2 = derivativeCurveX(t2);\n\t\t\tif (Math.abs(d2) < 1e-6) break;\n\t\t\tt2 = t2 - x2 / d2;\n\t\t}\n\n\t\tt0 = 0, t1 = 1, t2 = x;\n\n\t\tif (t2 < t0) return curveY(t0);\n\t\tif (t2 > t1) return curveY(t1);\n\n\t\t// Fallback to the bisection method for reliability.\n\t\twhile (t0 < t1) {\n\t\t\tx2 = curveX(t2);\n\t\t\tif (Math.abs(x2 - x) < epsilon) return curveY(t2);\n\t\t\tif (x > x2) t0 = t2;\n\t\t\telse t1 = t2;\n\t\t\tt2 = (t1 - t0) * .5 + t0;\n\t\t}\n\n\t\t// Failure\n\t\treturn curveY(t2);\n\n\t};\n\n};\n\n\n\nfunction Timer(cfg) {\n\tvar self = this;\n\tself.cfg = Util.mix({\n\t\teasing: \"linear\"\n\t}, cfg)\n}\n\nTimer.MIN_DURATION = 1;\n\nUtil.extend(Timer, Base, {\n\treset: function(cfg) {\n\t\tvar self = this;\n\t\tUtil.mix(self.cfg, cfg);\n\t\tself.isfinished = false;\n\t\tself.percent = 0;\n\t\tself._stop = null;\n\t},\n\trun: function() {\n\t\tvar self = this;\n\t\tvar duration = self.cfg.duration;\n\t\tif (duration <= Timer.MIN_DURATION) {\n\t\t\tself.isfinished = true;\n\t\t\tself.trigger(\"run\", {\n\t\t\t\tpercent: 1\n\t\t\t});\n\t\t\tself.trigger(\"end\", {\n\t\t\t\tpercent: 1\n\t\t\t});\n\t\t}\n\t\tif (self.isfinished) return;\n\t\tself._hasFinishedPercent = self._stop && self._stop.percent || 0;\n\t\tself._stop = null;\n\t\tself.start = Date.now();\n\t\tself.percent = 0;\n\t\t// epsilon determines the precision of the solved values\n\t\tvar epsilon = (1000 / 60 / duration) / 4;\n\t\tvar b = Easing[self.cfg.easing];\n\t\tself.easingFn = Bezier(b[0], b[1], b[2], b[3], epsilon);\n\t\tself._run();\n\t},\n\t_run: function() {\n\t\tvar self = this;\n\t\tcancelRAF(self._raf);\n\t\tself._raf = RAF(function() {\n\t\t\tself.now = Date.now();\n\t\t\tself.duration = self.now - self.start >= self.cfg.duration ? self.cfg.duration : self.now - self.start;\n\t\t\tself.progress = self.easingFn(self.duration / self.cfg.duration);\n\t\t\tself.percent = self.duration / self.cfg.duration + self._hasFinishedPercent;\n\t\t\tif (self.percent >= 1 || self._stop) {\n\t\t\t\tself.percent = self._stop && self._stop.percent ? self._stop.percent : 1;\n\t\t\t\tself.duration = self._stop && self._stop.duration ? self._stop.duration : self.duration;\n\t\t\t\tvar param = {\n\t\t\t\t\tpercent: self.percent\n\t\t\t\t};\n\t\t\t\tself.trigger(\"stop\", param);\n\t\t\t\tif (self.percent >= 1) {\n\t\t\t\t\tself.isfinished = true;\n\t\t\t\t\tself.trigger(\"end\", {\n\t\t\t\t\t\tpercent: 1\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tself.trigger(\"run\", {\n\t\t\t\tpercent: self.progress,\n\t\t\t\toriginPercent:self.percent\n\t\t\t});\n\t\t\tself._run();\n\t\t})\n\t},\n\tstop: function() {\n\t\tvar self = this;\n\t\tself._stop = {\n\t\t\tpercent: self.percent,\n\t\t\tnow: self.now\n\t\t};\n\t\tcancelRAF(self._raf)\n\t}\n});\n\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Timer;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Timer;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/timer.js\n// module id = 10\n// module chunks = 0","import ReactXScroll from 'components/react-xscroll';\n\nexport default class ReactXScrollCtrl {\n  static getInstance(inHandle){\n    return ReactXScroll.getInstance(inHandle);\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/components/react-xscroll-ctrl.js","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".xs-plugin-pulldown-container{text-align:center;width:100%;line-height:50px}.xs-plugin-pulldown-up .up{display:inline}.xs-plugin-pulldown-down .up,.xs-plugin-pulldown-up .down{display:none}.xs-plugin-pulldown-down .down{display:inline}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/autoprefixer-loader!./~/sass-loader!./src/components/style.plug.pulldown.scss\n// module id = 12\n// module chunks = 0","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".xs-plugin-pullup-container{line-height:40px;text-align:center}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/autoprefixer-loader!./~/sass-loader!./src/components/style.plug.pullup.scss\n// module id = 13\n// module chunks = 0","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/autoprefixer-loader!./~/sass-loader!./src/components/style.scss\n// module id = 14\n// module chunks = 0","/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\r\n(function(global, factory) {\r\n    if(exports === 'object' && typeof module !== 'undefined')\r\n        module.exports = factory(global)\r\n    if (typeof define === 'function' && define.amd)\r\n        define(function() { return factory(global) })\r\n    else\r\n        factory(global)\r\n}( typeof window !== \"undefined\" ? window : this, function(window) {\r\n    var Zepto = (function() {\r\n        var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\r\n            document = window.document,\r\n            elementDisplay = {}, classCache = {},\r\n            cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\r\n            fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\r\n            singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\r\n            tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\r\n            rootNodeRE = /^(?:body|html)$/i,\r\n            capitalRE = /([A-Z])/g,\r\n\r\n            // special attributes that should be get/set via method calls\r\n            methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\r\n\r\n            adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\r\n            table = document.createElement('table'),\r\n            tableRow = document.createElement('tr'),\r\n            containers = {\r\n                'tr': document.createElement('tbody'),\r\n                'tbody': table, 'thead': table, 'tfoot': table,\r\n                'td': tableRow, 'th': tableRow,\r\n                '*': document.createElement('div')\r\n            },\r\n            readyRE = /complete|loaded|interactive/,\r\n            simpleSelectorRE = /^[\\w-]*$/,\r\n            class2type = {},\r\n            toString = class2type.toString,\r\n            zepto = {},\r\n            camelize, uniq,\r\n            tempParent = document.createElement('div'),\r\n            propMap = {\r\n                'tabindex': 'tabIndex',\r\n                'readonly': 'readOnly',\r\n                'for': 'htmlFor',\r\n                'class': 'className',\r\n                'maxlength': 'maxLength',\r\n                'cellspacing': 'cellSpacing',\r\n                'cellpadding': 'cellPadding',\r\n                'rowspan': 'rowSpan',\r\n                'colspan': 'colSpan',\r\n                'usemap': 'useMap',\r\n                'frameborder': 'frameBorder',\r\n                'contenteditable': 'contentEditable'\r\n            },\r\n            isArray = Array.isArray ||\r\n                function(object){ return object instanceof Array }\r\n\r\n        zepto.matches = function(element, selector) {\r\n            if (!selector || !element || element.nodeType !== 1) return false\r\n            var matchesSelector = element.matches || element.webkitMatchesSelector ||\r\n                element.mozMatchesSelector || element.oMatchesSelector ||\r\n                element.matchesSelector\r\n            if (matchesSelector) return matchesSelector.call(element, selector)\r\n            // fall back to performing a selector:\r\n            var match, parent = element.parentNode, temp = !parent\r\n            if (temp) (parent = tempParent).appendChild(element)\r\n            match = ~zepto.qsa(parent, selector).indexOf(element)\r\n            temp && tempParent.removeChild(element)\r\n            return match\r\n        }\r\n\r\n        function type(obj) {\r\n            return obj == null ? String(obj) :\r\n            class2type[toString.call(obj)] || \"object\"\r\n        }\r\n\r\n        function isFunction(value) { return type(value) == \"function\" }\r\n        function isWindow(obj)     { return obj != null && obj == obj.window }\r\n        function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\r\n        function isObject(obj)     { return type(obj) == \"object\" }\r\n        function isPlainObject(obj) {\r\n            return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\r\n        }\r\n\r\n        function likeArray(obj) {\r\n            var length = !!obj && 'length' in obj && obj.length,\r\n                type = $.type(obj)\r\n\r\n            return 'function' != type && !isWindow(obj) && (\r\n                    'array' == type || length === 0 ||\r\n                    (typeof length == 'number' && length > 0 && (length - 1) in obj)\r\n                )\r\n        }\r\n\r\n        function compact(array) { return filter.call(array, function(item){ return item != null }) }\r\n        function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\r\n        camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\r\n        function dasherize(str) {\r\n            return str.replace(/::/g, '/')\r\n                .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\r\n                .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\r\n                .replace(/_/g, '-')\r\n                .toLowerCase()\r\n        }\r\n        uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\r\n\r\n        function classRE(name) {\r\n            return name in classCache ?\r\n                classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\r\n        }\r\n\r\n        function maybeAddPx(name, value) {\r\n            return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\r\n        }\r\n\r\n        function defaultDisplay(nodeName) {\r\n            var element, display\r\n            if (!elementDisplay[nodeName]) {\r\n                element = document.createElement(nodeName)\r\n                document.body.appendChild(element)\r\n                display = getComputedStyle(element, '').getPropertyValue(\"display\")\r\n                element.parentNode.removeChild(element)\r\n                display == \"none\" && (display = \"block\")\r\n                elementDisplay[nodeName] = display\r\n            }\r\n            return elementDisplay[nodeName]\r\n        }\r\n\r\n        function children(element) {\r\n            return 'children' in element ?\r\n                slice.call(element.children) :\r\n                $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\r\n        }\r\n\r\n        function Z(dom, selector) {\r\n            var i, len = dom ? dom.length : 0\r\n            for (i = 0; i < len; i++) this[i] = dom[i]\r\n            this.length = len\r\n            this.selector = selector || ''\r\n        }\r\n\r\n        // `$.zepto.fragment` takes a html string and an optional tag name\r\n        // to generate DOM nodes from the given html string.\r\n        // The generated DOM nodes are returned as an array.\r\n        // This function can be overridden in plugins for example to make\r\n        // it compatible with browsers that don't support the DOM fully.\r\n        zepto.fragment = function(html, name, properties) {\r\n            var dom, nodes, container\r\n\r\n            // A special case optimization for a single tag\r\n            if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\r\n\r\n            if (!dom) {\r\n                if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\r\n                if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\r\n                if (!(name in containers)) name = '*'\r\n\r\n                container = containers[name]\r\n                container.innerHTML = '' + html\r\n                dom = $.each(slice.call(container.childNodes), function(){\r\n                    container.removeChild(this)\r\n                })\r\n            }\r\n\r\n            if (isPlainObject(properties)) {\r\n                nodes = $(dom)\r\n                $.each(properties, function(key, value) {\r\n                    if (methodAttributes.indexOf(key) > -1) nodes[key](value)\r\n                    else nodes.attr(key, value)\r\n                })\r\n            }\r\n\r\n            return dom\r\n        }\r\n\r\n        // `$.zepto.Z` swaps out the prototype of the given `dom` array\r\n        // of nodes with `$.fn` and thus supplying all the Zepto functions\r\n        // to the array. This method can be overridden in plugins.\r\n        zepto.Z = function(dom, selector) {\r\n            return new Z(dom, selector)\r\n        }\r\n\r\n        // `$.zepto.isZ` should return `true` if the given object is a Zepto\r\n        // collection. This method can be overridden in plugins.\r\n        zepto.isZ = function(object) {\r\n            return object instanceof zepto.Z\r\n        }\r\n\r\n        // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\r\n        // takes a CSS selector and an optional context (and handles various\r\n        // special cases).\r\n        // This method can be overridden in plugins.\r\n        zepto.init = function(selector, context) {\r\n            var dom\r\n            // If nothing given, return an empty Zepto collection\r\n            if (!selector) return zepto.Z()\r\n            // Optimize for string selectors\r\n            else if (typeof selector == 'string') {\r\n                selector = selector.trim()\r\n                // If it's a html fragment, create nodes from it\r\n                // Note: In both Chrome 21 and Firefox 15, DOM error 12\r\n                // is thrown if the fragment doesn't begin with <\r\n                if (selector[0] == '<' && fragmentRE.test(selector))\r\n                    dom = zepto.fragment(selector, RegExp.$1, context), selector = null\r\n                // If there's a context, create a collection on that context first, and select\r\n                // nodes from there\r\n                else if (context !== undefined) return $(context).find(selector)\r\n                // If it's a CSS selector, use it to select nodes.\r\n                else dom = zepto.qsa(document, selector)\r\n            }\r\n            // If a function is given, call it when the DOM is ready\r\n            else if (isFunction(selector)) return $(document).ready(selector)\r\n            // If a Zepto collection is given, just return it\r\n            else if (zepto.isZ(selector)) return selector\r\n            else {\r\n                // normalize array if an array of nodes is given\r\n                if (isArray(selector)) dom = compact(selector)\r\n                // Wrap DOM nodes.\r\n                else if (isObject(selector))\r\n                    dom = [selector], selector = null\r\n                // If it's a html fragment, create nodes from it\r\n                else if (fragmentRE.test(selector))\r\n                    dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\r\n                // If there's a context, create a collection on that context first, and select\r\n                // nodes from there\r\n                else if (context !== undefined) return $(context).find(selector)\r\n                // And last but no least, if it's a CSS selector, use it to select nodes.\r\n                else dom = zepto.qsa(document, selector)\r\n            }\r\n            // create a new Zepto collection from the nodes found\r\n            return zepto.Z(dom, selector)\r\n        }\r\n\r\n        // `$` will be the base `Zepto` object. When calling this\r\n        // function just call `$.zepto.init, which makes the implementation\r\n        // details of selecting nodes and creating Zepto collections\r\n        // patchable in plugins.\r\n        $ = function(selector, context){\r\n            return zepto.init(selector, context)\r\n        }\r\n\r\n        function extend(target, source, deep) {\r\n            for (key in source)\r\n                if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n                    if (isPlainObject(source[key]) && !isPlainObject(target[key]))\r\n                        target[key] = {}\r\n                    if (isArray(source[key]) && !isArray(target[key]))\r\n                        target[key] = []\r\n                    extend(target[key], source[key], deep)\r\n                }\r\n                else if (source[key] !== undefined) target[key] = source[key]\r\n        }\r\n\r\n        // Copy all but undefined properties from one or more\r\n        // objects to the `target` object.\r\n        $.extend = function(target){\r\n            var deep, args = slice.call(arguments, 1)\r\n            if (typeof target == 'boolean') {\r\n                deep = target\r\n                target = args.shift()\r\n            }\r\n            args.forEach(function(arg){ extend(target, arg, deep) })\r\n            return target\r\n        }\r\n\r\n        // `$.zepto.qsa` is Zepto's CSS selector implementation which\r\n        // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\r\n        // This method can be overridden in plugins.\r\n        zepto.qsa = function(element, selector){\r\n            var found,\r\n                maybeID = selector[0] == '#',\r\n                maybeClass = !maybeID && selector[0] == '.',\r\n                nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\r\n                isSimple = simpleSelectorRE.test(nameOnly)\r\n            return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\r\n                ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\r\n                (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\r\n                    slice.call(\r\n                        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\r\n                            maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\r\n                                element.getElementsByTagName(selector) : // Or a tag\r\n                            element.querySelectorAll(selector) // Or it's not simple, and we need to query all\r\n                    )\r\n        }\r\n\r\n        function filtered(nodes, selector) {\r\n            return selector == null ? $(nodes) : $(nodes).filter(selector)\r\n        }\r\n\r\n        $.contains = document.documentElement.contains ?\r\n            function(parent, node) {\r\n                return parent !== node && parent.contains(node)\r\n            } :\r\n            function(parent, node) {\r\n                while (node && (node = node.parentNode))\r\n                    if (node === parent) return true\r\n                return false\r\n            }\r\n\r\n        function funcArg(context, arg, idx, payload) {\r\n            return isFunction(arg) ? arg.call(context, idx, payload) : arg\r\n        }\r\n\r\n        function setAttribute(node, name, value) {\r\n            value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\r\n        }\r\n\r\n        // access className property while respecting SVGAnimatedString\r\n        function className(node, value){\r\n            var klass = node.className || '',\r\n                svg   = klass && klass.baseVal !== undefined\r\n\r\n            if (value === undefined) return svg ? klass.baseVal : klass\r\n            svg ? (klass.baseVal = value) : (node.className = value)\r\n        }\r\n\r\n        // \"true\"  => true\r\n        // \"false\" => false\r\n        // \"null\"  => null\r\n        // \"42\"    => 42\r\n        // \"42.5\"  => 42.5\r\n        // \"08\"    => \"08\"\r\n        // JSON    => parse if valid\r\n        // String  => self\r\n        function deserializeValue(value) {\r\n            try {\r\n                return value ?\r\n                value == \"true\" ||\r\n                ( value == \"false\" ? false :\r\n                    value == \"null\" ? null :\r\n                        +value + \"\" == value ? +value :\r\n                            /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\r\n                                value )\r\n                    : value\r\n            } catch(e) {\r\n                return value\r\n            }\r\n        }\r\n\r\n        $.type = type\r\n        $.isFunction = isFunction\r\n        $.isWindow = isWindow\r\n        $.isArray = isArray\r\n        $.isPlainObject = isPlainObject\r\n\r\n        $.isEmptyObject = function(obj) {\r\n            var name\r\n            for (name in obj) return false\r\n            return true\r\n        }\r\n\r\n        $.isNumeric = function(val) {\r\n            var num = Number(val), type = typeof val\r\n            return val != null && type != 'boolean' &&\r\n                (type != 'string' || val.length) &&\r\n                !isNaN(num) && isFinite(num) || false\r\n        }\r\n\r\n        $.inArray = function(elem, array, i){\r\n            return emptyArray.indexOf.call(array, elem, i)\r\n        }\r\n\r\n        $.camelCase = camelize\r\n        $.trim = function(str) {\r\n            return str == null ? \"\" : String.prototype.trim.call(str)\r\n        }\r\n\r\n        // plugin compatibility\r\n        $.uuid = 0\r\n        $.support = { }\r\n        $.expr = { }\r\n        $.noop = function() {}\r\n\r\n        $.map = function(elements, callback){\r\n            var value, values = [], i, key\r\n            if (likeArray(elements))\r\n                for (i = 0; i < elements.length; i++) {\r\n                    value = callback(elements[i], i)\r\n                    if (value != null) values.push(value)\r\n                }\r\n            else\r\n                for (key in elements) {\r\n                    value = callback(elements[key], key)\r\n                    if (value != null) values.push(value)\r\n                }\r\n            return flatten(values)\r\n        }\r\n\r\n        $.each = function(elements, callback){\r\n            var i, key\r\n            if (likeArray(elements)) {\r\n                for (i = 0; i < elements.length; i++)\r\n                    if (callback.call(elements[i], i, elements[i]) === false) return elements\r\n            } else {\r\n                for (key in elements)\r\n                    if (callback.call(elements[key], key, elements[key]) === false) return elements\r\n            }\r\n\r\n            return elements\r\n        }\r\n\r\n        $.grep = function(elements, callback){\r\n            return filter.call(elements, callback)\r\n        }\r\n\r\n        if (window.JSON) $.parseJSON = JSON.parse\r\n\r\n        // Populate the class2type map\r\n        $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\r\n            class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\r\n        })\r\n\r\n        // Define methods that will be available on all\r\n        // Zepto collections\r\n        $.fn = {\r\n            constructor: zepto.Z,\r\n            length: 0,\r\n\r\n            // Because a collection acts like an array\r\n            // copy over these useful array functions.\r\n            forEach: emptyArray.forEach,\r\n            reduce: emptyArray.reduce,\r\n            push: emptyArray.push,\r\n            sort: emptyArray.sort,\r\n            splice: emptyArray.splice,\r\n            indexOf: emptyArray.indexOf,\r\n            concat: function(){\r\n                var i, value, args = []\r\n                for (i = 0; i < arguments.length; i++) {\r\n                    value = arguments[i]\r\n                    args[i] = zepto.isZ(value) ? value.toArray() : value\r\n                }\r\n                return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\r\n            },\r\n\r\n            // `map` and `slice` in the jQuery API work differently\r\n            // from their array counterparts\r\n            map: function(fn){\r\n                return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\r\n            },\r\n            slice: function(){\r\n                return $(slice.apply(this, arguments))\r\n            },\r\n\r\n            ready: function(callback){\r\n                // need to check if document.body exists for IE as that browser reports\r\n                // document ready when it hasn't yet created the body element\r\n                if (readyRE.test(document.readyState) && document.body) callback($)\r\n                else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\r\n                return this\r\n            },\r\n            get: function(idx){\r\n                return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\r\n            },\r\n            toArray: function(){ return this.get() },\r\n            size: function(){\r\n                return this.length\r\n            },\r\n            remove: function(){\r\n                return this.each(function(){\r\n                    if (this.parentNode != null)\r\n                        this.parentNode.removeChild(this)\r\n                })\r\n            },\r\n            each: function(callback){\r\n                emptyArray.every.call(this, function(el, idx){\r\n                    return callback.call(el, idx, el) !== false\r\n                })\r\n                return this\r\n            },\r\n            filter: function(selector){\r\n                if (isFunction(selector)) return this.not(this.not(selector))\r\n                return $(filter.call(this, function(element){\r\n                    return zepto.matches(element, selector)\r\n                }))\r\n            },\r\n            add: function(selector,context){\r\n                return $(uniq(this.concat($(selector,context))))\r\n            },\r\n            is: function(selector){\r\n                return this.length > 0 && zepto.matches(this[0], selector)\r\n            },\r\n            not: function(selector){\r\n                var nodes=[]\r\n                if (isFunction(selector) && selector.call !== undefined)\r\n                    this.each(function(idx){\r\n                        if (!selector.call(this,idx)) nodes.push(this)\r\n                    })\r\n                else {\r\n                    var excludes = typeof selector == 'string' ? this.filter(selector) :\r\n                        (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\r\n                    this.forEach(function(el){\r\n                        if (excludes.indexOf(el) < 0) nodes.push(el)\r\n                    })\r\n                }\r\n                return $(nodes)\r\n            },\r\n            has: function(selector){\r\n                return this.filter(function(){\r\n                    return isObject(selector) ?\r\n                        $.contains(this, selector) :\r\n                        $(this).find(selector).size()\r\n                })\r\n            },\r\n            eq: function(idx){\r\n                return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\r\n            },\r\n            first: function(){\r\n                var el = this[0]\r\n                return el && !isObject(el) ? el : $(el)\r\n            },\r\n            last: function(){\r\n                var el = this[this.length - 1]\r\n                return el && !isObject(el) ? el : $(el)\r\n            },\r\n            find: function(selector){\r\n                var result, $this = this\r\n                if (!selector) result = $()\r\n                else if (typeof selector == 'object')\r\n                    result = $(selector).filter(function(){\r\n                        var node = this\r\n                        return emptyArray.some.call($this, function(parent){\r\n                            return $.contains(parent, node)\r\n                        })\r\n                    })\r\n                else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\r\n                else result = this.map(function(){ return zepto.qsa(this, selector) })\r\n                return result\r\n            },\r\n            closest: function(selector, context){\r\n                var nodes = [], collection = typeof selector == 'object' && $(selector)\r\n                this.each(function(_, node){\r\n                    while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\r\n                        node = node !== context && !isDocument(node) && node.parentNode\r\n                    if (node && nodes.indexOf(node) < 0) nodes.push(node)\r\n                })\r\n                return $(nodes)\r\n            },\r\n            parents: function(selector){\r\n                var ancestors = [], nodes = this\r\n                while (nodes.length > 0)\r\n                    nodes = $.map(nodes, function(node){\r\n                        if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\r\n                            ancestors.push(node)\r\n                            return node\r\n                        }\r\n                    })\r\n                return filtered(ancestors, selector)\r\n            },\r\n            parent: function(selector){\r\n                return filtered(uniq(this.pluck('parentNode')), selector)\r\n            },\r\n            children: function(selector){\r\n                return filtered(this.map(function(){ return children(this) }), selector)\r\n            },\r\n            contents: function() {\r\n                return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\r\n            },\r\n            siblings: function(selector){\r\n                return filtered(this.map(function(i, el){\r\n                    return filter.call(children(el.parentNode), function(child){ return child!==el })\r\n                }), selector)\r\n            },\r\n            empty: function(){\r\n                return this.each(function(){ this.innerHTML = '' })\r\n            },\r\n            // `pluck` is borrowed from Prototype.js\r\n            pluck: function(property){\r\n                return $.map(this, function(el){ return el[property] })\r\n            },\r\n            show: function(){\r\n                return this.each(function(){\r\n                    this.style.display == \"none\" && (this.style.display = '')\r\n                    if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\r\n                        this.style.display = defaultDisplay(this.nodeName)\r\n                })\r\n            },\r\n            replaceWith: function(newContent){\r\n                return this.before(newContent).remove()\r\n            },\r\n            wrap: function(structure){\r\n                var func = isFunction(structure)\r\n                if (this[0] && !func)\r\n                    var dom   = $(structure).get(0),\r\n                        clone = dom.parentNode || this.length > 1\r\n\r\n                return this.each(function(index){\r\n                    $(this).wrapAll(\r\n                        func ? structure.call(this, index) :\r\n                            clone ? dom.cloneNode(true) : dom\r\n                    )\r\n                })\r\n            },\r\n            wrapAll: function(structure){\r\n                if (this[0]) {\r\n                    $(this[0]).before(structure = $(structure))\r\n                    var children\r\n                    // drill down to the inmost element\r\n                    while ((children = structure.children()).length) structure = children.first()\r\n                    $(structure).append(this)\r\n                }\r\n                return this\r\n            },\r\n            wrapInner: function(structure){\r\n                var func = isFunction(structure)\r\n                return this.each(function(index){\r\n                    var self = $(this), contents = self.contents(),\r\n                        dom  = func ? structure.call(this, index) : structure\r\n                    contents.length ? contents.wrapAll(dom) : self.append(dom)\r\n                })\r\n            },\r\n            unwrap: function(){\r\n                this.parent().each(function(){\r\n                    $(this).replaceWith($(this).children())\r\n                })\r\n                return this\r\n            },\r\n            clone: function(){\r\n                return this.map(function(){ return this.cloneNode(true) })\r\n            },\r\n            hide: function(){\r\n                return this.css(\"display\", \"none\")\r\n            },\r\n            toggle: function(setting){\r\n                return this.each(function(){\r\n                    var el = $(this)\r\n                        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\r\n                })\r\n            },\r\n            prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\r\n            next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\r\n            html: function(html){\r\n                return 0 in arguments ?\r\n                    this.each(function(idx){\r\n                        var originHtml = this.innerHTML\r\n                        $(this).empty().append( funcArg(this, html, idx, originHtml) )\r\n                    }) :\r\n                    (0 in this ? this[0].innerHTML : null)\r\n            },\r\n            text: function(text){\r\n                return 0 in arguments ?\r\n                    this.each(function(idx){\r\n                        var newText = funcArg(this, text, idx, this.textContent)\r\n                        this.textContent = newText == null ? '' : ''+newText\r\n                    }) :\r\n                    (0 in this ? this.pluck('textContent').join(\"\") : null)\r\n            },\r\n            attr: function(name, value){\r\n                var result\r\n                return (typeof name == 'string' && !(1 in arguments)) ?\r\n                    (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\r\n                    this.each(function(idx){\r\n                        if (this.nodeType !== 1) return\r\n                        if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\r\n                        else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\r\n                    })\r\n            },\r\n            removeAttr: function(name){\r\n                return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\r\n                    setAttribute(this, attribute)\r\n                }, this)})\r\n            },\r\n            prop: function(name, value){\r\n                name = propMap[name] || name\r\n                return (1 in arguments) ?\r\n                    this.each(function(idx){\r\n                        this[name] = funcArg(this, value, idx, this[name])\r\n                    }) :\r\n                    (this[0] && this[0][name])\r\n            },\r\n            removeProp: function(name){\r\n                name = propMap[name] || name\r\n                return this.each(function(){ delete this[name] })\r\n            },\r\n            data: function(name, value){\r\n                var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\r\n\r\n                var data = (1 in arguments) ?\r\n                    this.attr(attrName, value) :\r\n                    this.attr(attrName)\r\n\r\n                return data !== null ? deserializeValue(data) : undefined\r\n            },\r\n            val: function(value){\r\n                if (0 in arguments) {\r\n                    if (value == null) value = \"\"\r\n                    return this.each(function(idx){\r\n                        this.value = funcArg(this, value, idx, this.value)\r\n                    })\r\n                } else {\r\n                    return this[0] && (this[0].multiple ?\r\n                            $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\r\n                            this[0].value)\r\n                }\r\n            },\r\n            offset: function(coordinates){\r\n                if (coordinates) return this.each(function(index){\r\n                    var $this = $(this),\r\n                        coords = funcArg(this, coordinates, index, $this.offset()),\r\n                        parentOffset = $this.offsetParent().offset(),\r\n                        props = {\r\n                            top:  coords.top  - parentOffset.top,\r\n                            left: coords.left - parentOffset.left\r\n                        }\r\n\r\n                    if ($this.css('position') == 'static') props['position'] = 'relative'\r\n                    $this.css(props)\r\n                })\r\n                if (!this.length) return null\r\n                if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\r\n                    return {top: 0, left: 0}\r\n                var obj = this[0].getBoundingClientRect()\r\n                return {\r\n                    left: obj.left + window.pageXOffset,\r\n                    top: obj.top + window.pageYOffset,\r\n                    width: Math.round(obj.width),\r\n                    height: Math.round(obj.height)\r\n                }\r\n            },\r\n            css: function(property, value){\r\n                if (arguments.length < 2) {\r\n                    var element = this[0]\r\n                    if (typeof property == 'string') {\r\n                        if (!element) return\r\n                        return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\r\n                    } else if (isArray(property)) {\r\n                        if (!element) return\r\n                        var props = {}\r\n                        var computedStyle = getComputedStyle(element, '')\r\n                        $.each(property, function(_, prop){\r\n                            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\r\n                        })\r\n                        return props\r\n                    }\r\n                }\r\n\r\n                var css = ''\r\n                if (type(property) == 'string') {\r\n                    if (!value && value !== 0)\r\n                        this.each(function(){ this.style.removeProperty(dasherize(property)) })\r\n                    else\r\n                        css = dasherize(property) + \":\" + maybeAddPx(property, value)\r\n                } else {\r\n                    for (key in property)\r\n                        if (!property[key] && property[key] !== 0)\r\n                            this.each(function(){ this.style.removeProperty(dasherize(key)) })\r\n                        else\r\n                            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\r\n                }\r\n\r\n                return this.each(function(){ this.style.cssText += ';' + css })\r\n            },\r\n            index: function(element){\r\n                return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\r\n            },\r\n            hasClass: function(name){\r\n                if (!name) return false\r\n                return emptyArray.some.call(this, function(el){\r\n                    return this.test(className(el))\r\n                }, classRE(name))\r\n            },\r\n            addClass: function(name){\r\n                if (!name) return this\r\n                return this.each(function(idx){\r\n                    if (!('className' in this)) return\r\n                    classList = []\r\n                    var cls = className(this), newName = funcArg(this, name, idx, cls)\r\n                    newName.split(/\\s+/g).forEach(function(klass){\r\n                        if (!$(this).hasClass(klass)) classList.push(klass)\r\n                    }, this)\r\n                    classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\r\n                })\r\n            },\r\n            removeClass: function(name){\r\n                return this.each(function(idx){\r\n                    if (!('className' in this)) return\r\n                    if (name === undefined) return className(this, '')\r\n                    classList = className(this)\r\n                    funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\r\n                        classList = classList.replace(classRE(klass), \" \")\r\n                    })\r\n                    className(this, classList.trim())\r\n                })\r\n            },\r\n            toggleClass: function(name, when){\r\n                if (!name) return this\r\n                return this.each(function(idx){\r\n                    var $this = $(this), names = funcArg(this, name, idx, className(this))\r\n                    names.split(/\\s+/g).forEach(function(klass){\r\n                        (when === undefined ? !$this.hasClass(klass) : when) ?\r\n                            $this.addClass(klass) : $this.removeClass(klass)\r\n                    })\r\n                })\r\n            },\r\n            scrollTop: function(value){\r\n                if (!this.length) return\r\n                var hasScrollTop = 'scrollTop' in this[0]\r\n                if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\r\n                return this.each(hasScrollTop ?\r\n                    function(){ this.scrollTop = value } :\r\n                    function(){ this.scrollTo(this.scrollX, value) })\r\n            },\r\n            scrollLeft: function(value){\r\n                if (!this.length) return\r\n                var hasScrollLeft = 'scrollLeft' in this[0]\r\n                if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\r\n                return this.each(hasScrollLeft ?\r\n                    function(){ this.scrollLeft = value } :\r\n                    function(){ this.scrollTo(value, this.scrollY) })\r\n            },\r\n            position: function() {\r\n                if (!this.length) return\r\n\r\n                var elem = this[0],\r\n                    // Get *real* offsetParent\r\n                    offsetParent = this.offsetParent(),\r\n                    // Get correct offsets\r\n                    offset       = this.offset(),\r\n                    parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\r\n\r\n                // Subtract element margins\r\n                // note: when an element has margin: auto the offsetLeft and marginLeft\r\n                // are the same in Safari causing offset.left to incorrectly be 0\r\n                offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\r\n                offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\r\n\r\n                // Add offsetParent borders\r\n                parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\r\n                parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\r\n\r\n                // Subtract the two offsets\r\n                return {\r\n                    top:  offset.top  - parentOffset.top,\r\n                    left: offset.left - parentOffset.left\r\n                }\r\n            },\r\n            offsetParent: function() {\r\n                return this.map(function(){\r\n                    var parent = this.offsetParent || document.body\r\n                    while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\r\n                        parent = parent.offsetParent\r\n                    return parent\r\n                })\r\n            }\r\n        }\r\n\r\n        // for now\r\n        $.fn.detach = $.fn.remove\r\n\r\n        // Generate the `width` and `height` functions\r\n        ;['width', 'height'].forEach(function(dimension){\r\n            var dimensionProperty =\r\n                dimension.replace(/./, function(m){ return m[0].toUpperCase() })\r\n\r\n            $.fn[dimension] = function(value){\r\n                var offset, el = this[0]\r\n                if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\r\n                    isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\r\n                    (offset = this.offset()) && offset[dimension]\r\n                else return this.each(function(idx){\r\n                    el = $(this)\r\n                    el.css(dimension, funcArg(this, value, idx, el[dimension]()))\r\n                })\r\n            }\r\n        })\r\n\r\n        function traverseNode(node, fun) {\r\n            fun(node)\r\n            for (var i = 0, len = node.childNodes.length; i < len; i++)\r\n                traverseNode(node.childNodes[i], fun)\r\n        }\r\n\r\n        // Generate the `after`, `prepend`, `before`, `append`,\r\n        // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\r\n        adjacencyOperators.forEach(function(operator, operatorIndex) {\r\n            var inside = operatorIndex % 2 //=> prepend, append\r\n\r\n            $.fn[operator] = function(){\r\n                // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\r\n                var argType, nodes = $.map(arguments, function(arg) {\r\n                        var arr = []\r\n                        argType = type(arg)\r\n                        if (argType == \"array\") {\r\n                            arg.forEach(function(el) {\r\n                                if (el.nodeType !== undefined) return arr.push(el)\r\n                                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\r\n                                arr = arr.concat(zepto.fragment(el))\r\n                            })\r\n                            return arr\r\n                        }\r\n                        return argType == \"object\" || arg == null ?\r\n                            arg : zepto.fragment(arg)\r\n                    }),\r\n                    parent, copyByClone = this.length > 1\r\n                if (nodes.length < 1) return this\r\n\r\n                return this.each(function(_, target){\r\n                    parent = inside ? target : target.parentNode\r\n\r\n                    // convert all methods to a \"before\" operation\r\n                    target = operatorIndex == 0 ? target.nextSibling :\r\n                        operatorIndex == 1 ? target.firstChild :\r\n                            operatorIndex == 2 ? target :\r\n                                null\r\n\r\n                    var parentInDocument = $.contains(document.documentElement, parent)\r\n\r\n                    nodes.forEach(function(node){\r\n                        if (copyByClone) node = node.cloneNode(true)\r\n                        else if (!parent) return $(node).remove()\r\n\r\n                        parent.insertBefore(node, target)\r\n                        if (parentInDocument) traverseNode(node, function(el){\r\n                            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\r\n                                (!el.type || el.type === 'text/javascript') && !el.src){\r\n                                var target = el.ownerDocument ? el.ownerDocument.defaultView : window\r\n                                target['eval'].call(target, el.innerHTML)\r\n                            }\r\n                        })\r\n                    })\r\n                })\r\n            }\r\n\r\n            // after    => insertAfter\r\n            // prepend  => prependTo\r\n            // before   => insertBefore\r\n            // append   => appendTo\r\n            $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\r\n                $(html)[operator](this)\r\n                return this\r\n            }\r\n        })\r\n\r\n        zepto.Z.prototype = Z.prototype = $.fn\r\n\r\n        // Export internal API functions in the `$.zepto` namespace\r\n        zepto.uniq = uniq\r\n        zepto.deserializeValue = deserializeValue\r\n        $.zepto = zepto\r\n\r\n        return $\r\n    })()\r\n\r\n    window.Zepto = Zepto\r\n    window.$ === undefined && (window.$ = Zepto)\r\n\r\n    ;(function($){\r\n        var _zid = 1, undefined,\r\n            slice = Array.prototype.slice,\r\n            isFunction = $.isFunction,\r\n            isString = function(obj){ return typeof obj == 'string' },\r\n            handlers = {},\r\n            specialEvents={},\r\n            focusinSupported = 'onfocusin' in window,\r\n            focus = { focus: 'focusin', blur: 'focusout' },\r\n            hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\r\n\r\n        specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\r\n\r\n        function zid(element) {\r\n            return element._zid || (element._zid = _zid++)\r\n        }\r\n        function findHandlers(element, event, fn, selector) {\r\n            event = parse(event)\r\n            if (event.ns) var matcher = matcherFor(event.ns)\r\n            return (handlers[zid(element)] || []).filter(function(handler) {\r\n                return handler\r\n                    && (!event.e  || handler.e == event.e)\r\n                    && (!event.ns || matcher.test(handler.ns))\r\n                    && (!fn       || zid(handler.fn) === zid(fn))\r\n                    && (!selector || handler.sel == selector)\r\n            })\r\n        }\r\n        function parse(event) {\r\n            var parts = ('' + event).split('.')\r\n            return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\r\n        }\r\n        function matcherFor(ns) {\r\n            return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\r\n        }\r\n\r\n        function eventCapture(handler, captureSetting) {\r\n            return handler.del &&\r\n                (!focusinSupported && (handler.e in focus)) ||\r\n                !!captureSetting\r\n        }\r\n\r\n        function realEvent(type) {\r\n            return hover[type] || (focusinSupported && focus[type]) || type\r\n        }\r\n\r\n        function add(element, events, fn, data, selector, delegator, capture){\r\n            var id = zid(element), set = (handlers[id] || (handlers[id] = []))\r\n            events.split(/\\s/).forEach(function(event){\r\n                if (event == 'ready') return $(document).ready(fn)\r\n                var handler   = parse(event)\r\n                handler.fn    = fn\r\n                handler.sel   = selector\r\n                // emulate mouseenter, mouseleave\r\n                if (handler.e in hover) fn = function(e){\r\n                    var related = e.relatedTarget\r\n                    if (!related || (related !== this && !$.contains(this, related)))\r\n                        return handler.fn.apply(this, arguments)\r\n                }\r\n                handler.del   = delegator\r\n                var callback  = delegator || fn\r\n                handler.proxy = function(e){\r\n                    e = compatible(e)\r\n                    if (e.isImmediatePropagationStopped()) return\r\n                    e.data = data\r\n                    var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\r\n                    if (result === false) e.preventDefault(), e.stopPropagation()\r\n                    return result\r\n                }\r\n                handler.i = set.length\r\n                set.push(handler)\r\n                if ('addEventListener' in element)\r\n                    element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\r\n            })\r\n        }\r\n        function remove(element, events, fn, selector, capture){\r\n            var id = zid(element)\r\n                ;(events || '').split(/\\s/).forEach(function(event){\r\n                findHandlers(element, event, fn, selector).forEach(function(handler){\r\n                    delete handlers[id][handler.i]\r\n                    if ('removeEventListener' in element)\r\n                        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\r\n                })\r\n            })\r\n        }\r\n\r\n        $.event = { add: add, remove: remove }\r\n\r\n        $.proxy = function(fn, context) {\r\n            var args = (2 in arguments) && slice.call(arguments, 2)\r\n            if (isFunction(fn)) {\r\n                var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\r\n                proxyFn._zid = zid(fn)\r\n                return proxyFn\r\n            } else if (isString(context)) {\r\n                if (args) {\r\n                    args.unshift(fn[context], fn)\r\n                    return $.proxy.apply(null, args)\r\n                } else {\r\n                    return $.proxy(fn[context], fn)\r\n                }\r\n            } else {\r\n                throw new TypeError(\"expected function\")\r\n            }\r\n        }\r\n\r\n        $.fn.bind = function(event, data, callback){\r\n            return this.on(event, data, callback)\r\n        }\r\n        $.fn.unbind = function(event, callback){\r\n            return this.off(event, callback)\r\n        }\r\n        $.fn.one = function(event, selector, data, callback){\r\n            return this.on(event, selector, data, callback, 1)\r\n        }\r\n\r\n        var returnTrue = function(){return true},\r\n            returnFalse = function(){return false},\r\n            ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\r\n            eventMethods = {\r\n                preventDefault: 'isDefaultPrevented',\r\n                stopImmediatePropagation: 'isImmediatePropagationStopped',\r\n                stopPropagation: 'isPropagationStopped'\r\n            }\r\n\r\n        function compatible(event, source) {\r\n            if (source || !event.isDefaultPrevented) {\r\n                source || (source = event)\r\n\r\n                $.each(eventMethods, function(name, predicate) {\r\n                    var sourceMethod = source[name]\r\n                    event[name] = function(){\r\n                        this[predicate] = returnTrue\r\n                        return sourceMethod && sourceMethod.apply(source, arguments)\r\n                    }\r\n                    event[predicate] = returnFalse\r\n                })\r\n\r\n                event.timeStamp || (event.timeStamp = Date.now())\r\n\r\n                if (source.defaultPrevented !== undefined ? source.defaultPrevented :\r\n                        'returnValue' in source ? source.returnValue === false :\r\n                        source.getPreventDefault && source.getPreventDefault())\r\n                    event.isDefaultPrevented = returnTrue\r\n            }\r\n            return event\r\n        }\r\n\r\n        function createProxy(event) {\r\n            var key, proxy = { originalEvent: event }\r\n            for (key in event)\r\n                if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\r\n\r\n            return compatible(proxy, event)\r\n        }\r\n\r\n        $.fn.delegate = function(selector, event, callback){\r\n            return this.on(event, selector, callback)\r\n        }\r\n        $.fn.undelegate = function(selector, event, callback){\r\n            return this.off(event, selector, callback)\r\n        }\r\n\r\n        $.fn.live = function(event, callback){\r\n            $(document.body).delegate(this.selector, event, callback)\r\n            return this\r\n        }\r\n        $.fn.die = function(event, callback){\r\n            $(document.body).undelegate(this.selector, event, callback)\r\n            return this\r\n        }\r\n\r\n        $.fn.on = function(event, selector, data, callback, one){\r\n            var autoRemove, delegator, $this = this\r\n            if (event && !isString(event)) {\r\n                $.each(event, function(type, fn){\r\n                    $this.on(type, selector, data, fn, one)\r\n                })\r\n                return $this\r\n            }\r\n\r\n            if (!isString(selector) && !isFunction(callback) && callback !== false)\r\n                callback = data, data = selector, selector = undefined\r\n            if (callback === undefined || data === false)\r\n                callback = data, data = undefined\r\n\r\n            if (callback === false) callback = returnFalse\r\n\r\n            return $this.each(function(_, element){\r\n                if (one) autoRemove = function(e){\r\n                    remove(element, e.type, callback)\r\n                    return callback.apply(this, arguments)\r\n                }\r\n\r\n                if (selector) delegator = function(e){\r\n                    var evt, match = $(e.target).closest(selector, element).get(0)\r\n                    if (match && match !== element) {\r\n                        evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\r\n                        return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\r\n                    }\r\n                }\r\n\r\n                add(element, event, callback, data, selector, delegator || autoRemove)\r\n            })\r\n        }\r\n        $.fn.off = function(event, selector, callback){\r\n            var $this = this\r\n            if (event && !isString(event)) {\r\n                $.each(event, function(type, fn){\r\n                    $this.off(type, selector, fn)\r\n                })\r\n                return $this\r\n            }\r\n\r\n            if (!isString(selector) && !isFunction(callback) && callback !== false)\r\n                callback = selector, selector = undefined\r\n\r\n            if (callback === false) callback = returnFalse\r\n\r\n            return $this.each(function(){\r\n                remove(this, event, callback, selector)\r\n            })\r\n        }\r\n\r\n        $.fn.trigger = function(event, args){\r\n            event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\r\n            event._args = args\r\n            return this.each(function(){\r\n                // handle focus(), blur() by calling them directly\r\n                if (event.type in focus && typeof this[event.type] == \"function\") this[event.type]()\r\n                // items in the collection might not be DOM elements\r\n                else if ('dispatchEvent' in this) this.dispatchEvent(event)\r\n                else $(this).triggerHandler(event, args)\r\n            })\r\n        }\r\n\r\n        // triggers event handlers on current element just as if an event occurred,\r\n        // doesn't trigger an actual event, doesn't bubble\r\n        $.fn.triggerHandler = function(event, args){\r\n            var e, result\r\n            this.each(function(i, element){\r\n                e = createProxy(isString(event) ? $.Event(event) : event)\r\n                e._args = args\r\n                e.target = element\r\n                $.each(findHandlers(element, event.type || event), function(i, handler){\r\n                    result = handler.proxy(e)\r\n                    if (e.isImmediatePropagationStopped()) return false\r\n                })\r\n            })\r\n            return result\r\n        }\r\n\r\n        // shortcut methods for `.bind(event, fn)` for each event type\r\n        ;('focusin focusout focus blur load resize scroll unload click dblclick '+\r\n        'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\r\n        'change select keydown keypress keyup error').split(' ').forEach(function(event) {\r\n            $.fn[event] = function(callback) {\r\n                return (0 in arguments) ?\r\n                    this.bind(event, callback) :\r\n                    this.trigger(event)\r\n            }\r\n        })\r\n\r\n        $.Event = function(type, props) {\r\n            if (!isString(type)) props = type, type = props.type\r\n            var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\r\n            if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\r\n            event.initEvent(type, bubbles, true)\r\n            return compatible(event)\r\n        }\r\n\r\n    })(Zepto)\r\n\r\n    ;(function($){\r\n        var jsonpID = +new Date(),\r\n            document = window.document,\r\n            key,\r\n            name,\r\n            rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\r\n            scriptTypeRE = /^(?:text|application)\\/javascript/i,\r\n            xmlTypeRE = /^(?:text|application)\\/xml/i,\r\n            jsonType = 'application/json',\r\n            htmlType = 'text/html',\r\n            blankRE = /^\\s*$/,\r\n            originAnchor = document.createElement('a')\r\n\r\n        originAnchor.href = window.location.href\r\n\r\n        // trigger a custom event and return false if it was cancelled\r\n        function triggerAndReturn(context, eventName, data) {\r\n            var event = $.Event(eventName)\r\n            $(context).trigger(event, data)\r\n            return !event.isDefaultPrevented()\r\n        }\r\n\r\n        // trigger an Ajax \"global\" event\r\n        function triggerGlobal(settings, context, eventName, data) {\r\n            if (settings.global) return triggerAndReturn(context || document, eventName, data)\r\n        }\r\n\r\n        // Number of active Ajax requests\r\n        $.active = 0\r\n\r\n        function ajaxStart(settings) {\r\n            if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\r\n        }\r\n        function ajaxStop(settings) {\r\n            if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\r\n        }\r\n\r\n        // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\r\n        function ajaxBeforeSend(xhr, settings) {\r\n            var context = settings.context\r\n            if (settings.beforeSend.call(context, xhr, settings) === false ||\r\n                triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\r\n                return false\r\n\r\n            triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\r\n        }\r\n        function ajaxSuccess(data, xhr, settings, deferred) {\r\n            var context = settings.context, status = 'success'\r\n            settings.success.call(context, data, status, xhr)\r\n            if (deferred) deferred.resolveWith(context, [data, status, xhr])\r\n            triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\r\n            ajaxComplete(status, xhr, settings)\r\n        }\r\n        // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\r\n        function ajaxError(error, type, xhr, settings, deferred) {\r\n            var context = settings.context\r\n            settings.error.call(context, xhr, type, error)\r\n            if (deferred) deferred.rejectWith(context, [xhr, type, error])\r\n            triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\r\n            ajaxComplete(type, xhr, settings)\r\n        }\r\n        // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\r\n        function ajaxComplete(status, xhr, settings) {\r\n            var context = settings.context\r\n            settings.complete.call(context, xhr, status)\r\n            triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\r\n            ajaxStop(settings)\r\n        }\r\n\r\n        function ajaxDataFilter(data, type, settings) {\r\n            if (settings.dataFilter == empty) return data\r\n            var context = settings.context\r\n            return settings.dataFilter.call(context, data, type)\r\n        }\r\n\r\n        // Empty function, used as default callback\r\n        function empty() {}\r\n\r\n        $.ajaxJSONP = function(options, deferred){\r\n            if (!('type' in options)) return $.ajax(options)\r\n\r\n            var _callbackName = options.jsonpCallback,\r\n                callbackName = ($.isFunction(_callbackName) ?\r\n                        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\r\n                script = document.createElement('script'),\r\n                originalCallback = window[callbackName],\r\n                responseData,\r\n                abort = function(errorType) {\r\n                    $(script).triggerHandler('error', errorType || 'abort')\r\n                },\r\n                xhr = { abort: abort }, abortTimeout\r\n\r\n            if (deferred) deferred.promise(xhr)\r\n\r\n            $(script).on('load error', function(e, errorType){\r\n                clearTimeout(abortTimeout)\r\n                $(script).off().remove()\r\n\r\n                if (e.type == 'error' || !responseData) {\r\n                    ajaxError(null, errorType || 'error', xhr, options, deferred)\r\n                } else {\r\n                    ajaxSuccess(responseData[0], xhr, options, deferred)\r\n                }\r\n\r\n                window[callbackName] = originalCallback\r\n                if (responseData && $.isFunction(originalCallback))\r\n                    originalCallback(responseData[0])\r\n\r\n                originalCallback = responseData = undefined\r\n            })\r\n\r\n            if (ajaxBeforeSend(xhr, options) === false) {\r\n                abort('abort')\r\n                return xhr\r\n            }\r\n\r\n            window[callbackName] = function(){\r\n                responseData = arguments\r\n            }\r\n\r\n            script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName)\r\n            document.head.appendChild(script)\r\n\r\n            if (options.timeout > 0) abortTimeout = setTimeout(function(){\r\n                abort('timeout')\r\n            }, options.timeout)\r\n\r\n            return xhr\r\n        }\r\n\r\n        $.ajaxSettings = {\r\n            // Default type of request\r\n            type: 'GET',\r\n            // Callback that is executed before request\r\n            beforeSend: empty,\r\n            // Callback that is executed if the request succeeds\r\n            success: empty,\r\n            // Callback that is executed the the server drops error\r\n            error: empty,\r\n            // Callback that is executed on request complete (both: error and success)\r\n            complete: empty,\r\n            // The context for the callbacks\r\n            context: null,\r\n            // Whether to trigger \"global\" Ajax events\r\n            global: true,\r\n            // Transport\r\n            xhr: function () {\r\n                return new window.XMLHttpRequest()\r\n            },\r\n            // MIME types mapping\r\n            // IIS returns Javascript as \"application/x-javascript\"\r\n            accepts: {\r\n                script: 'text/javascript, application/javascript, application/x-javascript',\r\n                json:   jsonType,\r\n                xml:    'application/xml, text/xml',\r\n                html:   htmlType,\r\n                text:   'text/plain'\r\n            },\r\n            // Whether the request is to another domain\r\n            crossDomain: false,\r\n            // Default timeout\r\n            timeout: 0,\r\n            // Whether data should be serialized to string\r\n            processData: true,\r\n            // Whether the browser should be allowed to cache GET responses\r\n            cache: true,\r\n            //Used to handle the raw response data of XMLHttpRequest.\r\n            //This is a pre-filtering function to sanitize the response.\r\n            //The sanitized response should be returned\r\n            dataFilter: empty\r\n        }\r\n\r\n        function mimeToDataType(mime) {\r\n            if (mime) mime = mime.split(';', 2)[0]\r\n            return mime && ( mime == htmlType ? 'html' :\r\n                    mime == jsonType ? 'json' :\r\n                        scriptTypeRE.test(mime) ? 'script' :\r\n                        xmlTypeRE.test(mime) && 'xml' ) || 'text'\r\n        }\r\n\r\n        function appendQuery(url, query) {\r\n            if (query == '') return url\r\n            return (url + '&' + query).replace(/[&?]{1,2}/, '?')\r\n        }\r\n\r\n        // serialize payload and append it to the URL for GET requests\r\n        function serializeData(options) {\r\n            if (options.processData && options.data && $.type(options.data) != \"string\")\r\n                options.data = $.param(options.data, options.traditional)\r\n            if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\r\n                options.url = appendQuery(options.url, options.data), options.data = undefined\r\n        }\r\n\r\n        $.ajax = function(options){\r\n            var settings = $.extend({}, options || {}),\r\n                deferred = $.Deferred && $.Deferred(),\r\n                urlAnchor, hashIndex\r\n            for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\r\n\r\n            ajaxStart(settings)\r\n\r\n            if (!settings.crossDomain) {\r\n                urlAnchor = document.createElement('a')\r\n                urlAnchor.href = settings.url\r\n                // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\r\n                urlAnchor.href = urlAnchor.href\r\n                settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\r\n            }\r\n\r\n            if (!settings.url) settings.url = window.location.toString()\r\n            if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\r\n            serializeData(settings)\r\n\r\n            var dataType = settings.dataType, hasPlaceholder = /\\?.+=\\?/.test(settings.url)\r\n            if (hasPlaceholder) dataType = 'jsonp'\r\n\r\n            if (settings.cache === false || (\r\n                    (!options || options.cache !== true) &&\r\n                    ('script' == dataType || 'jsonp' == dataType)\r\n                ))\r\n                settings.url = appendQuery(settings.url, '_=' + Date.now())\r\n\r\n            if ('jsonp' == dataType) {\r\n                if (!hasPlaceholder)\r\n                    settings.url = appendQuery(settings.url,\r\n                        settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\r\n                return $.ajaxJSONP(settings, deferred)\r\n            }\r\n\r\n            var mime = settings.accepts[dataType],\r\n                headers = { },\r\n                setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\r\n                protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\r\n                xhr = settings.xhr(),\r\n                nativeSetHeader = xhr.setRequestHeader,\r\n                abortTimeout\r\n\r\n            if (deferred) deferred.promise(xhr)\r\n\r\n            if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\r\n            setHeader('Accept', mime || '*/*')\r\n            if (mime = settings.mimeType || mime) {\r\n                if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\r\n                xhr.overrideMimeType && xhr.overrideMimeType(mime)\r\n            }\r\n            if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\r\n                setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\r\n\r\n            if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\r\n            xhr.setRequestHeader = setHeader\r\n\r\n            xhr.onreadystatechange = function(){\r\n                if (xhr.readyState == 4) {\r\n                    xhr.onreadystatechange = empty\r\n                    clearTimeout(abortTimeout)\r\n                    var result, error = false\r\n                    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\r\n                        dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\r\n\r\n                        if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\r\n                            result = xhr.response\r\n                        else {\r\n                            result = xhr.responseText\r\n\r\n                            try {\r\n                                // http://perfectionkills.com/global-eval-what-are-the-options/\r\n                                // sanitize response accordingly if data filter callback provided\r\n                                result = ajaxDataFilter(result, dataType, settings)\r\n                                if (dataType == 'script')    (1,eval)(result)\r\n                                else if (dataType == 'xml')  result = xhr.responseXML\r\n                                else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\r\n                            } catch (e) { error = e }\r\n\r\n                            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\r\n                        }\r\n\r\n                        ajaxSuccess(result, xhr, settings, deferred)\r\n                    } else {\r\n                        ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (ajaxBeforeSend(xhr, settings) === false) {\r\n                xhr.abort()\r\n                ajaxError(null, 'abort', xhr, settings, deferred)\r\n                return xhr\r\n            }\r\n\r\n            var async = 'async' in settings ? settings.async : true\r\n            xhr.open(settings.type, settings.url, async, settings.username, settings.password)\r\n\r\n            if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\r\n\r\n            for (name in headers) nativeSetHeader.apply(xhr, headers[name])\r\n\r\n            if (settings.timeout > 0) abortTimeout = setTimeout(function(){\r\n                xhr.onreadystatechange = empty\r\n                xhr.abort()\r\n                ajaxError(null, 'timeout', xhr, settings, deferred)\r\n            }, settings.timeout)\r\n\r\n            // avoid sending empty string (#319)\r\n            xhr.send(settings.data ? settings.data : null)\r\n            return xhr\r\n        }\r\n\r\n        // handle optional data/success arguments\r\n        function parseArguments(url, data, success, dataType) {\r\n            if ($.isFunction(data)) dataType = success, success = data, data = undefined\r\n            if (!$.isFunction(success)) dataType = success, success = undefined\r\n            return {\r\n                url: url\r\n                , data: data\r\n                , success: success\r\n                , dataType: dataType\r\n            }\r\n        }\r\n\r\n        $.get = function(/* url, data, success, dataType */){\r\n            return $.ajax(parseArguments.apply(null, arguments))\r\n        }\r\n\r\n        $.post = function(/* url, data, success, dataType */){\r\n            var options = parseArguments.apply(null, arguments)\r\n            options.type = 'POST'\r\n            return $.ajax(options)\r\n        }\r\n\r\n        $.getJSON = function(/* url, data, success */){\r\n            var options = parseArguments.apply(null, arguments)\r\n            options.dataType = 'json'\r\n            return $.ajax(options)\r\n        }\r\n\r\n        $.fn.load = function(url, data, success){\r\n            if (!this.length) return this\r\n            var self = this, parts = url.split(/\\s/), selector,\r\n                options = parseArguments(url, data, success),\r\n                callback = options.success\r\n            if (parts.length > 1) options.url = parts[0], selector = parts[1]\r\n            options.success = function(response){\r\n                self.html(selector ?\r\n                    $('<div>').html(response.replace(rscript, \"\")).find(selector)\r\n                    : response)\r\n                callback && callback.apply(self, arguments)\r\n            }\r\n            $.ajax(options)\r\n            return this\r\n        }\r\n\r\n        var escape = encodeURIComponent\r\n\r\n        function serialize(params, obj, traditional, scope){\r\n            var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\r\n            $.each(obj, function(key, value) {\r\n                type = $.type(value)\r\n                if (scope) key = traditional ? scope :\r\n                scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\r\n                // handle data in serializeArray() format\r\n                if (!scope && array) params.add(value.name, value.value)\r\n                // recurse into nested objects\r\n                else if (type == \"array\" || (!traditional && type == \"object\"))\r\n                    serialize(params, value, traditional, key)\r\n                else params.add(key, value)\r\n            })\r\n        }\r\n\r\n        $.param = function(obj, traditional){\r\n            var params = []\r\n            params.add = function(key, value) {\r\n                if ($.isFunction(value)) value = value()\r\n                if (value == null) value = \"\"\r\n                this.push(escape(key) + '=' + escape(value))\r\n            }\r\n            serialize(params, obj, traditional)\r\n            return params.join('&').replace(/%20/g, '+')\r\n        }\r\n    })(Zepto)\r\n\r\n    ;(function($){\r\n        $.fn.serializeArray = function() {\r\n            var name, type, result = [],\r\n                add = function(value) {\r\n                    if (value.forEach) return value.forEach(add)\r\n                    result.push({ name: name, value: value })\r\n                }\r\n            if (this[0]) $.each(this[0].elements, function(_, field){\r\n                type = field.type, name = field.name\r\n                if (name && field.nodeName.toLowerCase() != 'fieldset' &&\r\n                    !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\r\n                    ((type != 'radio' && type != 'checkbox') || field.checked))\r\n                    add($(field).val())\r\n            })\r\n            return result\r\n        }\r\n\r\n        $.fn.serialize = function(){\r\n            var result = []\r\n            this.serializeArray().forEach(function(elm){\r\n                result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\r\n            })\r\n            return result.join('&')\r\n        }\r\n\r\n        $.fn.submit = function(callback) {\r\n            if (0 in arguments) this.bind('submit', callback)\r\n            else if (this.length) {\r\n                var event = $.Event('submit')\r\n                this.eq(0).trigger(event)\r\n                if (!event.isDefaultPrevented()) this.get(0).submit()\r\n            }\r\n            return this\r\n        }\r\n\r\n    })(Zepto)\r\n\r\n    ;(function(){\r\n        // getComputedStyle shouldn't freak out when called\r\n        // without a valid element as argument\r\n        try {\r\n            getComputedStyle(undefined)\r\n        } catch(e) {\r\n            var nativeGetComputedStyle = getComputedStyle\r\n            window.getComputedStyle = function(element, pseudoElement){\r\n                try {\r\n                    return nativeGetComputedStyle(element, pseudoElement)\r\n                } catch(e) {\r\n                    return null\r\n                }\r\n            }\r\n        }\r\n    })()\r\n    return Zepto\r\n}))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/n-zepto/n-zepto.js\n// module id = 15\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pulldown.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/style.plug.pulldown.scss\n// module id = 16\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.plug.pullup.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/style.plug.pullup.scss\n// module id = 17\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/autoprefixer-loader/index.js!./../../node_modules/sass-loader/index.js!./style.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/style.scss\n// module id = 18\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\n var Util = require('./util');\n\n function Boundry(cfg) {\n     this.cfg = Util.mix({\n         width: 0,\n         height: 0\n     }, cfg)\n     this.init();\n }\n Util.mix(Boundry.prototype, {\n     init: function() {\n         var self = this;\n         self._xtop = 0;\n         self._xright = 0;\n         self._xleft = 0;\n         self._xbottom = 0;\n         self.refresh({\n             width: self.cfg.width,\n             height: self.cfg.height\n         });\n     },\n     reset: function() {\n         this.resetTop();\n         this.resetLeft();\n         this.resetBottom();\n         this.resetRight();\n         return this;\n     },\n     resetTop: function() {\n         this._xtop = 0;\n         this.refresh();\n         return this;\n     },\n     resetLeft: function() {\n         this._xleft = 0;\n         this.refresh();\n         return this;\n     },\n     resetBottom: function() {\n         this._xbottom = 0;\n         this.refresh();\n         return this;\n     },\n     resetRight: function() {\n         this._xright = 0;\n         this.refresh();\n         return this;\n     },\n     expandTop: function(top) {\n         this._xtop = top;\n         this.refresh();\n         return this;\n     },\n     expandLeft: function(left) {\n         this._xleft = left;\n         this.refresh();\n         return this;\n     },\n     expandRight: function(right) {\n         this._xright = right;\n         this.refresh();\n         return this;\n     },\n     expandBottom: function(bottom) {\n         this._xbottom = bottom;\n         this.refresh();\n         return this;\n     },\n     refresh: function(cfg) {\n         Util.mix(this.cfg, cfg);\n         this.top = this._xtop;\n         this.left = this._xleft;\n         this.bottom = (cfg && cfg.height || this.cfg.height || 0) - this._xbottom;\n         this.right = (cfg && cfg.width || this.cfg.width || 0) - this._xright;\n         this.width = this.right - this.left > 0 ? this.right - this.left : 0;\n         this.height = this.bottom - this.top > 0 ? this.bottom - this.top : 0;\n         return this;\n     }\n });\n\n\n if (typeof module == 'object' && module.exports) {\n     module.exports = Boundry;\n }\n /** ignored by jsdoc **/\n else{\n    return Boundry;\n }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/boundry.js\n// module id = 19\n// module chunks = 0","define(function(require, exports, module) {\n/*\n\twrapped scroll controller\n*/\n\"use strict\";\nvar Util = require('../util'),\n\tBase = require('../base');\n\nvar Controller = function(cfg) {\n\tController.superclass.constructor.call(this, cfg);\n\tthis.userConfig = Util.mix({}, cfg);\n\tthis.init();\n}\n\nUtil.extend(Controller, Base, {\n\tinit: function() {\n\t\tvar self = this;\n\t\tself.xscroll = self.userConfig.xscroll;\n\t},\n\tadd: function(scroll, cfg) {\n\t\tvar self = this;\n\t\tcfg = Util.extend({\n\t\t\tcaptureBounce: false,\n\t\t\tstopPropagation: true\n\t\t}, cfg)\n\t\tif (!self.__scrolls) {\n\t\t\tself.__scrolls = {};\n\t\t}\n\t\tif (scroll.guid && !self.__scrolls[scroll.guid]) {\n\t\t\tscroll.parentscroll = self.xscroll;\n\t\t\tself._bind(scroll);\n\t\t\treturn self.__scrolls[scroll.guid] = scroll;\n\t\t}\n\t\treturn;\n\t},\n\tremove: function(scroll) {\n\t\tvar self = this;\n\t\tif (!scroll || !scroll.guid) return;\n\t\tvar subscroll = self.__scrolls[scroll.guid];\n\t\tif (subscroll) {\n\t\t\tsubscroll.parentscroll = null;\n\t\t\tself._unbind(scroll);\n\t\t\tsubscroll = null;\n\t\t}\n\t},\n\tget: function(guid) {\n\t\tif (guid) {\n\t\t\treturn this.__scrolls[guid];\n\t\t}\n\t\treturn this.__scrolls;\n\t},\n\n\t_unbind: function(sub) {\n\n\t},\n\n\t_bind: function(sub) {\n\t\tvar self = this,\n\t\t\txscroll = self.xscroll;\n\t\txscroll.renderTo.addEventListener(\"touchstart\", function() {\n\t\t\txscroll._resetLockConfig();\n\t\t});\n\t\tsub.renderTo.addEventListener(\"touchstart\", function() {\n\t\t\tsub._resetLockConfig();\n\t\t});\n\t\txscroll.on(\"panend\", xscroll._resetLockConfig);\n\t\tsub.on(\"panend\", sub._resetLockConfig);\n\t\tsub.on(\"panstart\", function(e) {\n\t\t\t//vertical scroll enabled\n\t\t\tif (!sub.userConfig.lockY && !xscroll.userConfig.lockY) {\n\t\t\t\t//outside of boundry\n\t\t\t\tif (sub.isBoundryOut()) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (e.direction == 16 && sub.getBoundryOutTop() >= 0) {\n\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t} else if (e.direction == 8 && sub.getBoundryOutTop() >= 0 && sub.getBoundryOutBottom() < 0) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t}\n\t\t\t\tif (e.direction == 8 && sub.getBoundryOutBottom() >= 0) {\n\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t} else if (e.direction == 16 && sub.getBoundryOutBottom() >= 0 && sub.getBoundryOutTop() < 0) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t}\n\t\t\t\tif (sub.getBoundryOutTop() < 0 && sub.getBoundryOutBottom() < 0) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//horizontal scroll enabled\n\t\t\tif (!sub.userConfig.lockX && !xscroll.userConfig.lockX) {\n\t\t\t\tif (sub.isBoundryOut()) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (e.direction == 4 && sub.getBoundryOutLeft() >= 0) {\n\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t} else if (e.direction == 2 && sub.getBoundryOutLeft() >= 0 && sub.getBoundryOutRight() < 0) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t}\n\t\t\t\tif (e.direction == 2 && sub.getBoundryOutRight() >= 0) {\n\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t} else if (e.direction == 4 && sub.getBoundryOutRight() >= 0 && sub.getBoundryOutLeft() < 0) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t}\n\t\t\t\tif (sub.getBoundryOutLeft() < 0 && sub.getBoundryOutRight() < 0) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!sub.userConfig.lockX && xscroll.userConfig.lockX) {\n\t\t\t\t//pan x\n\t\t\t\tif (e.direction == 2 || e.direction == 4) {\n\t\t\t\t\txscroll.userConfig.lockY = true;\n\t\t\t\t} else {\n\t\t\t\t\tsub.userConfig.lockX = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!sub.userConfig.lockY && xscroll.userConfig.lockY) {\n\t\t\t\t//pan y\n\t\t\t\tif (e.direction == 8 || e.direction == 16) {\n\t\t\t\t\txscroll.userConfig.lockX = true;\n\t\t\t\t} else {\n\t\t\t\t\tsub.userConfig.lockY = true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Controller;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn Controller;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/components/controller.js\n// module id = 20\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Base = require('../base');\nvar transform = Util.prefixStyle(\"transform\");\n\nvar Fixed = function(cfg) {\n  Fixed.superclass.constructor.call(this, cfg);\n  this.userConfig = Util.mix({\n    fixedRenderTo: undefined,\n    fixedElements: \".xs-fixed\",\n    prefix: \"xs-fixed-container\",\n    zoomType: \"y\"\n  }, cfg);\n  this.init();\n}\n\nUtil.extend(Fixed, Base, {\n  fixedElements: [],\n  init: function() {\n    var self = this,\n      userConfig = self.userConfig,\n      xscroll = self.xscroll = userConfig.xscroll,\n      xscrollConfig = self.xscrollConfig = xscroll.userConfig;\n    self.isY = !!(userConfig.zoomType == \"y\");\n    self._ = self.isY ? {\n      top: \"top\",\n      height: \"height\",\n      width: \"width\",\n      offsetTop:\"offsetTop\"\n    } : {\n      top: \"left\",\n      height: \"width\",\n      width: \"height\",\n      offsetTop:\"offsetLeft\"\n    };\n    self.fixedRenderTo = Util.getNode(userConfig.fixedRenderTo);\n    return self;\n  },\n  render: function() {\n    var self = this;\n    var xscroll = self.xscroll;\n    self.infinite = xscroll.getPlugin(\"infinite\");\n    if (!self.fixedRenderTo) {\n      self.fixedRenderTo = document.createElement('div');\n      xscroll.renderTo.appendChild(self.fixedRenderTo);\n    }\n    Util.addClass(self.fixedRenderTo, self.userConfig.prefix);\n    var originalFixedElements = self.originalFixedElements = self.getFixedElements();\n    for (var i = 0, l = originalFixedElements.length; i < l; i++) {\n      self.renderFixedElement(originalFixedElements[i], i,self.fixedRenderTo);\n    }\n    return self;\n  },\n  getFixedElements: function() {\n    var self = this;\n    var infinite = self.infinite;\n    var userConfig = self.userConfig;\n    if (infinite) {\n      var els = [];\n      for (var i in infinite.__serializedData) {\n        var data = infinite.__serializedData[i];\n        if (data && data.style && data.style.position == \"fixed\") {\n          els.push(data);\n        }\n      }\n      return els;\n    } else {\n      return Util.getNodes(userConfig.fixedElements, self.xscroll.content);\n    }\n  },\n  renderFixedElement: function(el, fixedIndex,fixedRenderTo) {\n    var self = this;\n    var isRender = true;\n    var _ = self._;\n    var xscroll = self.xscroll;\n    var userConfig = self.userConfig;\n    var xscrollConfig = self.xscrollConfig;\n    var useOriginScroll = xscrollConfig.useOriginScroll;\n    var infinite = self.infinite;\n    var fixedElement = self.fixedElements[fixedIndex];\n    if (!self.fixedElements[fixedIndex]) {\n      isRender = false;\n      if (useOriginScroll && !infinite) {\n        //use original position:fixed stylesheet\n        el.style.position = \"fixed\";\n        el.style.display = \"block\";\n      } else {\n        //deep clone fixed nodes and hide original nodes\n        fixedElement = document.createElement(\"div\");\n        if (infinite) {\n          fixedElement.setAttribute(\"style\", Util.stringifyStyle(Util.mix(el.style, {\n            display: \"block\",\n            width: \"100%\"\n          })));\n          fixedElement.style[_.top] = (el.style[_.top] >= 0 ? el.style[_.top] : el._top) + \"px\";\n          if (el.style[_.height]) {\n            fixedElement.style[_.height] = el.style[_.height] + \"px\";\n          }\n          infinite.userConfig.renderHook.call(self, fixedElement, el);\n        } else {\n          fixedElement.style.display = \"block\";\n          fixedElement.style.position = \"absolute\";\n          fixedElement.style[_.width] = \"100%\";\n          fixedElement.innerHTML = el.innerHTML;\n          fixedElement.className = el.className;\n          fixedElement.setAttribute(\"style\", el.getAttribute(\"style\"));\n          fixedElement.style[_.top] = el[_.offsetTop] + \"px\";\n          el.style.display = \"none\";\n        }\n        fixedRenderTo.appendChild(fixedElement);\n        self.fixedElements.push(fixedElement);\n      }\n    }\n    xscroll.trigger(\"fixedchange\", {\n      fixedIndex: fixedIndex,\n      fixedElement: useOriginScroll ? el : fixedElement,\n      originalFixedElement: el,\n      isRender: isRender\n    });\n  },\n  destroy: function() {\n    var self = this;\n    self.fixedElements = undefined;\n  }\n});\n\nif (typeof module == 'object' && module.exports) {\n  module.exports = Fixed;\n}\n/** ignored by jsdoc **/\nelse {\n  return Fixed;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/components/fixed.js\n// module id = 21\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Animate = require('../animate');\nvar MAX_BOUNCE_DISTANCE = 40;\nvar MIN_BAR_SCROLLED_SIZE = 10;\nvar MIN_BAR_SIZE = 50;\nvar transform = Util.prefixStyle(\"transform\");\nvar transformStr = Util.vendor ? [\"-\", Util.vendor, \"-transform\"].join(\"\") : \"transform\";\nvar transition = Util.prefixStyle(\"transition\");\nvar borderRadius = Util.prefixStyle(\"borderRadius\");\nvar transitionDuration = Util.prefixStyle(\"transitionDuration\");\n\nvar ScrollBar = function(cfg) {\n\tthis.userConfig = Util.mix({\n\t\tMIN_BAR_SCROLLED_SIZE:MIN_BAR_SCROLLED_SIZE,\n\t\tMIN_BAR_SIZE:MIN_BAR_SIZE,\n\t\tMAX_BOUNCE_DISTANCE:MAX_BOUNCE_DISTANCE,\n\t\tspacing:5\n\t}, cfg);\n\tthis.init(cfg.xscroll);\n}\n\nUtil.mix(ScrollBar.prototype, {\n\tinit: function(xscroll) {\n\t\tvar self = this;\n\t\tself.xscroll = xscroll;\n\t\tself.type = self.userConfig.type;\n\t\tself.isY = self.type == \"y\" ? true : false;\n\t\tself.scrollTopOrLeft = self.isY ? \"scrollTop\" : \"scrollLeft\";\n\t},\n\tdestroy: function() {\n\t\tvar self = this;\n\t\tUtil.remove(self.scrollbar);\n\t\tself.xscroll.off(\"scroll\", self._scrollHandler, self);\n\t\tself.xscroll.off(\"scrollend\", self._scrollEndHandler, self);\n\t},\n\trender: function() {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar boundry = xscroll.boundry;\n\t\tvar indicatorInsets = self.xscroll.userConfig.indicatorInsets;\n\t\tvar translateZ = xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\tvar transform = translateZ ? transformStr + \":\" + translateZ + \";\" : \"\";\n\t\tvar commonCss = \"opacity:0;position:absolute;z-index:999;overflow:hidden;-webkit-border-radius:3px;-moz-border-radius:3px;-o-border-radius:3px;\" + transform;\n\t\tindicatorInsets._xright =  indicatorInsets.right + indicatorInsets.spacing;\n\t\tindicatorInsets._xbottom =  indicatorInsets.bottom + indicatorInsets.spacing;\n\t\tvar css = self.isY ?\n\t\t\tUtil.substitute(\"width:{width}px;bottom:{_xbottom}px;top:{top}px;right:{right}px;\", indicatorInsets) + commonCss :\n\t\t\tUtil.substitute(\"height:{width}px;left:{left}px;right:{_xright}px;bottom:{bottom}px;\",indicatorInsets) + commonCss;\n\t\t\n\n\t\tif(!self.scrollbar){\n\t\t\tself.scrollbar = document.createElement(\"div\");\t\n\t\t\tself.indicate = document.createElement(\"div\");\n\t\t\txscroll.renderTo.appendChild(self.scrollbar);\n\t\t\tself.scrollbar.appendChild(self.indicate);\n\t\t}\n\t\tself.scrollbar.style.cssText = css;\n\t\tvar size = self.isY ? \"width:100%;\" : \"height:100%;\";\n\t\tself.indicate.style.cssText = size + \"position:absolute;background:rgba(0,0,0,0.3);-webkit-border-radius:3px;-moz-border-radius:3px;-o-border-radius:3px;\"\n\t\tself._update();\n\t\tself.hide(0);\n\t\tself._bindEvt();\n\t},\n\t_update: function(pos, duration, easing, callback) {\n\t\tvar self = this;\n\t\tvar pos = undefined === pos ? (self.isY ? self.xscroll.getScrollTop() : self.xscroll.getScrollLeft()) : pos;\n\t\tvar barInfo = self.computeScrollBar(pos);\n\t\tvar size = self.isY ? \"height\" : \"width\";\n\t\tself.indicate.style[size] = Math.round(barInfo.size) + \"px\";\n\t\tif (duration && easing) {\n\t\t\tself.scrollTo(barInfo.pos, duration, easing, callback);\n\t\t} else {\n\t\t\tself.moveTo(barInfo.pos);\n\t\t}\n\t},\n\t//compute the position and size of the scrollbar\n\tcomputeScrollBar: function(pos) {\n\t\tvar self = this;\n\t\tvar type = self.isY ? \"y\" : \"x\";\n\t\tvar spacing = self.userConfig.spacing;\n\t\tvar xscroll = self.xscroll;\n\t\tvar boundry = xscroll.boundry;\n\t\tvar userConfig = self.userConfig;\n\t\tvar pos = self.isY ? Math.round(pos) + boundry._xtop : Math.round(pos) + boundry._xleft;\n\t\tvar MIN_BAR_SCROLLED_SIZE = userConfig.MIN_BAR_SCROLLED_SIZE;\n\t\tvar MIN_BAR_SIZE = userConfig.MIN_BAR_SIZE;\n\t\tvar MAX_BOUNCE_DISTANCE = userConfig.MAX_BOUNCE_DISTANCE;\n\t\tself.containerSize = self.isY ? xscroll.containerHeight + boundry._xtop + boundry._xbottom : self.xscroll.containerWidth + boundry._xright + boundry._xleft;\n\t\tself.size = self.isY ? boundry.cfg.height : boundry.cfg.width;\n\t\tself.indicateSize = self.isY ? boundry.cfg.height - spacing * 2 : boundry.cfg.width - spacing * 2;\n\t\tvar indicateSize = self.indicateSize;\n\t\tvar containerSize = self.containerSize;\n\t\tvar barPos = indicateSize * pos / containerSize;\n\t\tvar barSize = Math.round(indicateSize * self.size / containerSize);\n\t\tvar overTop = self.isY ? xscroll.getBoundryOutTop() : xscroll.getBoundryOutLeft();\n\t\tvar overBottom = self.isY ? xscroll.getBoundryOutBottom() : xscroll.getBoundryOutRight();\n\t\tvar barShiftSize = MIN_BAR_SIZE - barSize > 0 ? MIN_BAR_SIZE - barSize : 0;\n\t\tbarSize = barSize < MIN_BAR_SIZE ? MIN_BAR_SIZE : barSize;\n\t\tbarPos = (indicateSize - barShiftSize) * pos / containerSize;\n\t\tif (overTop >= 0) {\n\t\t\tvar pct = overTop / MAX_BOUNCE_DISTANCE;\n\t\t\tpct = pct > 1 ? 1 : pct;\n\t\t\tbarPos = - pct * (barSize -  MIN_BAR_SCROLLED_SIZE)\n\t\t}\n\t\tif (overBottom >= 0) {\n\t\t\tvar pct = overBottom / MAX_BOUNCE_DISTANCE;\n\t\t\tpct = pct > 1 ? 1 : pct;\n\t\t\tbarPos = pct * (barSize - MIN_BAR_SCROLLED_SIZE) + indicateSize - barSize; \n\t\t}\n\t\tself.barPos = Math.round(barPos);\n\t\treturn {\n\t\t\tsize: Math.round(barSize),\n\t\t\tpos: self.barPos\n\t\t};\n\t},\n\tscrollTo: function(pos, duration, easing, callback) {\n\t\tvar self = this;\n\t\tself.show();\n\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\tvar config = {\n\t\t\tcss: {\n\t\t\t\ttransform: self.isY ? \"translateY(\" + pos + \"px)\" + translateZ : \"translateX(\" + pos + \"px)\" + translateZ\n\t\t\t},\n\t\t\tduration: duration,\n\t\t\teasing: easing,\n\t\t\tuseTransition: self.xscroll.userConfig.useTransition,\n\t\t\tend: callback\n\t\t};\n\t\tself.__timer = self.__timer || new Animate(self.indicate, config);\n\t\t//run\n\t\tself.__timer.stop();\n\t\tself.__timer.reset(config);\n\t\tself.__timer.run();\n\t},\n\tmoveTo: function(pos) {\n\t\tvar self = this;\n\t\tself.show();\n\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\tself.isY ? self.indicate.style[transform] = \"translateY(\" + pos + \"px) \" + translateZ : self.indicate.style[transform] = \"translateX(\" + pos + \"px) \" + translateZ\n\t\tself.indicate.style[transition] = \"\";\n\t},\n\t_scrollHandler: function(e) {\n\t\tvar self = this;\n\t\tself._update(e[self.scrollTopOrLeft]);\n\t\treturn self;\n\t},\n\tisBoundryOut: function() {\n\t\tvar self = this;\n\t\treturn !self.isY ? (self.xscroll.isBoundryOutLeft() || self.xscroll.isBoundryOutRight()) : (self.xscroll.isBoundryOutTop() || self.xscroll.isBoundryOutBottom());\n\t},\n\t_scrollEndHandler: function(e) {\n\t\tvar self = this;\n\t\tif (!self.isBoundryOut()) {\n\t\t\tself._update(e[self.scrollTopOrLeft]);\n\t\t\tself.hide();\n\t\t}\n\t\treturn self;\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tif (self.__isEvtBind) return;\n\t\tself.__isEvtBind = true;\n\t\tself.xscroll.on(\"scroll\", self._scrollHandler, self);\n\t\tself.xscroll.on(\"scrollend\", self._scrollEndHandler, self);\n\t},\n\treset: function() {\n\t\tvar self = this;\n\t\tself.pos = 0;\n\t\tself._update();\n\t},\n\thide: function(duration, easing, delay) {\n\t\tvar self = this;\n\t\tvar duration = duration >= 0 ? duration : 300;\n\t\tvar easing = easing || \"ease-out\";\n\t\tvar delay = delay >= 0 ? delay : 100;\n\t\tself.scrollbar.style.opacity = 0;\n\t\tself.scrollbar.style[transition] = [\"opacity \", duration, \"ms \", \" ease-out \", delay, \"ms\"].join(\"\");\n\t},\n\tshow: function() {\n\t\tvar self = this;\n\t\tself.scrollbar.style.opacity = 1;\n\t\tself.scrollbar.style[transition] = \"\";\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = ScrollBar;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn ScrollBar;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/components/scrollbar.js\n// module id = 22\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Base = require('../base');\n//transform\nvar transform = Util.prefixStyle(\"transform\");\n// default render function for position:sticky elements\nvar defaultStickyRenderFunc = function(e) {\n  var stickyElement = e.stickyElement;\n  var curStickyElement = e.curStickyElement;\n  var xscroll = e.xscroll;\n  var _ = e._;\n  var infinite = xscroll.getPlugin(\"infinite\");\n  if (infinite) {\n    infinite.userConfig.renderHook.call(self, stickyElement, curStickyElement);\n    stickyElement.setAttribute(\"xs-guid\", curStickyElement.guid);\n    Util.addClass(stickyElement, curStickyElement.className);\n    for (var attrName in curStickyElement.style) {\n      if (attrName != \"display\" && attrName != \"position\") {\n        //copy styles\n        stickyElement.style[attrName] = attrName == _.height ? curStickyElement.style[attrName] + 'px' : curStickyElement.style[attrName];\n      }\n    }\n  } else {\n    var style = curStickyElement.getAttribute(\"style\");\n    stickyElement.innerHTML = curStickyElement.innerHTML;\n    stickyElement.className = curStickyElement.className;\n    style && stickyElement.setAttribute(\"style\", style);\n  }\n}\n\nvar Sticky = function(cfg) {\n  Sticky.superclass.constructor.call(this, cfg);\n  this.userConfig = Util.mix({\n    stickyRenderTo: undefined,\n    forceSticky: true,\n    prefix: \"xs-sticky-container\",\n    stickyRenderFunc: defaultStickyRenderFunc,\n    zoomType: \"y\"\n  }, cfg);\n  this.init();\n}\n\nUtil.extend(Sticky, Base, {\n  init: function() {\n    var self = this,\n      userConfig = self.userConfig,\n      xscroll = self.xscroll = userConfig.xscroll;\n    var isY = self.isY = !!(userConfig.zoomType == \"y\");\n    self._ = {\n      top: self.isY ? \"top\" : \"left\",\n      left: self.isY ? \"left\" : \"bottom\",\n      right: self.isY ? \"right\" : \"top\",\n      height: self.isY ? \"height\" : \"width\",\n      width: self.isY ? \"width\" : \"height\"\n    };\n    self.stickyRenderTo = Util.getNode(userConfig.stickyRenderTo);\n    self._handlers = [];\n    return self;\n  },\n  getStickiesPos: function() {\n    var self = this;\n    var xscroll = self.xscroll;\n    var isInfinite = self.isInfinite;\n    var isY = self.isY;\n    var _ = self._;\n    var stickiesPos = [];\n    var getPos = function(sticky) {\n      var pos = {};\n      if (isInfinite) {\n        pos[_.top] = isY ? sticky._top : sticky._left;\n        pos[_.height] = isY ? sticky._height : sticky._width;\n      } else {\n        pos[_.top] = self.isY ? Util.getOffsetTop(sticky) : Util.getOffsetLeft(sticky);\n        pos[_.height] = self.isY ? sticky.offsetHeight : sticky.offsetWidth;\n      }\n      return pos;\n    }\n    for (var i = 0; i < self.stickiesNum; i++) {\n      var pos = getPos(self.stickyElements[i]);\n      self._handlers[i] = self._handlers[i] || self.createStickyEl();\n      pos.el = self._handlers[i];\n      pos.isRender = false;\n      stickiesPos.push(pos);\n    }\n    return stickiesPos\n  },\n  getStickyElements: function() {\n    var self = this;\n    var xscroll = self.xscroll;\n    var userConfig = self.userConfig;\n    var isInfinite = self.isInfinite;\n    var infinite = xscroll.getPlugin(\"infinite\");\n    if (infinite) {\n      var stickyElements = [],\n        serializedData = infinite.__serializedData;\n      for (var i in serializedData) {\n        var rowData = serializedData[i];\n        if (rowData && rowData.style && \"sticky\" == rowData.style.position) {\n          stickyElements.push(rowData);\n        }\n      }\n      return stickyElements;\n    } else {\n      return Util.getNodes(xscroll.userConfig.stickyElements, xscroll.content);\n    }\n  },\n  render: function(force) {\n    var self = this;\n    var userConfig = self.userConfig;\n    var xscroll = self.xscroll;\n    self.isInfinite = !!xscroll.getPlugin(\"infinite\");\n    var _ = self._;\n    self.stickyElements = self.getStickyElements();\n    self.stickiesNum = self.stickyElements && self.stickyElements.length;\n    if (!self.stickiesNum) return;\n    if (!self.stickyRenderTo) {\n      self.stickyRenderTo = document.createElement('div');\n      xscroll.renderTo.appendChild(self.stickyRenderTo);\n    }\n    self.stickiesPos = self.getStickiesPos();\n    var stickyRenderTo = self.stickyRenderTo;\n    stickyRenderTo.style[_.top] = 0;\n    stickyRenderTo.style[_.left] = 0;\n    stickyRenderTo.style[_.right] = 0;\n    stickyRenderTo.style.position = xscroll.userConfig.useOriginScroll ? \"fixed\" : \"absolute\";\n    Util.addClass(self.stickyRenderTo, userConfig.prefix);\n    self.stickyHandler(force);\n    self._bindEvt();\n  },\n  createStickyEl: function() {\n    var self = this;\n    var el = document.createElement('div');\n    el.style.display = \"none\";\n    Util.addClass(el, \"xs-sticky-handler\");\n    self.stickyRenderTo.appendChild(el);\n    return el;\n  },\n  _bindEvt: function() {\n    var self = this,\n      xscroll = self.xscroll;\n    xscroll.on(\"scroll\", self.stickyHandler, self);\n  },\n  stickyHandler: function(force) {\n    var self = this;\n    var xscroll = self.xscroll;\n    var userConfig = self.userConfig;\n    var scrollTop = self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft();\n    var stickiesPos = self.stickiesPos;\n    var _ = self._;\n    var indexes = [];\n    for (var i = 0, l = stickiesPos.length; i < l; i++) {\n      var top = stickiesPos[i][_.top];\n      if (scrollTop > top) {\n        indexes.push(i);\n      }\n    }\n    if (!indexes.length) {\n      if (self.stickyElement) {\n        self.stickyElement.style.display = \"none\";\n      }\n      self.curStickyIndex = undefined;\n      return;\n    }\n\n    var curStickyIndex = Math.max.apply(null, indexes);\n    if (self.curStickyIndex != curStickyIndex || force) {\n      var prevStickyIndex = self.curStickyIndex;\n      self.curStickyIndex = curStickyIndex;\n      self.curStickyElement = self.stickyElements[curStickyIndex];\n      self.curStickyPos = stickiesPos[curStickyIndex];\n      self.stickyElement = self.curStickyPos.el;\n      for (var i = 0, l = stickiesPos.length; i < l; i++) {\n        stickiesPos[i].el.style.display = \"none\";\n      }\n      var eventsObj = {\n        stickyElement: self.stickyElement,\n        curStickyIndex: self.curStickyIndex,\n        prevStickyIndex: prevStickyIndex,\n        curStickyPos: self.curStickyPos,\n        isRender: self.curStickyPos.isRender\n      };\n      xscroll.trigger(\"beforestickychange\", eventsObj);\n      self._stickyRenderFunc(self);\n      xscroll.trigger(\"stickychange\", eventsObj);\n    }\n\n    var trans = 0;\n    if (self.stickiesPos[self.curStickyIndex + 1]) {\n      var cur = self.stickiesPos[self.curStickyIndex];\n      var next = self.stickiesPos[self.curStickyIndex + 1];\n      if (scrollTop + cur[_.height] > next[_.top] && scrollTop + cur[_.height] < next[_.top] + cur[_.height]) {\n        trans = cur[_.height] + scrollTop - next[_.top];\n      } else {\n        trans = 0;\n      }\n    }\n    self.stickyElement.style[transform] = self.isY ? \"translateY(-\" + (trans) + \"px) translateZ(0)\" : \"translateX(-\" + (trans) + \"px) translateZ(0)\";\n  },\n  _stickyRenderFunc: function(e) {\n    var self = this;\n    var _ = self._;\n    var stickyRenderFunc = self.userConfig.stickyRenderFunc;\n    var el = self.curStickyPos.el;\n    if (!self.curStickyPos.isRender) {\n      el.style[_.left] = 0;\n      el.style[_.right] = 0;\n      stickyRenderFunc && stickyRenderFunc.call(self, e);\n    }\n    el.style.display = \"block\";\n    self.curStickyPos.isRender = true;\n  },\n  destroy: function() {\n    var self = this;\n    self.stickyElements = undefined;\n    self.stickiesNum = undefined;\n    self.stickiesPos = undefined;\n    Util.remove(self.stickyElement);\n    self.stickyElement = undefined;\n  }\n});\n\nif (typeof module == 'object' && module.exports) {\n  module.exports = Sticky;\n}\n/** ignored by jsdoc **/\nelse {\n  return Sticky;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/components/sticky.js\n// module id = 23\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util');\n// Returns a function that will be executed at most one time, no matter how\n// often you call it. Useful for lazy initialization.\nvar _once = function(func) {\n  var ran = false,\n    memo;\n  return function() {\n    if (ran) return memo;\n    ran = true;\n    memo = func.apply(this, arguments);\n    func = null;\n    return memo;\n  };\n};\n\n\n/**\n * @discription events\n * @mixin\n */\nvar Events = {\n  // Bind an event to a `callback` function. Passing `\"all\"` will bind\n  // the callback to all events fired.\n  on: function(name, callback, context) {\n    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;\n    this._events || (this._events = {});\n    var events = this._events[name] || (this._events[name] = []);\n    events.push({\n      callback: callback,\n      context: context,\n      ctx: context || this\n    });\n    return this;\n  },\n\n\n  // Bind an event to only be triggered a single time. After the first time\n  // the callback is invoked, it will be removed.\n  once: function(name, callback, context) {\n    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;\n    var self = this;\n    var once = _once(function() {\n      self.off(name, once);\n      callback.apply(this, arguments);\n    });\n    once._callback = callback;\n    return this.on(name, once, context);\n  },\n\n  // Remove one or many callbacks. If `context` is null, removes all\n  // callbacks with that function. If `callback` is null, removes all\n  // callbacks for the event. If `name` is null, removes all bound\n  // callbacks for all events.\n  off: function(name, callback, context) {\n    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;\n\n    // Remove all callbacks for all events.\n    if (!name && !callback && !context) {\n      this._events = void 0;\n      return this;\n    }\n\n    var names = name ? [name] : Object.keys(this._events);\n    for (var i = 0, length = names.length; i < length; i++) {\n      name = names[i];\n\n      // Bail out if there are no events stored.\n      var events = this._events[name];\n      if (!events) continue;\n\n      // Remove all callbacks for this event.\n      if (!callback && !context) {\n        delete this._events[name];\n        continue;\n      }\n\n      // Find any remaining events.\n      var remaining = [];\n      for (var j = 0, k = events.length; j < k; j++) {\n        var event = events[j];\n        if (\n          callback && callback !== event.callback &&\n          callback !== event.callback._callback ||\n          context && context !== event.context\n        ) {\n          remaining.push(event);\n        }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length) {\n        this._events[name] = remaining;\n      } else {\n        delete this._events[name];\n      }\n    }\n\n    return this;\n  },\n\n  // Trigger one or many events, firing all bound callbacks. Callbacks are\n  // passed the same arguments as `trigger` is, apart from the event name\n  // (unless you're listening on `\"all\"`, which will cause your callback to\n  // receive the true name of the event as the first argument).\n  trigger: function(name) {\n    if (!this._events) return this;\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (!eventsApi(this, 'trigger', name, args)) return this;\n    var events = this._events[name];\n    var allEvents = this._events.all;\n    if (events) triggerEvents(events, args);\n    if (allEvents) triggerEvents(allEvents, arguments);\n    return this;\n  },\n\n  // Inversion-of-control versions of `on` and `once`. Tell *this* object to\n  // listen to an event in another object ... keeping track of what it's\n  // listening to.\n  listenTo: function(obj, name, callback) {\n    var listeningTo = this._listeningTo || (this._listeningTo = {});\n    var id = obj._listenId || (obj._listenId = Util.guid('l'));\n    listeningTo[id] = obj;\n    if (!callback && typeof name === 'object') callback = this;\n    obj.on(name, callback, this);\n    return this;\n  },\n\n  listenToOnce: function(obj, name, callback) {\n    if (typeof name === 'object') {\n      for (var event in name) this.listenToOnce(obj, event, name[event]);\n      return this;\n    }\n    var cb = _once(function() {\n      this.stopListening(obj, name, cb);\n      callback.apply(this, arguments);\n    });\n    cb._callback = callback;\n    return this.listenTo(obj, name, cb);\n  },\n\n  // Tell this object to stop listening to either specific events ... or\n  // to every object it's currently listening to.\n  stopListening: function(obj, name, callback) {\n    var listeningTo = this._listeningTo;\n    if (!listeningTo) return this;\n    var remove = !name && !callback;\n    if (!callback && typeof name === 'object') callback = this;\n    if (obj)(listeningTo = {})[obj._listenId] = obj;\n    for (var id in listeningTo) {\n      obj = listeningTo[id];\n      obj.off(name, callback, this);\n      if (remove || Util.isEmpty(obj._events)) delete this._listeningTo[id];\n    }\n    return this;\n  }\n\n};\n\n// Regular expression used to split event strings.\nvar eventSplitter = /\\s+/;\n\n// Implement fancy features of the Events API such as multiple event\n// names `\"change blur\"` and jQuery-style event maps `{change: action}`\n// in terms of the existing API.\nvar eventsApi = function(obj, action, name, rest) {\n  if (!name) return true;\n\n  // Handle event maps.\n  if (typeof name === 'object') {\n    for (var key in name) {\n      obj[action].apply(obj, [key, name[key]].concat(rest));\n    }\n    return false;\n  }\n\n  // Handle space separated event names.\n  if (eventSplitter.test(name)) {\n    var names = name.split(eventSplitter);\n    for (var i = 0, length = names.length; i < length; i++) {\n      obj[action].apply(obj, [names[i]].concat(rest));\n    }\n    return false;\n  }\n\n  return true;\n};\n\n// A difficult-to-believe, but optimized internal dispatch function for\n// triggering events. Tries to keep the usual cases speedy (most internal\nvar triggerEvents = function(events, args) {\n  var ev, i = -1,\n    l = events.length,\n    a1 = args[0],\n    a2 = args[1],\n    a3 = args[2];\n  switch (args.length) {\n    case 0:\n      while (++i < l)(ev = events[i]).callback.call(ev.ctx);\n      return;\n    case 1:\n      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1);\n      return;\n    case 2:\n      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2);\n      return;\n    case 3:\n      while (++i < l)(ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n      return;\n    default:\n      while (++i < l)(ev = events[i]).callback.apply(ev.ctx, args);\n      return;\n  }\n};\n\n// Aliases for backwards compatibility.\nEvents.bind = Events.on;\nEvents.unbind = Events.off;\n\nif (typeof module == 'object' && module.exports) {\n  module.exports = Events;\n}\n/** ignored by jsdoc **/\nelse {\n  return Events;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/events.js\n// module id = 24\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util'),\n    Base = require('./base'),\n    Core = require('./core'),\n    Animate = require('./animate');\n\nvar transformOrigin = Util.prefixStyle(\"transformOrigin\");\n/** \n * @constructor\n * @param {object} cfg config for scroll\n * @extends XScroll\n * @example\n * var xscroll = new OriginScroll({\n *    renderTo:\"#scroll\"\n * });\n * xscroll.render();\n */\nfunction OriginScroll(cfg) {\n    OriginScroll.superclass.constructor.call(this, cfg);\n}\n\nUtil.extend(OriginScroll, Core, {\n    init: function() {\n        var self = this;\n        OriginScroll.superclass.init.call(this);\n        self.resetSize();\n    },\n    /**\n     * get scroll top value\n     * @memberof OriginScroll\n     * @return {number} scrollTop\n     */\n    getScrollTop: function() {\n        return this.renderTo.scrollTop;\n    },\n    /**\n     * get scroll left value\n     * @memberof OriginScroll\n     * @return {number} scrollLeft\n     */\n    getScrollLeft: function() {\n        return this.renderTo.scrollLeft;\n    },\n    /**\n     * vertical scroll absolute to the destination\n     * @memberof SimuScroll\n     * @param scrollTop {number} scrollTop\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollTop: function(y, duration, easing, callback) {\n        var self = this;\n        var y = Math.round(y);\n        if (self.userConfig.lockY) return;\n        var duration = duration || 0;\n        var easing = easing || \"quadratic\";\n        var config = {\n            css: {\n                scrollTop: y\n            },\n            duration: duration,\n            easing: easing,\n            run: function(e) {\n                //trigger scroll event\n                self.trigger(\"scroll\", {\n                    scrollTop: self.getScrollTop(),\n                    scrollLeft: self.getScrollLeft()\n                });\n            },\n            useTransition: false, //scrollTop \n            end: callback\n        };\n        self.__timers.y = self.__timers.y || new Animate(self.renderTo, config);\n        //run\n        self.__timers.y.stop();\n        self.__timers.y.reset(config);\n        self.__timers.y.run();\n    },\n    /**\n     * horizontal scroll absolute to the destination\n     * @memberof SimuScroll\n     * @param scrollLeft {number} scrollLeft\n     * @param duration {number} duration for animte\n     * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n     **/\n    scrollLeft: function(x, duration, easing, callback) {\n        var self = this;\n        var x = Math.round(x);\n        if (self.userConfig.lockX) return;\n        var duration = duration || 0;\n        var easing = easing || \"quadratic\";\n        var config = {\n            css: {\n                scrollLeft: x\n            },\n            duration: duration,\n            easing: easing,\n            run: function(e) {\n                //trigger scroll event\n                self.trigger(\"scroll\", {\n                    scrollTop: self.getScrollTop(),\n                    scrollLeft: self.getScrollLeft()\n                });\n            },\n            useTransition: false, //scrollTop \n            end: callback\n        };\n        self.__timers.x = self.__timers.x || new Animate(self.renderTo, config);\n        //run\n        self.__timers.x.stop();\n        self.__timers.x.reset(config);\n        self.__timers.x.run();\n    },\n    _bindEvt: function() {\n        OriginScroll.superclass._bindEvt.call(this);\n        var self = this;\n        if (self.__isEvtBind) return;\n        self.__isEvtBind = true;\n        self.renderTo.addEventListener(\"scroll\", function(e) {\n            self.trigger(\"scroll\", {\n                type: \"scroll\",\n                scrollTop: self.getScrollTop(),\n                scrollLeft: self.getScrollLeft()\n            })\n        }, false)\n    }\n});\n\nif (typeof module == 'object' && module.exports) {\n    module.exports = OriginScroll;\n}\n/** ignored by jsdoc **/\nelse {\n    return OriginScroll;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/origin-scroll.js\n// module id = 25\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util'),\n\tBase = require('../base');\n\nvar transform = Util.prefixStyle(\"transform\");\nvar transition = Util.prefixStyle(\"transition\");\n\n/**\n * An infinity dom-recycled list plugin for xscroll.\n * @constructor\n * @param {object} cfg\n * @param {string} cfg.transition recomposition cell with a transition\n * @param {string} cfg.infiniteElements dom-selector for reused elements\n * @param {function} cfg.renderHook render function for cell by per col or per row duration scrolling\n * @extends {Base}\n */\nvar Infinite = function(cfg) {\n\tInfinite.superclass.constructor.call(this, cfg);\n\tthis.userConfig = Util.mix({\n\t\ttransition: 'all 0.5s ease'\n\t}, cfg);\n}\n\nUtil.extend(Infinite, Base, {\n\t/**\n\t * a pluginId\n\t * @memberOf Infinite\n\t * @type {string}\n\t */\n\tpluginId: \"infinite\",\n\t/**\n\t * store the visible elements inside of view.\n\t * @memberOf Infinite\n\t * @type {object}\n\t */\n\tvisibleElements: {},\n\t/**\n\t * store all elements data.\n\t * @memberOf Infinite\n\t * @type {object}\n\t */\n\tsections: {},\n\t/**\n\t * plugin initializer\n\t * @memberOf Infinite\n\t * @override Base\n\t * @return {Infinite}\n\t */\n\tpluginInitializer: function(xscroll) {\n\t\tvar self = this;\n\t\tself.xscroll = xscroll;\n\t\tself.isY = !!(xscroll.userConfig.zoomType == \"y\");\n\t\tself._ = {\n\t\t\t_top:self.isY ? \"_top\" : \"_left\",\n\t\t\t_height:self.isY ? \"_height\" : \"_width\",\n\t\t\ttop:self.isY ? \"top\" : \"left\",\n\t\t\theight:self.isY ? \"height\" : \"width\",\n\t\t\twidth:self.isY ? \"width\" : \"height\",\n\t\t\ty:self.isY ? \"y\" : \"x\",\n\t\t\ttranslate:self.isY ? \"translateY\" : \"translateX\",\n\t\t\tcontainerHeight:self.isY ? \"containerHeight\" : \"containerWidth\",\n\t\t\tscrollTop:self.isY ? \"scrollTop\" : \"scrollLeft\",\n\t\t}\n\t\tself._initInfinite();\n\t\txscroll.on(\"afterrender\", function() {\n\t\t\tself.render();\n\t\t\tself._bindEvt();\n\t\t});\n\t\treturn self;\n\t},\n\t/**\n\t * detroy the plugin\n\t * @memberOf Infinite\n\t * @override Base\n\t * @return {Infinite}\n\t */\n\tpluginDestructor: function() {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\tself.infiniteElements[i].style[_.top] = \"auto\";\n\t\t\tself.infiniteElements[i].style[transform] = \"none\";\n\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t}\n\t\tself.xscroll && self.xscroll.off(\"scroll\", self._updateByScroll, self);\n\t\tself.xscroll && self.xscroll.off(\"tap panstart pan panend\", self._cellEventsHandler, self);\n\t\treturn self;\n\t},\n\t_initInfinite: function() {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar _ = self._;\n\t\tself.sections = {};\n\t\tself.infiniteElements = xscroll.renderTo.querySelectorAll(self.userConfig.infiniteElements);\n\t\tself.infiniteLength = self.infiniteElements.length;\n\t\tself.infiniteElementsCache = (function() {\n\t\t\tvar tmp = []\n\t\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\t\ttmp.push({});\n\t\t\t\tself.infiniteElements[i].style.position = \"absolute\";\n\t\t\t\tself.infiniteElements[i].style[_.top] = 0;\n\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t\tself.infiniteElements[i].style.display = \"block\";\n\t\t\t\tUtil.addClass(self.infiniteElements[i], \"_xs_infinite_elements_\");\n\t\t\t}\n\t\t\treturn tmp;\n\t\t})();\n\t\tself.elementsPos = {};\n\t\treturn self;\n\t},\n\t_renderUnRecycledEl: function() {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tvar translateZ = self.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\tfor (var i in self.__serializedData) {\n\t\t\tvar unrecycledEl = self.__serializedData[i];\n\t\t\tif (self.__serializedData[i]['recycled'] === false) {\n\t\t\t\tvar el = unrecycledEl.id && document.getElementById(unrecycledEl.id.replace(\"#\", \"\")) || document.createElement(\"div\");\n\t\t\t\tvar randomId = Util.guid(\"xs-row-\");\n\t\t\t\tel.id = unrecycledEl.id || randomId;\n\t\t\t\tunrecycledEl.id = el.id;\n\t\t\t\tself.xscroll.content.appendChild(el);\n\t\t\t\tfor (var attrName in unrecycledEl.style) {\n\t\t\t\t\tif (attrName != _.height && attrName != \"display\" && attrName != \"position\") {\n\t\t\t\t\t\tel.style[attrName] = unrecycledEl.style[attrName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tel.style[_.top] = 0;\n\t\t\t\tel.style.position = \"absolute\";\n\t\t\t\tel.style.display = \"block\";\n\t\t\t\tel.style[_.height] = unrecycledEl[_._height] + \"px\";\n\t\t\t\tel.style[transform] = _.translate + \"(\" + unrecycledEl[_._top] + \"px) \" + translateZ;\n\t\t\t\tUtil.addClass(el, unrecycledEl.className);\n\t\t\t\tself.userConfig.renderHook.call(self, el, unrecycledEl);\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * render or update the scroll contents\n\t * @memberOf Infinite\n\t * @return {Infinite}\n\t */\n\trender: function() {\n\t\tvar self = this;\n\t\tvar _  = self._;\n\t\tvar xscroll = self.xscroll;\n\t\tvar offset = self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft();\n\t\tself.visibleElements = self.getVisibleElements(offset);\n\t\tself.__serializedData = self._computeDomPositions();\n\t\txscroll.sticky && xscroll.sticky.render(true); //force render\n\t\txscroll.fixed && xscroll.fixed.render();\n\t\tvar size = xscroll[_.height];\n\t\tvar containerSize = self._containerSize;\n\t\tif (containerSize < size) {\n\t\t\tcontainerSize = size;\n\t\t}\n\t\txscroll[_.containerHeight] = containerSize;\n\t\txscroll.container.style[_.height] = containerSize + \"px\";\n\t\txscroll.content.style[_.height] = containerSize + \"px\";\n\t\tself._renderUnRecycledEl();\n\t\tself._updateByScroll();\n\t\tself._updateByRender(offset);\n\t\tself.xscroll.boundryCheck();\n\t\treturn self;\n\t},\n\t_getChangedRows: function(newElementsPos) {\n\t\tvar self = this;\n\t\tvar changedRows = {};\n\t\tfor (var i in self.elementsPos) {\n\t\t\tif (!newElementsPos.hasOwnProperty(i)) {\n\t\t\t\tchangedRows[i] = \"delete\";\n\t\t\t}\n\t\t}\n\t\tfor (var i in newElementsPos) {\n\t\t\tif (newElementsPos[i].recycled && !self.elementsPos.hasOwnProperty(i)) {\n\t\t\t\tchangedRows[i] = \"add\";\n\t\t\t}\n\t\t}\n\t\tself.elementsPos = newElementsPos;\n\t\treturn changedRows;\n\t},\n\t_updateByScroll: function(e) {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar _ = self._;\n\t\tvar _pos = e && e[_.scrollTop];\n\t\tvar pos = _pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : _pos;\n\t\tvar elementsPos = self.getVisibleElements(pos);\n\t\tvar changedRows = self.changedRows = self._getChangedRows(elementsPos);\n\t\ttry{\n\t\t\tfor (var i in changedRows) {\n\t\t\t\tif (changedRows[i] == \"delete\") {\n\t\t\t\t\tself._pushEl(i);\n\t\t\t\t}\n\t\t\t\tif (changedRows[i] == \"add\") {\n\t\t\t\t\tvar elObj = self._popEl(elementsPos[i][self.guid]);\n\t\t\t\t\tvar index = elObj.index;\n\t\t\t\t\tvar el = elObj.el;\n\t\t\t\t\tif (el) {\n\t\t\t\t\t\tself.infiniteElementsCache[index].guid = elementsPos[i].guid;\n\t\t\t\t\t\tself.__serializedData[elementsPos[i].guid].__infiniteIndex = index;\n\t\t\t\t\t\tself._renderData(el, elementsPos[i]);\n\t\t\t\t\t\tself._renderStyle(el, elementsPos[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(e){\n\t\t\tconsole.warn('Not enough infiniteElements setted!');\n\t\t}\n\t\treturn self;\n\t},\n\t_updateByRender: function(pos) {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tvar xscroll = self.xscroll;\n\t\tvar pos = pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : pos;\n\t\tvar prevElementsPos = self.visibleElements;\n\t\tvar newElementsPos = self.getVisibleElements(pos);\n\t\tvar prevEl, newEl;\n\t\t//repaint\n\t\tfor (var i in newElementsPos) {\n\t\t\tnewEl = newElementsPos[i];\n\t\t\tfor (var j in prevElementsPos) {\n\t\t\t\tprevEl = prevElementsPos[j];\n\t\t\t\tif (prevEl.guid === newEl.guid) {\n\t\t\t\t\tif (newEl.style != prevEl.style || newEl[_._top] != prevEl[_._top] || newEl[_._height] != prevEl[_._height]) {\n\t\t\t\t\t\tself._renderStyle(self.infiniteElements[newEl.__infiniteIndex], newEl, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (JSON.stringify(newEl.data) != JSON.stringify(prevEl.data)) {\n\t\t\t\t\t\tself._renderData(self.infiniteElements[newEl.__infiniteIndex], newEl);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// paint\n\t\t\t\t\tif (self.__serializedData[newEl.guid].recycled && self.__serializedData[newEl.guid].__infiniteIndex === undefined) {\n\t\t\t\t\t\tvar elObj = self._popEl();\n\t\t\t\t\t\tself.__serializedData[newEl.guid].__infiniteIndex = elObj.index;\n\t\t\t\t\t\tself._renderData(elObj.el, newEl);\n\t\t\t\t\t\tself._renderStyle(elObj.el, newEl);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tself.visibleElements = newElementsPos;\n\t},\n\t/**\n\t * get all element posInfo such as top,height,template,html\n\t * @return {Array}\n\t **/\n\t_computeDomPositions: function() {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tvar pos = 0,\n\t\t\tsize = 0,\n\t\t\tsections = self.sections,\n\t\t\tsection;\n\t\tvar data = [];\n\t\tvar serializedData = {};\n\t\tfor (var i in sections) {\n\t\t\tfor (var j = 0, len = sections[i].length; j < len; j++) {\n\t\t\t\tsection = sections[i][j];\n\t\t\t\tsection.sectionId = i;\n\t\t\t\tsection.index = j;\n\t\t\t\tdata.push(section);\n\t\t\t}\n\t\t}\n\n\t\t//f = v/itemSize*1000 < 60 => v = 0.06 * itemSize\n\t\tself.userConfig.maxSpeed = 0.06 * 50;\n\t\tfor (var i = 0, l = data.length; i < l; i++) {\n\t\t\tvar item = data[i];\n\t\t\tsize = item.style && item.style[_.height] >= 0 && item.style.position != \"fixed\" ? item.style[_.height] : 0;\n\t\t\titem.guid = item.guid || Util.guid();\n\t\t\titem[_._top] = pos;\n\t\t\titem[_._height] = size;\n\t\t\titem.recycled = item.recycled === false ? false : true;\n\t\t\tpos += size;\n\t\t\tserializedData[item.guid] = item;\n\t\t}\n\t\tself._containerSize = pos;\n\t\treturn serializedData;\n\t},\n\t/**\n\t * get all elements inside of the view.\n\t * @memberOf Infinite\n\t * @param {number} pos scrollLeft or scrollTop\n\t * @return {object} visibleElements\n\t */\n\tgetVisibleElements: function(pos) {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar _ = self._;\n\t\tvar pos = pos === undefined ? (self.isY ? xscroll.getScrollTop() : xscroll.getScrollLeft()) : pos;\n\t\tvar threshold = self.userConfig.threshold >= 0 ? self.userConfig.threshold : xscroll[_.height] / 3;\n\t\tvar tmp = {},\n\t\t\titem;\n\t\tvar data = self.__serializedData;\n\t\tfor (var i in data) {\n\t\t\titem = data[i];\n\t\t\tif (item[_._top] >= pos - threshold && item[_._top] <= pos + xscroll[_.height] + threshold) {\n\t\t\t\ttmp[item.guid] = item;\n\t\t\t}\n\t\t}\n\t\treturn JSON.parse(JSON.stringify(tmp));\n\t},\n\t_popEl: function() {\n\t\tvar self = this;\n\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\tif (!self.infiniteElementsCache[i]._visible) {\n\t\t\t\tself.infiniteElementsCache[i]._visible = true;\n\t\t\t\treturn {\n\t\t\t\t\tindex: i,\n\t\t\t\t\tel: self.infiniteElements[i]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t_pushEl: function(guid) {\n\t\tvar self = this;\n\t\tfor (var i = 0; i < self.infiniteLength; i++) {\n\t\t\tif (self.infiniteElementsCache[i].guid == guid) {\n\t\t\t\tself.infiniteElementsCache[i]._visible = false;\n\t\t\t\tself.infiniteElements[i].style.visibility = \"hidden\";\n\t\t\t\tself.infiniteElementsCache[i].guid = null;\n\t\t\t}\n\t\t}\n\t},\n\t_renderData: function(el, elementObj) {\n\t\tvar self = this;\n\t\tif (!el || !elementObj || elementObj.style.position == \"fixed\") return;\n\t\tself.userConfig.renderHook.call(self, el, elementObj);\n\t},\n\t_renderStyle: function(el, elementObj, useTransition) {\n\t\tvar self = this;\n\t\tvar _ = self._;\n\t\tif (!el) return;\n\t\tvar translateZ = self.xscroll.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n\t\t//update style\n\t\tfor (var attrName in elementObj.style) {\n\t\t\tif (attrName != _.height && attrName != \"display\" && attrName != \"position\") {\n\t\t\t\tel.style[attrName] = elementObj.style[attrName];\n\t\t\t}\n\t\t}\n\t\tel.setAttribute(\"xs-index\", elementObj.index);\n\t\tel.setAttribute(\"xs-sectionid\", elementObj.sectionId);\n\t\tel.setAttribute(\"xs-guid\", elementObj.guid);\n\t\tel.style.visibility = \"visible\";\n\t\tel.style[_.height] = elementObj[_._height] + \"px\";\n\t\tel.style[transform] = _.translate + \"(\" + elementObj[_._top] + \"px) \" + translateZ;\n\t\tel.style[transition] = useTransition ? self.userConfig.transition : \"none\";\n\t},\n\tgetCell: function(e) {\n\t\tvar self = this,\n\t\t\tcell;\n\t\tvar el = Util.findParentEl(e.target, \"._xs_infinite_elements_\", self.xscroll.renderTo);\n\t\tif(!el){\n\t\t\tel = Util.findParentEl(e.target, \".xs-sticky-handler\", self.xscroll.renderTo);\n\t\t}\n\t\tvar guid = el && el.getAttribute(\"xs-guid\");\n\t\tif (undefined === guid) return;\n\t\treturn {\n\t\t\tdata:self.__serializedData[guid],\n\t\t\tel:el\n\t\t};\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tif (self._isEvtBinded) return;\n\t\tself._isEvtBinded = true;\n\t\tself.xscroll.renderTo.addEventListener(\"webkitTransitionEnd\", function(e) {\n\t\t\tif (e.target.className.match(/xs-row/)) {\n\t\t\t\te.target.style.webkitTransition = \"\";\n\t\t\t}\n\t\t});\n\t\tself.xscroll.on(\"scroll\", self._updateByScroll, self);\n\t\tself.xscroll.on(\"tap panstart pan panend\", self._cellEventsHandler, self);\n\t\treturn self;\n\t},\n\t_cellEventsHandler: function(e) {\n\t\tvar self = this;\n\t\tvar cell = self.getCell(e);\n\t\te.cell = cell.data;\n\t\te.cellEl = cell.el;\n\t\te.cell && self[e.type].call(self, e);\n\t},\n\t/**\n\t * tap event\n\t * @memberOf Infinite\n\t * @param {object} e events data include cell object\n\t * @event\n\t */\n\ttap: function(e) {\n\t\tthis.trigger(\"tap\", e);\n\t\treturn this;\n\t},\n\t/**\n\t * panstart event\n\t * @memberOf Infinite\n\t * @param {object} e events data include cell object\n\t * @event\n\t */\n\tpanstart: function(e) {\n\t\tthis.trigger(\"panstart\", e);\n\t\treturn this;\n\t},\n\t/**\n\t * pan event\n\t * @memberOf Infinite\n\t * @param {object} e events data include cell object\n\t * @event\n\t */\n\tpan: function(e) {\n\t\tthis.trigger(\"pan\", e);\n\t\treturn this;\n\t},\n\t/**\n\t * panend event\n\t * @memberOf Infinite\n\t * @param {object} e events data include cell object\n\t * @event\n\t */\n\tpanend: function(e) {\n\t\tthis.trigger(\"panend\", e);\n\t\treturn this;\n\t},\n\t/**\n\t * insert data before a position\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId of the target cell\n\t * @param {number} index index of the target cell\n\t * @param {object} data data to insert\n\t * @return {Infinite}\n\t */\n\tinsertBefore: function(sectionId, index, data) {\n\t\tvar self = this;\n\t\tif (sectionId === undefined || index === undefined || data === undefined) return self;\n\t\tif (!self.sections[sectionId]) {\n\t\t\tself.sections[sectionId] = [];\n\t\t}\n\t\tself.sections[sectionId].splice(index, 0, data);\n\t\treturn self;\n\t},\n\t/**\n\t * insert data after a position\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId of the target cell\n\t * @param {number} index index of the target cell\n\t * @param {object} data data to insert\n\t * @return {Infinite}\n\t */\n\tinsertAfter: function(sectionId, index, data) {\n\t\tvar self = this;\n\t\tif (sectionId === undefined || index === undefined || data === undefined) return self;\n\t\tif (!self.sections[sectionId]) {\n\t\t\tself.sections[sectionId] = [];\n\t\t}\n\t\tself.sections[sectionId].splice(Number(index) + 1, 0, data);\n\t\treturn self;\n\t},\n\t/**\n\t * append data after a section\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId for the append cell\n\t * @param {object} data data to append\n\t * @return {Infinite}\n\t */\n\tappend: function(sectionId, data) {\n\t\tvar self = this;\n\t\tif (!self.sections[sectionId]) {\n\t\t\tself.sections[sectionId] = [];\n\t\t}\n\t\tself.sections[sectionId] = self.sections[sectionId].concat(data);\n\t\treturn self;\n\t},\n\t/**\n\t * remove some data by sectionId,from,number\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId for the append cell\n\t * @param {number} from removed index from\n\t * @param {number} number removed data number\n\t * @return {Infinite}\n\t */\n\tremove: function(sectionId, from, number) {\n\t\tvar self = this;\n\t\tvar number = number || 1;\n\t\tif (undefined === sectionId || !self.sections[sectionId]) return self;\n\t\t//remove a section\n\t\tif (undefined === from) {\n\t\t\tself.sections[sectionId] = null;\n\t\t\treturn self;\n\t\t}\n\t\t//remove some data in section\n\t\tif (self.sections[sectionId] && self.sections[sectionId][from]) {\n\t\t\tself.sections[sectionId].splice(from, number);\n\t\t\treturn self;\n\t\t}\n\t\treturn self;\n\t},\n\t/**\n\t * replace some data by sectionId and index\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId to replace\n\t * @param {number} index removed index from\n\t * @param {object} data new data to replace\n\t * @return {Infinite}\n\t */\n\treplace: function(sectionId, index, data) {\n\t\tvar self = this;\n\t\tif (undefined === sectionId || !self.sections[sectionId]) return self;\n\t\tself.sections[sectionId][index] = data;\n\t\treturn self;\n\t},\n\t/**\n\t * get data by sectionId and index\n\t * @memberOf Infinite\n\t * @param {string} sectionId sectionId\n\t * @param {number} index index in the section\n\t * @return {object} data data\n\t */\n\tget: function(sectionId, index) {\n\t\tif (undefined === sectionId) return;\n\t\tif (undefined === index) return this.sections[sectionId];\n\t\treturn this.sections[sectionId][index];\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = Infinite;\n}\n/** ignored by jsdoc **/\nelse if (window.XScroll && window.XScroll.Plugins) {\n\treturn XScroll.Plugins.Infinite = Infinite;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/plugins/infinite.js\n// module id = 26\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Base = require('../base');\nvar clsPrefix;\nvar containerCls;\nvar content = \"Pull Down To Refresh\";\nvar loadingContent = \"Loading...\";\n/**\n * A pulldown to refresh plugin for xscroll.\n * @constructor\n * @param {object} cfg\n * @param {number} cfg.height\n * @param {string} cfg.content default html for pulldown\n * @param {string} cfg.downContent html for pulldown when scrollTop is smaller than cfg.height\n * @param {string} cfg.upContent html for pulldown when scrollTop is larger than cfg.height\n * @param {string} cfg.loadingContent html for pulldown when released\n * @param {string} cfg.clsPrefix  class prefix which default value is \"xs-plugin-pulldown-\"\n * @extends {Base}\n */\nvar PullDown = function(cfg) {\n\tPullDown.superclass.constructor.call(this, cfg);\n\tthis.userConfig = Util.mix({\n\t\tcontent: content,\n\t\theight: 60,\n\t\tautoRefresh: true,\n\t\tdownContent: \"Pull Down To Refresh\",\n\t\tupContent: \"Release To Refresh\",\n\t\tloadingContent: loadingContent,\n\t\tclsPrefix: \"xs-plugin-pulldown-\"\n\t}, cfg);\n}\nUtil.extend(PullDown, Base, {\n\t/**\n\t * a pluginId\n\t * @memberOf PullDown\n\t * @type {string}\n\t */\n\tpluginId: \"pulldown\",\n\t/**\n\t * plugin initializer\n\t * @memberOf PullDown\n\t * @override Base\n\t * @return {PullDown}\n\t */\n\tpluginInitializer: function(xscroll) {\n\t\tvar self = this;\n\t\tself.xscroll = xscroll.render();\n\t\tclsPrefix = self.userConfig.clsPrefix;\n\t\tself.render();\n\t\treturn self;\n\t},\n\t/**\n\t * detroy the plugin\n\t * @memberOf PullDown\n\t * @override Base\n\t * @return {PullDown}\n\t */\n\tpluginDestructor: function() {\n\t\tvar self = this;\n\t\tUtil.remove(self.pulldown);\n\t\tself.xscroll.off(\"panstart\", self._panStartHandler, self);\n\t\tself.xscroll.off(\"pan\", self._panHandler, self);\n\t\tself.xscroll.off(\"panend\", self._panEndHandler, self);\n\t\tself.__isRender = false;\n\t\tself._evtBinded = false;\n\t},\n\t/**\n\t * render pulldown plugin\n\t * @memberOf PullDown\n\t * @return {PullDown}\n\t */\n\trender: function() {\n\t\tvar self = this;\n\t\tif (self.__isRender) return;\n\t\tself.__isRender = true;\n\t\tvar containerCls = clsPrefix + \"container\";\n\t\tvar height = self.userConfig.height || 60;\n\t\tvar pulldown = self.pulldown = document.createElement(\"div\");\n\t\tpulldown.className = containerCls;\n\t\tpulldown.style.position = \"absolute\";\n\t\tpulldown.style.width = \"100%\";\n\t\tpulldown.style.height = height + \"px\";\n\t\tpulldown.style.lineHeight = height + \"px\";\n\t\tpulldown.style.top = -height + \"px\";\n\t\tpulldown.style.textAlign = \"center\";\n\t\tself.xscroll.container.appendChild(pulldown);\n\t\tself.status = 'up';\n\t\tUtil.addClass(pulldown, clsPrefix + self.status);\n\t\tpulldown.innerHTML = self.userConfig[self.status + \"Content\"] || self.userConfig.content;\n\t\tself._bindEvt();\n\t\treturn self;\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tif (self._evtBinded) return;\n\t\tself._evtBinded = true;\n\t\tvar pulldown = self.pulldown;\n\t\tvar xscroll = self.xscroll;\n\t\txscroll.on(\"pan\", self._panHandler, self);\n\t\txscroll.on(\"panstart\", self._panStartHandler, self);\n\t\txscroll.on(\"panend\", self._panEndHandler, self);\n\t},\n\t_changeStatus: function(status) {\n\t\tvar prevVal = this.status;\n\t\tthis.status = status;\n\t\tUtil.removeClass(this.pulldown, clsPrefix + prevVal)\n\t\tUtil.addClass(this.pulldown, clsPrefix + status);\n\t\tif (this.userConfig[status + \"Content\"]) {\n\t\t\tthis.pulldown.innerHTML = this.userConfig[status + \"Content\"];\n\t\t}\n\t\tif (prevVal != status) {\n\t\t\tthis.trigger(\"statuschange\", {\n\t\t\t\tprevVal: prevVal,\n\t\t\t\tnewVal: status\n\t\t\t});\n\t\t\tif (status == \"loading\") {\n\t\t\t\tthis.trigger(\"loading\");\n\t\t\t}\n\t\t}\n\t},\n\t/**\n\t * reset the pulldown plugin\n\t * @memberOf PullDown\n\t * @param {function} callback\n\t * @return {PullDown}\n\t */\n\treset: function(callback) {\n\t\tthis.xscroll.boundry.resetTop()\n\t\tthis.xscroll.boundryCheckY(callback);\n\t\tthis._expanded = false;\n\t\treturn this;\n\t},\n\t_panStartHandler: function(e) {\n\t\tclearTimeout(this.loadingItv);\n\t},\n\t_panHandler: function(e) {\n\t\tvar self = this;\n\t\tvar scrollTop = self.xscroll.getScrollTop();\n\t\tif (scrollTop > 0) return;\n\t\tself._changeStatus(Math.abs(scrollTop) < self.userConfig.height ? \"down\" : \"up\");\n\t},\n\t_panEndHandler: function(e) {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar height = self.userConfig.height || 60;\n\t\tvar scrollTop = xscroll.getScrollTop();\n\t\tif (scrollTop < -height) {\n\t\t\t//prevent default bounce\n\t\t\te.preventDefault();\n\t\t\txscroll.boundry.resetTop();\n\t\t\txscroll.boundry.expandTop(height);\n\t\t\txscroll.boundryCheckY(function() {\n\t\t\t\tself._changeStatus(\"loading\");\n\t\t\t});\n\t\t\tif (self.userConfig.autoRefresh) {\n\t\t\t\tclearTimeout(self.loadingItv);\n\t\t\t\tself.loadingItv = setTimeout(function() {\n\t\t\t\t\txscroll.boundry.resetTop();\n\t\t\t\t\txscroll.boundryCheckY(function() {\n\t\t\t\t\t\twindow.location.reload();\n\t\t\t\t\t})\n\t\t\t\t}, 800);\n\t\t\t}\n\t\t}\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = PullDown;\n}\n/** ignored by jsdoc **/\nelse if (window.XScroll && window.XScroll.Plugins) {\n\treturn XScroll.Plugins.PullDown = PullDown;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/plugins/pulldown.js\n// module id = 27\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('../util');\nvar Base = require('../base');\nvar clsPrefix;\nvar containerCls;\nvar loadingContent = \"Loading...\";\nvar upContent = \"Pull Up To Refresh\";\nvar downContent = \"Release To Refresh\";\nvar PULL_UP_HEIGHT = 60;\nvar HEIGHT = 40;\n/**\n * A pullup to load plugin for xscroll.\n * @constructor\n * @param {object} cfg\n * @param {number} cfg.height\n * @param {string} cfg.downContent\n * @param {string} cfg.upContent\n * @param {string} cfg.loadingContent\n * @param {string} cfg.clsPrefix  class prefix which default value is \"xs-plugin-pullup-\"\n * @param {number} cfg.bufferHeight preload data before scrolling to the bottom of the boundry\n * @extends {Base}\n */\nvar PullUp = function(cfg) {\n\tPullUp.superclass.constructor.call(this);\n\tthis.userConfig = Util.mix({\n\t\tupContent: upContent,\n\t\tdownContent: downContent,\n\t\tpullUpHeight: PULL_UP_HEIGHT,\n\t\theight: HEIGHT,\n\t\tloadingContent: loadingContent,\n\t\tbufferHeight: 0,\n\t\tclsPrefix: \"xs-plugin-pullup-\"\n\t}, cfg);\n}\nUtil.extend(PullUp, Base, {\n\t/**\n\t * a pluginId\n\t * @memberOf PullUp\n\t * @type {string}\n\t */\n\tpluginId: \"pullup\",\n\t/**\n\t * plugin initializer\n\t * @memberOf PullUp\n\t * @override Base\n\t * @return {PullUp}\n\t */\n\tpluginInitializer: function(xscroll) {\n\t\tvar self = this;\n\t\tself.xscroll = xscroll.render();\n\t\tclsPrefix = self.userConfig.clsPrefix;\n\t\tself.render();\n\t\treturn self;\n\t},\n\t/**\n\t * detroy the plugin\n\t * @memberOf PullUp\n\t * @override Base\n\t * @return {PullUp}\n\t */\n\tpluginDestructor: function() {\n\t\tvar self = this;\n\t\tUtil.remove(self.pullup);\t\t\n\t\tself.xscroll.off(\"scrollend\", self._scrollEndHandler, self);\n\t\tself.xscroll.off(\"scroll\", self._scrollHandler, self);\n\t\tself.xscroll.off(\"pan\", self._panHandler, self);\n\t\tself.xscroll.boundry.resetBottom();\n\t\tself.__isRender = false;\n\t\tself._evtBinded = false;\n\t},\n\t/**\n\t * render pullup plugin\n\t * @memberOf PullUp\n\t * @return {PullUp}\n\t */\n\trender: function() {\n\t\tvar self = this;\n\t\tif (self.__isRender) return;\n\t\tself.__isRender = true;\n\t\tvar containerCls = clsPrefix + \"container\";\n\t\tvar height = self.userConfig.height;\n\t\tvar pullup = self.pullup = document.createElement(\"div\");\n\t\tpullup.className = containerCls;\n\t\tpullup.style.position = \"absolute\";\n\t\tpullup.style.width = \"100%\";\n\t\tpullup.style.height = height + \"px\";\n\t\tpullup.style.bottom = -height + \"px\";\n\t\tself.xscroll.container.appendChild(pullup);\n\t\tself.xscroll.boundry.expandBottom(self.userConfig.height);\n\t\tself.status = 'up';\n\t\tUtil.addClass(pullup, clsPrefix + self.status);\n\t\tpullup.innerHTML = self.userConfig[self.status + \"Content\"] || self.userConfig.content;\n\t\tself._bindEvt();\n\t\treturn self;\n\t},\n\t_bindEvt: function() {\n\t\tvar self = this;\n\t\tif (self._evtBinded) return;\n\t\tself._evtBinded = true;\n\t\tvar pullup = self.pullup;\n\t\tvar xscroll = self.xscroll;\n\t\txscroll.on(\"pan\", self._panHandler, self);\n\t\t//load width a buffer\n\t\tif (self.userConfig.bufferHeight > 0) {\n\t\t\txscroll.on(\"scroll\", self._scrollHandler, self);\n\t\t}\n\t\t//bounce bottom\n\t\txscroll.on(\"scrollend\", self._scrollEndHandler, self);\n\t\treturn self;\n\t},\n\t_scrollEndHandler: function(e) {\n\t\tvar self = this,\n\t\t\txscroll = self.xscroll,\n\t\t\tscrollTop = xscroll.getScrollTop();\n\t\tif (scrollTop == xscroll.containerHeight - xscroll.height + self.userConfig.height) {\n\t\t\tself._changeStatus(\"loading\");\n\t\t}\n\t\treturn self;\n\t},\n\t_scrollHandler: function(e) {\n\t\tvar self = this,\n\t\t\txscroll = self.xscroll;\n\t\tif (!self.isLoading && Math.abs(e.scrollTop) + xscroll.height + self.userConfig.height + self.userConfig.bufferHeight >= xscroll.containerHeight + xscroll.boundry._xtop + xscroll.boundry._xbottom) {\n\t\t\tself._changeStatus(\"loading\");\n\t\t}\n\t\treturn self;\n\t},\n\t_panHandler: function(e) {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tvar offsetTop = -xscroll.getScrollTop();\n\t\tif (offsetTop < xscroll.height - xscroll.containerHeight - self.userConfig.pullUpHeight) {\n\t\t\tself._changeStatus(\"down\")\n\t\t} else {\n\t\t\tself._changeStatus(\"up\");\n\t\t}\n\t\treturn self;\n\t},\n\t_changeStatus: function(status) {\n\t\tif (status != \"loading\" && this.isLoading) return;\n\t\tvar prevVal = this.status;\n\t\tthis.status = status;\n\t\tUtil.removeClass(this.pullup, clsPrefix + prevVal)\n\t\tUtil.addClass(this.pullup, clsPrefix + status);\n\t\tthis.pullup.innerHTML = this.userConfig[status + \"Content\"];\n\t\tif (prevVal != status) {\n\t\t\tthis.trigger(\"statuschange\", {\n\t\t\t\tprevVal: prevVal,\n\t\t\t\tnewVal: status\n\t\t\t});\n\t\t\tif (status == \"loading\") {\n\t\t\t\tthis.isLoading = true;\n\t\t\t\tthis.trigger(\"loading\");\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t * notify pullup plugin to complete state after a remote data request\n\t * @memberOf PullUp\n\t * @return {PullUp}\n\t */\n\tcomplete: function() {\n\t\tvar self = this;\n\t\tvar xscroll = self.xscroll;\n\t\tself.isLoading = false;\n\t\tself._changeStatus(\"up\");\n\t\treturn self;\n\t}\n});\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = PullUp;\n}\n/** ignored by jsdoc **/\nelse if (window.XScroll && window.XScroll.Plugins) {\n\treturn XScroll.Plugins.PullUp = PullUp;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/plugins/pullup.js\n// module id = 28\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util'),\n  Base = require('./base'),\n  Core = require('./core'),\n  Animate = require('./animate'),\n  Hammer = require('./hammer'),\n  ScrollBar = require('./components/scrollbar'),\n  Controller = require('./components/controller');\n//reduced boundry pan distance\nvar PAN_RATE = 1 - 0.618;\n//constant for scrolling acceleration\nvar SCROLL_ACCELERATION = 0.0005;\n//constant for outside of boundry acceleration\nvar BOUNDRY_ACCELERATION = 0.03;\n//transform-origin\nvar transformOrigin = Util.prefixStyle(\"transformOrigin\");\n//transform\nvar transform = Util.prefixStyle(\"transform\");\n/** \n * @constructor\n * @param {object} cfg config for scroll\n * @param {number} cfg.SCROLL_ACCELERATION  acceleration for scroll, min value make the scrolling smoothly\n * @param {number} cfg.BOUNDRY_CHECK_DURATION duration for boundry bounce\n * @param {number} cfg.BOUNDRY_CHECK_EASING easing for boundry bounce\n * @param {number} cfg.BOUNDRY_CHECK_ACCELERATION acceleration for boundry bounce\n * @param {boolean} cfg.lockX just like overflow-x:hidden\n * @param {boolean} cfg.lockY just like overflow-y:hidden\n * @param {boolean} cfg.scrollbarX config if the scrollbar-x is visible\n * @param {boolean} cfg.scrollbarY config if the scrollbar-y is visible\n * @param {boolean} cfg.useTransition config if use css3 transition or raf for scroll animation\n * @param {boolean} cfg.bounce config if use has the bounce effect when scrolling outside of the boundry\n * @param {boolean} cfg.boundryCheck config if scrolling inside of the boundry\n * @param {boolean} cfg.preventDefault prevent touchstart\n * @param {boolean} cfg.preventTouchMove prevent touchmove\n * @param {string|HTMLElement}  cfg.container config for scroller's container which default value is \".xs-container\"\n * @param {string|HTMLElement}  cfg.content config for scroller's content which default value is \".xs-content\"\n * @param {object}  cfg.indicatorInsets  config scrollbars position {top: number, left: number, bottom: number, right: number}\n * @param {string}  cfg.stickyElements config for sticky-positioned elements\n * @param {string}  cfg.fixedElements config for fixed-positioned elements\n * @param {string}  cfg.touchAction config for touchAction of the scroller\n * @extends XScroll\n * @example\n * var xscroll = new SimuScroll({\n *    renderTo:\"#scroll\",\n *    lockX:false,\n *    scrollbarX:true\n * });\n * xscroll.render();\n */\nfunction SimuScroll(cfg) {\n  SimuScroll.superclass.constructor.call(this, cfg);\n}\n\nUtil.extend(SimuScroll, Core, {\n  /** \n   * @memberof SimuScroll\n   * @override\n   */\n  init: function() {\n    var self = this;\n    var defaultCfg = {\n      preventDefault: true,\n      preventTouchMove: true\n    };\n    SimuScroll.superclass.init.call(this);\n    self.userConfig = Util.mix(defaultCfg, self.userConfig);\n    self.SCROLL_ACCELERATION = self.userConfig.SCROLL_ACCELERATION || SCROLL_ACCELERATION;\n    self.BOUNDRY_ACCELERATION = self.userConfig.BOUNDRY_ACCELERATION || BOUNDRY_ACCELERATION;\n    self._initContainer();\n    self.resetSize();\n    //set overflow behaviors\n    self._setOverflowBehavior();\n    self.defaltConfig = {\n      lockY: self.userConfig.lockY,\n      lockX: self.userConfig.lockX\n    }\n    return self;\n  },\n  destroy: function() {\n    var self = this;\n    SimuScroll.superclass.destroy.call(this);\n    self.renderTo.style.overflow = \"\";\n    self.renderTo.style.touchAction = \"\";\n    self.container.style.transform = \"\";\n    self.container.style.transformOrigin = \"\";\n    self.content.style.transform = \"\";\n    self.content.style.transformOrigin = \"\";\n    self.off(\"touchstart mousedown\", self._ontouchstart);\n    self.off(\"touchmove\", self._ontouchmove);\n    self.destroyScrollBars();\n  },\n  /**\n   * set overflow behavior\n   * @return {boolean} [description]\n   */\n  _setOverflowBehavior: function() {\n    var self = this;\n    var renderTo = self.renderTo;\n    var computeStyle = getComputedStyle(renderTo);\n    self.userConfig.lockX = undefined === self.userConfig.lockX ? ((computeStyle['overflow-x'] == \"hidden\" || self.width == self.containerWidth) ? true : false) : self.userConfig.lockX;\n    self.userConfig.lockY = undefined === self.userConfig.lockY ? ((computeStyle['overflow-y'] == \"hidden\" || self.height == self.containerHeight) ? true : false) : self.userConfig.lockY;\n    self.userConfig.scrollbarX = undefined === self.userConfig.scrollbarX ? (self.userConfig.lockX ? false : true) : self.userConfig.scrollbarX;\n    self.userConfig.scrollbarY = undefined === self.userConfig.scrollbarY ? (self.userConfig.lockY ? false : true) : self.userConfig.scrollbarY;\n    return self;\n  },\n  /**\n   * reset lockX or lockY config to the default value\n   */\n  _resetLockConfig: function() {\n    var self = this;\n    self.userConfig.lockX = self.defaltConfig.lockX;\n    self.userConfig.lockY = self.defaltConfig.lockY;\n    return self;\n  },\n  /**\n   * init container\n   * @override\n   * @return {SimuScroll}\n   */\n  _initContainer: function() {\n    var self = this;\n    SimuScroll.superclass._initContainer.call(self);\n    if (self.__isContainerInited || !self.container || !self.content) return;\n    self.container.style[transformOrigin] = \"0 0\";\n    self.content.style[transformOrigin] = \"0 0\";\n    self.translate(0, 0);\n    self.__isContainerInited = true;\n    return self;\n  },\n  /**\n   * get scroll top value\n   * @memberof SimuScroll\n   * @return {number} scrollTop\n   */\n  getScrollTop: function() {\n    var transY = window.getComputedStyle(this.container)[transform].match(/[-\\d\\.*\\d*]+/g);\n    return transY ? Math.round(transY[5]) === 0 ? 0 : -Math.round(transY[5]) : 0;\n  },\n  /**\n   * get scroll left value\n   * @memberof SimuScroll\n   * @return {number} scrollLeft\n   */\n  getScrollLeft: function() {\n    var transX = window.getComputedStyle(this.content)[transform].match(/[-\\d\\.*\\d*]+/g);\n    return transX ? Math.round(transX[4]) === 0 ? 0 : -Math.round(transX[4]) : 0;\n  },\n  /**\n   * horizontal scroll absolute to the destination\n   * @memberof SimuScroll\n   * @param scrollLeft {number} scrollLeft\n   * @param duration {number} duration for animte\n   * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n   **/\n  scrollLeft: function(x, duration, easing, callback) {\n    if (this.userConfig.lockX) return;\n    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n    this.x = (undefined === x || isNaN(x) || 0 === x) ? 0 : -Math.round(x);\n    this._animate(\"x\", \"translateX(\" + this.x + \"px) scale(\" + this.scale + \")\" + translateZ, duration, easing, callback);\n    return this;\n  },\n  /**\n   * vertical scroll absolute to the destination\n   * @memberof SimuScroll\n   * @param scrollTop {number} scrollTop\n   * @param duration {number} duration for animte\n   * @param easing {string} easing functio for animate : ease-in | ease-in-out | ease | bezier(n,n,n,n)\n   **/\n  scrollTop: function(y, duration, easing, callback) {\n    if (this.userConfig.lockY) return;\n    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n    this.y = (undefined === y || isNaN(y) || 0 === y) ? 0 : -Math.round(y);\n    this._animate(\"y\", \"translateY(\" + this.y + \"px) \" + translateZ, duration, easing, callback);\n    return this;\n  },\n  /**\n   * translate the scroller to a new destination includes x , y , scale\n   * @memberof SimuScroll\n   * @param x {number} x\n   * @param y {number} y\n   * @param scale {number} scale\n   **/\n  translate: function(x, y, scale) {\n    var translateZ = this.userConfig.gpuAcceleration ? \" translateZ(0) \" : \"\";\n    this.x = x || this.x || 0;\n    this.y = y || this.y || 0;\n    this.scale = scale || this.scale || 1;\n    this.content.style[transform] = \"translate(\" + this.x + \"px,0px) scale(\" + this.scale + \") \" + translateZ;\n    this.container.style[transform] = \"translate(0px,\" + this.y + \"px) \" + translateZ;\n    return this;\n  },\n  _animate: function(type, transform, duration, easing, callback) {\n    var self = this;\n    var duration = duration || 0;\n    var easing = easing || \"quadratic\";\n    var el = type == \"y\" ? self.container : self.content;\n    var config = {\n      css: {\n        transform: transform\n      },\n      duration: duration,\n      easing: easing,\n      run: function(e) {\n        /**\n         * @event {@link SimuScroll#\"scroll\"}\n         */\n        self.trigger(\"scroll\", {\n          scrollTop: self.getScrollTop(),\n          scrollLeft: self.getScrollLeft(),\n          type: \"scroll\"\n        });\n      },\n      useTransition: self.userConfig.useTransition,\n      end: function(e) {\n        callback && callback();\n        if ((self[\"_bounce\" + type] === 0 || self[\"_bounce\" + type] === undefined) && easing != \"linear\") {\n          self['isScrolling' + type.toUpperCase()] = false;\n          self['isRealScrolling' + type.toUpperCase()] = false;\n          self.trigger(\"scrollend\", {\n            type: \"scrollend\",\n            scrollTop: self.getScrollTop(),\n            scrollLeft: self.getScrollLeft(),\n            zoomType: type,\n            duration: duration,\n            easing: easing\n          });\n        }\n      }\n    };\n    var timer = self.__timers[type] = self.__timers[type] || new Animate(el, config);\n    timer.stop();\n    timer.reset(config);\n    timer.run();\n    self.trigger(\"scrollanimate\", {\n      type: \"scrollanimate\",\n      scrollTop: -self.y,\n      scrollLeft: -self.x,\n      duration: duration,\n      easing: easing,\n      zoomType: type\n    })\n    return this;\n  },\n  _ontap: function(e) {\n    var self = this;\n    self.boundryCheck();\n    self._unPreventHref(e);\n    if (!self.isRealScrollingX && !self.isRealScrollingY) {\n      self._triggerClick(e);\n    }\n    self._preventHref(e);\n    self.isRealScrollingY = false;\n    self.isRealScrollingY = false;\n  },\n  _bindEvt: function() {\n    SimuScroll.superclass._bindEvt.call(this);\n    var self = this;\n    if (self.__isEvtBind) return;\n    self.__isEvtBind = true;\n    var pinch = new Hammer.Pinch();\n    self.mc.add(pinch);\n    self.on(\"touchstart mousedown\", self._ontouchstart, self);\n    self.on(\"touchmove\", self._ontouchmove, self);\n    self.on(\"tap\", self._ontap, self);\n    self.on(\"panstart\", self._onpanstart, self);\n    self.on(\"pan\", self._onpan, self);\n    self.on(\"panend\", self._onpanend, self);\n    //window resize\n    window.addEventListener(\"resize\", function(e) {\n      setTimeout(function() {\n        self.resetSize();\n        self.boundryCheck(0);\n        self.render();\n      }, 100);\n    }, self);\n\n    return this;\n  },\n  _ontouchstart: function(e) {\n    var self = this;\n    if (!(/(SELECT|INPUT|TEXTAREA)/i).test(e.target.tagName) && self.userConfig.preventDefault) {\n      e.preventDefault();\n    }\n    self.stop();\n  },\n  _ontouchmove: function(e) {\n    this.userConfig.preventTouchMove && e.preventDefault();\n  },\n  _onpanstart: function(e) {\n    this.userConfig.preventTouchMove && e.preventDefault();\n    var self = this;\n    var scrollLeft = self.getScrollLeft();\n    var scrollTop = self.getScrollTop();\n    self.stop();\n    self.translate(-scrollLeft, -scrollTop);\n    var threshold = self.mc.get(\"pan\").options.threshold;\n    self.thresholdY = e.direction == \"8\" ? threshold : e.direction == \"16\" ? -threshold : 0;\n    self.thresholdX = e.direction == \"2\" ? threshold : e.direction == \"4\" ? -threshold : 0;\n    return self;\n  },\n  _onpan: function(e) {\n    this.userConfig.preventTouchMove && e.preventDefault();\n    var self = this;\n    var boundry = self.boundry;\n    var userConfig = self.userConfig;\n    var boundryCheck = userConfig.boundryCheck;\n    var bounce = userConfig.bounce;\n    var scrollTop = self.__topstart || (self.__topstart = -self.getScrollTop());\n    var scrollLeft = self.__leftstart || (self.__leftstart = -self.getScrollLeft());\n    var y = userConfig.lockY ? Number(scrollTop) : Number(scrollTop) + (e.deltaY + self.thresholdY);\n    var x = userConfig.lockX ? Number(scrollLeft) : Number(scrollLeft) + (e.deltaX + self.thresholdX);\n    var containerWidth = self.containerWidth;\n    var containerHeight = self.containerHeight;\n    if (boundryCheck) {\n      //over top\n      y = y > boundry.top ? bounce ? (y - boundry.top) * PAN_RATE + boundry.top : boundry.top : y;\n      //over bottom\n      y = y < boundry.bottom - containerHeight ? bounce ? y + (boundry.bottom - containerHeight - y) * PAN_RATE : boundry.bottom - containerHeight : y;\n      //over left\n      x = x > boundry.left ? bounce ? (x - boundry.left) * PAN_RATE + boundry.left : boundry.left : x;\n      //over right\n      x = x < boundry.right - containerWidth ? bounce ? x + (boundry.right - containerWidth - x) * PAN_RATE : boundry.right - containerWidth : x;\n    }\n    //move to x,y\n    self.translate(x, y);\n    //pan trigger the opposite direction\n    self.directionX = e.type == 'panleft' ? 'right' : e.type == 'panright' ? 'left' : '';\n    self.directionY = e.type == 'panup' ? 'down' : e.type == 'pandown' ? 'up' : '';\n    self.trigger(\"scroll\", {\n      scrollTop: -y,\n      scrollLeft: -x,\n      triggerType: \"pan\",\n      type: \"scroll\"\n    });\n    return self;\n  },\n  _onpanend: function(e) {\n    var self = this;\n    var userConfig = self.userConfig;\n    var transX = self.computeScroll(\"x\", e.velocityX);\n    var transY = self.computeScroll(\"y\", e.velocityY);\n    var scrollLeft = transX ? transX.pos : 0;\n    var scrollTop = transY ? transY.pos : 0;\n    var duration;\n    if (transX && transY && transX.status == \"inside\" && transY.status == \"inside\" && transX.duration && transY.duration) {\n      //ensure the same duration\n      duration = Math.max(transX.duration, transY.duration);\n    }\n    transX && self.scrollLeft(scrollLeft, duration || transX.duration, transX.easing, function(e) {\n      self.boundryCheckX();\n    });\n    transY && self.scrollTop(scrollTop, duration || transY.duration, transY.easing, function(e) {\n      self.boundryCheckY();\n    });\n    //judge the direction\n    self.directionX = e.velocityX < 0 ? \"left\" : \"right\";\n    self.directionY = e.velocityY < 0 ? \"up\" : \"down\";\n    //clear start\n    self.__topstart = null;\n    self.__leftstart = null;\n    return self;\n  },\n  /**\n   * judge the scroller is out of boundry horizontally and vertically\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOut: function() {\n    return this.isBoundryOutLeft() || this.isBoundryOutRight() || this.isBoundryOutTop() || this.isBoundryOutBottom();\n  },\n  /**\n   * judge if the scroller is outsideof left\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOutLeft: function() {\n    return this.getBoundryOutLeft() > 0 ? true : false;\n  },\n  /**\n   * judge if the scroller is outsideof right\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOutRight: function() {\n    return this.getBoundryOutRight() > 0 ? true : false;\n  },\n  /**\n   * judge if the scroller is outsideof top\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOutTop: function() {\n    return this.getBoundryOutTop() > 0 ? true : false;\n  },\n  /**\n   * judge if the scroller is outsideof bottom\n   * @memberof SimuScroll\n   * @return {boolean} isBoundryOut\n   **/\n  isBoundryOutBottom: function() {\n    return this.getBoundryOutBottom() > 0 ? true : false;\n  },\n  /**\n   * get the offset value outsideof top\n   * @memberof SimuScroll\n   * @return {number} offset\n   **/\n  getBoundryOutTop: function() {\n    return -this.boundry.top - this.getScrollTop();\n  },\n  /**\n   * get the offset value outsideof left\n   * @memberof SimuScroll\n   * @return {number} offset\n   **/\n  getBoundryOutLeft: function() {\n    return -this.boundry.left - this.getScrollLeft();\n  },\n  /**\n   * get the offset value outsideof bottom\n   * @memberof SimuScroll\n   * @return {number} offset\n   **/\n  getBoundryOutBottom: function() {\n    return this.boundry.bottom - this.containerHeight + this.getScrollTop();\n  },\n  /**\n   * get the offset value outsideof right\n   * @memberof SimuScroll\n   * @return {number} offset\n   **/\n  getBoundryOutRight: function() {\n    return this.boundry.right - this.containerWidth + this.getScrollLeft();\n  },\n  /**\n   * compute scroll transition by zoomType and velocity\n   * @memberof SimuScroll\n   * @param {string} zoomType zoomType of scrolling\n   * @param {number} velocity velocity after panend\n   * @example\n   * var info = xscroll.computeScroll(\"x\",2);\n   * // return {pos:90,easing:\"easing\",status:\"inside\",duration:500}\n   * @return {Object}\n   **/\n  computeScroll: function(type, v) {\n    var self = this;\n    var userConfig = self.userConfig;\n    var boundry = self.boundry;\n    var pos = type == \"x\" ? self.getScrollLeft() : self.getScrollTop();\n    var boundryStart = type == \"x\" ? boundry.left : boundry.top;\n    var boundryEnd = type == \"x\" ? boundry.right : boundry.bottom;\n    var innerSize = type == \"x\" ? self.containerWidth : self.containerHeight;\n    var maxSpeed = userConfig.maxSpeed || 2;\n    var boundryCheck = userConfig.boundryCheck;\n    var bounce = userConfig.bounce;\n    var transition = {};\n    var status = \"inside\";\n    if (boundryCheck) {\n      if (type == \"x\" && (self.isBoundryOutLeft() || self.isBoundryOutRight())) {\n        self.boundryCheckX();\n        return;\n      } else if (type == \"y\" && (self.isBoundryOutTop() || self.isBoundryOutBottom())) {\n        self.boundryCheckY();\n        return;\n      }\n    }\n    if (type == \"x\" && self.userConfig.lockX) return;\n    if (type == \"y\" && self.userConfig.lockY) return;\n    v = v > maxSpeed ? maxSpeed : v < -maxSpeed ? -maxSpeed : v;\n    var a = self.SCROLL_ACCELERATION * (v / (Math.abs(v) || 1));\n    var a2 = self.BOUNDRY_ACCELERATION;\n    var t = isNaN(v / a) ? 0 : v / a;\n    var s = Number(pos) + t * v / 2;\n    //over top boundry check bounce\n    if (s < -boundryStart && boundryCheck) {\n      var _s = -boundryStart - pos;\n      var _t = (Math.sqrt(-2 * a * _s + v * v) + v) / a;\n      var v0 = v - a * _t;\n      var _t2 = Math.abs(v0 / a2);\n      var s2 = v0 / 2 * _t2;\n      t = _t + _t2;\n      s = bounce ? -boundryStart + s2 : -boundryStart;\n      status = \"outside\";\n    } else if (s > innerSize - boundryEnd && boundryCheck) {\n      var _s = (boundryEnd - innerSize) + pos;\n      var _t = (Math.sqrt(-2 * a * _s + v * v) - v) / a;\n      var v0 = v - a * _t;\n      var _t2 = Math.abs(v0 / a2);\n      var s2 = v0 / 2 * _t2;\n      t = _t + _t2;\n      s = bounce ? innerSize - boundryEnd + s2 : innerSize - boundryEnd;\n      status = \"outside\";\n    }\n    if (isNaN(s) || isNaN(t)) return;\n    transition.pos = s;\n    transition.duration = t;\n    transition.easing = Math.abs(v) > 2 ? \"circular\" : \"quadratic\";\n    transition.status = status;\n    var Type = type.toUpperCase();\n    self['isScrolling' + Type] = true;\n    self['isRealScrolling' + Type] = true;\n    return transition;\n  },\n  /**\n   * bounce to the boundry horizontal\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  boundryCheckX: function(duration, easing, callback) {\n    var self = this;\n    if (!self.userConfig.boundryCheck) return;\n    if (typeof arguments[0] == \"function\") {\n      callback = arguments[0];\n      duration = self.userConfig.BOUNDRY_CHECK_DURATION;\n      easing = self.userConfig.BOUNDRY_CHECK_EASING;\n    } else {\n      duration = duration === 0 ? 0 : self.userConfig.BOUNDRY_CHECK_DURATION,\n        easing = easing || self.userConfig.BOUNDRY_CHECK_EASING;\n    }\n    if (!self.userConfig.bounce || self.userConfig.lockX) return;\n    var boundry = self.boundry;\n    if (self.isBoundryOutLeft()) {\n      self.scrollLeft(-boundry.left, duration, easing, callback);\n    } else if (self.isBoundryOutRight()) {\n      self.scrollLeft(self.containerWidth - boundry.right, duration, easing, callback);\n    }\n    return self;\n  },\n  /**\n   * bounce to the boundry vertical\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  boundryCheckY: function(duration, easing, callback) {\n    var self = this;\n    if (!self.userConfig.boundryCheck) return;\n    if (typeof arguments[0] == \"function\") {\n      callback = arguments[0];\n      duration = self.userConfig.BOUNDRY_CHECK_DURATION;\n      easing = self.userConfig.BOUNDRY_CHECK_EASING;\n    } else {\n      duration = duration === 0 ? 0 : self.userConfig.BOUNDRY_CHECK_DURATION,\n        easing = easing || self.userConfig.BOUNDRY_CHECK_EASING;\n    }\n    if (!self.userConfig.boundryCheck || self.userConfig.lockY) return;\n    var boundry = self.boundry;\n    if (self.isBoundryOutTop()) {\n      self.scrollTop(-boundry.top, duration, easing, callback);\n    } else if (self.isBoundryOutBottom()) {\n      self.scrollTop(self.containerHeight - boundry.bottom, duration, easing, callback);\n    }\n    return self;\n  },\n  /**\n   * bounce to the boundry vertical and horizontal\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  boundryCheck: function(duration, easing, callback) {\n    this.boundryCheckX(duration, easing, callback);\n    this.boundryCheckY(duration, easing, callback);\n    return this;\n  },\n  /**\n   * stop scrolling immediatelly\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  stop: function() {\n    var self = this;\n    self.__timers.x && self.__timers.x.stop();\n    self.__timers.y && self.__timers.y.stop();\n    if (self.isScrollingX || self.isScrollingY) {\n      var scrollTop = self.getScrollTop(),\n        scrollLeft = self.getScrollLeft();\n      self.trigger(\"scrollend\", {\n        scrollTop: scrollTop,\n        scrollLeft: scrollLeft\n      });\n      self.trigger(\"stop\", {\n        scrollTop: scrollTop,\n        scrollLeft: scrollLeft\n      })\n      self.isScrollingX = false;\n      self.isScrollingY = false;\n    }\n    return self;\n  },\n  /**\n   * render scroll\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   **/\n  render: function() {\n    var self = this;\n    SimuScroll.superclass.render.call(this);\n    //fixed for scrollbars\n    if (getComputedStyle(self.renderTo).position == \"static\") {\n      self.renderTo.style.position = \"relative\";\n    }\n    self.renderTo.style.overflow = \"hidden\";\n    self.initScrollBars();\n    self.initController();\n    return self;\n  },\n  /**\n   * init scrollbars\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   */\n  initScrollBars: function() {\n    var self = this;\n    if (!self.userConfig.boundryCheck) return;\n    var indicatorInsets = self.userConfig.indicatorInsets;\n    if (self.userConfig.scrollbarX) {\n      self.scrollbarX = self.scrollbarX || new ScrollBar({\n        xscroll: self,\n        type: \"x\",\n        spacing: indicatorInsets.spacing\n      });\n      self.scrollbarX.render();\n      self.scrollbarX._update();\n      self.scrollbarX.hide();\n    }\n    if (self.userConfig.scrollbarY) {\n      self.scrollbarY = self.scrollbarY || new ScrollBar({\n        xscroll: self,\n        type: \"y\",\n        spacing: indicatorInsets.spacing\n      });\n      self.scrollbarY.render();\n      self.scrollbarY._update();\n      self.scrollbarY.hide();\n    }\n    return self;\n  },\n  /**\n   * destroy scrollbars\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   */\n  destroyScrollBars: function() {\n    this.scrollbarX && this.scrollbarX.destroy();\n    this.scrollbarY && this.scrollbarY.destroy();\n    return this;\n  },\n  /**\n   * init controller for multi-scrollers\n   * @memberof SimuScroll\n   * @return {SimuScroll}\n   */\n  initController: function() {\n    var self = this;\n    self.controller = self.controller || new Controller({\n      xscroll: self\n    });\n    return self;\n  },\n  _unPreventHref: function(e) {\n    var target = Util.findParentEl(e.target,'a',this.renderTo);\n    if(!target) return;\n    if (target.tagName.toLowerCase() == \"a\") {\n      var href = target.getAttribute(\"data-xs-href\");\n      if (href) {\n        target.setAttribute(\"href\", href);\n      }\n    }\n  },\n  _preventHref: function(e) {\n    var target = Util.findParentEl(e.target,'a',this.renderTo);\n    if(!target) return;\n    if (target.tagName.toLowerCase() == \"a\") {\n      var href = target.getAttribute(\"href\");\n      href && target.setAttribute(\"href\", \"javascript:void(0)\");\n      href && target.setAttribute(\"data-xs-href\", href);\n    }\n  },\n  _triggerClick: function(e) {\n    var target = e.target;\n    if (!(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName)) {\n      var ev = document.createEvent('MouseEvents');\n      ev.initMouseEvent('click', true, true, e.view, 1,\n        target.screenX, target.screenY, target.clientX, target.clientY,\n        e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,\n        0, null);\n      target.dispatchEvent(ev);\n    }\n  }\n});\n\nif (typeof module == 'object' && module.exports) {\n  module.exports = SimuScroll;\n}\n/** ignored by jsdoc **/\nelse {\n  return SimuScroll;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/simulate-scroll.js\n// module id = 29\n// module chunks = 0","define(function(require, exports, module) {\n\"use strict\";\nvar Util = require('./util'),\n\tBase = require('./base'),\n\tTimer = require('./timer'),\n\tAnimate = require('./animate'),\n\tHammer = require('./hammer'),\n\tSimuScroll = require('./simulate-scroll'),\n\tOriginScroll = require('./origin-scroll');\nvar XScroll = function(cfg) {\n\t\tvar _ = cfg && cfg.useOriginScroll ? OriginScroll : SimuScroll;\n\t\treturn new _(cfg);\n\t}\n/**\n * Util\n * @namespace Util\n * @type {Object}\n */\nXScroll.Util = Util;\n/**\n * Base\n * @namespace Base\n * @type {Base}\n */\nXScroll.Base = Base;\n/**\n * Timer\n * @namespace Timer\n * @type {Timer}\n */\nXScroll.Timer = Timer;\n/**\n * Animate\n * @namespace Animate\n * @type {Animate}\n */\nXScroll.Animate = Animate;\n/**\n * Hammer\n * @namespace Hammer\n * @type {Hammer}\n */\nXScroll.Hammer = Hammer;\n/**\n * plugins\n * @namespace Plugins\n * @type {Object}\n */\nXScroll.Plugins = {};\n\nif (typeof module == 'object' && module.exports) {\n\tmodule.exports = XScroll;\n}\n/** ignored by jsdoc **/\nelse {\n\treturn window.XScroll = XScroll;\n}\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/xscroll/build/cmd/xscroll.js\n// module id = 30\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_31__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"classnames\"\n// module id = 31\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_32__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 32\n// module chunks = 0"],"sourceRoot":""}